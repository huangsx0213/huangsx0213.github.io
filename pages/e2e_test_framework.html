<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>E2E Automatic Testing Framework</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f9;
            color: #333;
        }
        .code-container, .directory-container {
            background-color: #282c34;
            color: #abb2bf;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
            overflow-x: auto;
            position: relative;
        }
        .code-container pre, .directory-container pre {
            margin: 0;
        }
        .class-header, .directory-header {
            font-size: 1.5em;
            color: #61dafb;
            margin-bottom: 10px;
        }
        .copy-button, .return-button {
            position: absolute;
            right: 20px;
            top: 20px;
            background-color: #61dafb;
            color: #282c34;
            border: none;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 3px;
            margin-left: 5px;
        }
        .return-button {
            right: 100px;
        }
        .directory a {
            color: #98c379;
            text-decoration: none;
        }
        .directory a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <h1>E2E Automatic Testing Framework</h1>
    <div class="directory-container">
        <div class="directory-header">File Directory</div>
        <pre class="directory">./
│   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_main_py">main.py</a>
│   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_README_md">README.md</a>
│   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_yaml_config_cli_py">yaml_config_cli.py</a>
│   ├── configs/
│   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_configs_api_test_config_yaml">api_test_config.yaml</a>
│   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_configs_e2e_test_config_yaml">e2e_test_config.yaml</a>
│   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_configs_logging_config_yaml">logging_config.yaml</a>
│   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_configs_saved_fields_yaml">saved_fields.yaml</a>
│   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_configs_web_pt_config_yaml">web_pt_config.yaml</a>
│   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_configs_web_test_config_yaml">web_test_config.yaml</a>
│   ├── libraries/
│   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries___init___py">__init__.py</a>
│   │   ├── api/
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api_api_robot_generator_py">api_robot_generator.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api_api_test_keywords_py">api_test_keywords.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api_api_test_loader_py">api_test_loader.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api_body_generator_py">body_generator.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api_headers_generator_py">headers_generator.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api_request_sender_py">request_sender.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api_response_handler_py">response_handler.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api_saved_fields_manager_py">saved_fields_manager.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api_template_renderer_py">template_renderer.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api_variable_generator_py">variable_generator.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api___init___py">__init__.py</a>
│   │   ├── common/
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_common_config_manager_py">config_manager.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_common_db_py">db.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_common_db_validator_py">db_validator.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_common_gen_temp_default_py">gen_temp_default.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_common_log_manager_py">log_manager.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_common_utility_helpers_py">utility_helpers.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_common___init___py">__init__.py</a>
│   │   ├── e2e/
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_e2e_e2e_robot_generator_py">e2e_robot_generator.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_e2e___init___py">__init__.py</a>
│   │   ├── performance/
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_performance_web_pt_py">web_pt.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_performance_web_pt_loader_py">web_pt_loader.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_performance_web_pt_reporter_py">web_pt_reporter.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_performance_web_pt_robot_generator_py">web_pt_robot_generator.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_performance_web_pt_robot_keyword_py">web_pt_robot_keyword.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_performance___init___py">__init__.py</a>
│   │   ├── robot/
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_robot_robot_dashboard_generator_py">robot_dashboard_generator.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_robot_robot_report_data_py">robot_report_data.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_robot_robot_result_visitor_py">robot_result_visitor.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_robot___init___py">__init__.py</a>
│   │   ├── web/
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_custom_action_executor_py">custom_action_executor.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_page_object_py">page_object.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_table_verifier_py">table_verifier.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_webdriver_factory_py">webdriver_factory.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_actions_py">web_actions.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_robot_generator_py">web_robot_generator.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_test_loader_py">web_test_loader.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web___init___py">__init__.py</a>
│   │   │   ├── web_action/
│   │   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_alert_actions_py">alert_actions.py</a>
│   │   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_base_py">base.py</a>
│   │   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_basic_actions_py">basic_actions.py</a>
│   │   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_browser_actions_py">browser_actions.py</a>
│   │   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_cookie_actions_py">cookie_actions.py</a>
│   │   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_decorators_py">decorators.py</a>
│   │   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_frame_window_actions_py">frame_window_actions.py</a>
│   │   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_javascript_actions_py">javascript_actions.py</a>
│   │   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_js_py">js.py</a>
│   │   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_screenshot_actions_py">screenshot_actions.py</a>
│   │   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_table_actions_py">table_actions.py</a>
│   │   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_verification_actions_py">verification_actions.py</a>
│   │   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_wait_actions_py">wait_actions.py</a>
│   │   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action___init___py">__init__.py</a>
│   ├── templates/
│   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_templates_rf_report_template_html">rf_report_template.html</a>
│   ├── testing_server/
│   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_testing_server_positions_json">positions.json</a>
│   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_testing_server_server_py">server.py</a>
</pre>
    </div>
    <div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_README_md">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\README.md</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre># Automated Testing Framework User Manual

## Table of Contents
1. Framework Features
2. Installation and Setup
3. Configuration
4. API Test Cases Excel Structure
5. Web UI Test Cases Excel Structure
6. Writing Test Cases
7. Running Tests
8. Viewing Results
9. Best Practices
10. Troubleshooting
11. Advanced Features
12. Maintenance and Updates

## 1. Framework Features

This automated testing framework offers the following features:

1. Multi-type Testing Support: Supports API testing, Web UI testing, and End-to-End (E2E) testing.
2. Flexible Configuration: Uses YAML files for configuration, making it easy to modify and maintain.
3. Data-Driven: Manages test cases using Excel files, supporting parameterized testing.
4. Dynamic Value Support: Supports dynamically generated values in API tests, such as UUID, timestamps, etc.
5. Variable Management: Supports sharing and reusing variables between test cases.
6. Page Object Model: Uses page object pattern in Web UI testing, improving code reusability and maintainability.
7. Custom Operations: Supports defining and using custom Python operations in Web UI tests.
8. Detailed Logs and Reports: Generates detailed HTML reports and logs, including failure screenshots.
9. Flexible Test Case Selection: Supports filtering specific tests by tags or test case IDs.
10. Environment Management: Supports multi-environment configuration, making it easy to switch between different environments.
11. Error Handling and Retry Mechanism: Implements robust error handling and test retry logic.
12. CI-Friendly: Easy to integrate into CI/CD processes.
13. Extensibility: Modular framework design, easy to add new features and customize.
14. Sanity Check Feature: Supports automatic skipping of subsequent tests if a designated sanity check test fails.

## 2. Installation and Setup

### 2.1 Python and pip

Ensure you have Python 3.7 or higher installed. You can download it from [python.org](https://www.python.org/downloads/).

### 2.2 Required Python Packages

Install the required packages using pip:

```bash
pip install -r requirements.txt
```

The `requirements.txt` file should include (but is not limited to):

```
robot-framework
requests
pandas
openpyxl
pyyaml
jinja2
jsonpath-ng
lxml
selenium
pillow
numpy
```

### 2.3 WebDriver Setup

For Web UI testing, ensure you have the appropriate WebDriver installed and configured in your system PATH:
- ChromeDriver for Google Chrome
- EdgeDriver for Microsoft Edge

### 2.4 Project Structure

Ensure your project follows this structure:
```
project_root/
├── configs/
│   ├── api_test_config.yaml
│   ├── web_test_config.yaml
│   ├── e2e_test_config.yaml
│   └── logging_config.yaml
├── libraries/
│   ├── api/
│   ├── web/
│   ├── e2e/
│   ├── robot/
│   └── common/
├── test_cases/
│   ├── api_test_cases.xlsx
│   ├── web_test_cases.xlsx
│   └── e2e_test_cases.xlsx
├── templates/
│   └── rf_report_template.html
├── report/
├── main.py
├── yaml_config_cli.py
└── requirements.txt
```

## 3. Configuration

### 3.1 API Test Configuration (api_test_config.yaml)

```yaml
active_environment: DEV
test_cases_path: 'test_cases/api_test_cases.xlsx'
clear_saved_fields_after_test: true
tc_id_list: []
tags: []
```

- `active_environment`: Currently active test environment (e.g., DEV, SIT, UAT, PROD)
- `test_cases_path`: Path to the API test cases Excel file
- `clear_saved_fields_after_test`: Whether to clear saved fields after each test
- `tc_id_list`: List of specific test case IDs to execute
- `tags`: List of tags to filter test cases

### 3.2 Web UI Test Configuration (web_test_config.yaml)

```yaml
active_environment: SIT
test_case_path: 'test_cases/web_test_cases.xlsx'
tc_id_list: []
tags: []
```

- `active_environment`: Currently active test environment
- `test_case_path`: Path to the Web UI test cases Excel file
- `tc_id_list`: List of specific test case IDs to execute
- `tags`: List of tags to filter test cases

### 3.3 End to end Test Configuration (e2e_test_config.yaml)

```yaml
active_environment: SIT
test_case_path: 'test_cases/e2e_test_cases.xlsx'
tc_id_list: []
tags: []
```

- `active_environment`: Currently active test environment
- `test_case_path`: Path to the End-to-End test cases Excel file
- `tc_id_list`: List of specific test case IDs to execute
- `tags`: List of tags to filter test cases
- 
### 3.4 Using yaml_config_cli.py

You can use the `yaml_config_cli.py` script to modify configuration files from the command line. For example:

```bash
python yaml_config_cli.py configs/api_test_config.yaml --update active_environment PROD
python yaml_config_cli.py configs/api_test_config.yaml --add-to-list tc_id_list TC001
python yaml_config_cli.py configs/api_test_config.yaml --remove-from-list tags deprecated
```

## 4. API Test Cases Excel Structure

### 4.1 Sheets:
1. API: Main test case information
2. BodyTemplates: Request body templates
3. BodyDefaults: Default values for request bodies
4. Headers: Header templates
5. Endpoints: Environment-specific endpoint configurations

### 4.2 API Sheet Columns:
| Column Name | Description | Possible Values | Logic |
|-------------|-------------|-----------------|-------|
| TCID | Unique test case identifier | String, e.g., "TC001" | Must be unique |
| Name | Test case name | String | Descriptive name |
| Descriptions | Test case description | String | Detailed explanation of test purpose |
| Run | Whether to execute this case | "Y" or "N" | Y means execute, N means skip |
| Tags | Case tags | Comma-separated string | For categorizing and filtering cases |
| Endpoint | API endpoint name | String | Must match definitions in Endpoints sheet |
| Headers | Request header template name | String | Must match definitions in Headers sheet |
| Body Template | Request body template name | String | Must match definitions in BodyTemplates sheet |
| Body Default | Default request body name | String | Must match definitions in BodyDefaults sheet |
| Body Override | Custom request body fields | JSON format string | Overrides or adds to default request body |
| Exp Result | Expected results | JSONPath expressions | Used to validate response content |
| Save Fields | Save response fields | JSONPath expressions | Used to save specific fields from the response |
| Conditions | Special conditions | Specific format string | E.g., [Checkwith], [TestSetup], [TestTeardown] |
| Wait | Wait time after test execution | Number (seconds) | Pause execution for specified time |

#### Sanity Check:
To designate a test case as a sanity check:
1. In the 'Tags' column of the API sheet, include the tag 'sanity check' (case-insensitive).
2. If a test case with the 'sanity check' tag fails, all subsequent test cases will be automatically skipped.

Example:
```
TCID | Name           | ... | Tags
-----|----------------|-----|----------------
TC001| Sanity Check   | ... | critical, sanity check
TC002| Regular Test   | ... | regression
```

### 4.3 BodyTemplates Sheet:
| Column Name | Description | Possible Values | Logic |
|-------------|-------------|-----------------|-------|
| TemplateName | Template name | String | Unique identifier |
| Content | Template content | JSON or XML format string | Can include Jinja2 template syntax |
| Format | Template format | "json" or "xml" | Specifies the format of the template |

### 4.4 BodyDefaults Sheet:
| Column Name | Description | Possible Values | Logic |
|-------------|-------------|-----------------|-------|
| Name | Default value name | String | Unique identifier |
| Content | Default value content | JSON format string | Provides default request body content |

### 4.5 Headers Sheet:
| Column Name | Description | Possible Values | Logic |
|-------------|-------------|-----------------|-------|
| HeaderName | Header template name | String | Unique identifier |
| Content | Header content | YAML format string | Defines request headers |

### 4.6 Endpoints Sheet:
| Column Name | Description | Possible Values | Logic |
|-------------|-------------|-----------------|-------|
| Environment | Environment name | DEV, SIT, UAT, PROD, etc. | Corresponds to active_environment in config file |
| Endpoint | Endpoint name | String | Unique identifier |
| Method | HTTP method | GET, POST, PUT, DELETE, PATCH | Specifies request method |
| Path | Request path | URL path string | Can include path parameters |

## 5. Web UI Test Cases Excel Structure

### 5.1 Sheets:
1. TestCases: Main test case information
2. TestSteps: Steps for each test case
3. TestData: Test data for parameterization
4. Locators: Element locators
5. PageModules: Page object definitions
6. WebEnvironments: Environment-specific configurations
7. CustomActions: Custom Python actions

### 5.2 TestCases Sheet:
| Column Name | Description | Possible Values | Logic |
|-------------|-------------|-----------------|-------|
| Case ID | Unique test case identifier | String, e.g., "UITC001" | Must be unique |
| Name | Test case name | String | Descriptive name |
| Descriptions | Test case description | String | Detailed explanation of test purpose |
| Run | Whether to execute this case | "Y" or "N" | Y means execute, N means skip |
| Tags | Case tags | Comma-separated string | For categorizing and filtering cases |

#### Sanity Check:
To designate a test case as a sanity check:
1. In the 'Tags' column of the TestCases sheet, include the tag 'sanity check' (case-insensitive).
2. If a test case with the 'sanity check' tag fails, all subsequent test cases will be automatically skipped.

Example:
```
Case ID | Name           | ... | Tags
--------|----------------|-----|----------------
UITC001 | Sanity Check   | ... | critical, sanity check
UITC002 | Regular Test   | ... | regression
```

### 5.3 TestSteps Sheet:
| Column Name | Description | Possible Values | Logic |
|-------------|-------------|-----------------|-------|
| Case ID | Corresponding test case ID | String | Must match Case ID in TestCases |
| Step ID | Unique identifier for each step | Integer | Defines execution order of steps |
| Page Name | Page object name | String | Must match definitions in PageModules |
| Module Name | Module name | String | Specific module within the page object |
| Run | Whether to execute this step | "Y" or "N" | Y means execute, N means skip |

### 5.4 TestData Sheet:
| Column Name | Description | Possible Values | Logic |
|-------------|-------------|-----------------|-------|
| Case ID | Corresponding test case ID | String | Must match Case ID in TestCases |
| Data Set | Data set identifier | String | Used to distinguish multiple sets of test data |
| Parameter Name | Parameter name | String | Corresponds to parameters in TestSteps |
| Value | Parameter value | Any type | Actual test data |
| Data Type | Data type | string, integer, json, etc. | Specifies the data type of the parameter |

### 5.5 Locators Sheet:
| Column Name | Description | Possible Values | Logic |
|-------------|-------------|-----------------|-------|
| Page | Page name | String | Corresponds to pages in PageModules |
| Element Name | Element name | String | Unique identifier |
| Locator Type | Location method | id, name, xpath, css, etc. | Selenium-supported location methods |
| Locator Value | Location value | String | Specific location expression |

### 5.6 PageModules Sheet:
| Column Name | Description | Possible Values | Logic |
|-------------|-------------|-----------------|-------|
| Page Name | Page name | String | Unique identifier |
| Module Name | Module name | String | Functional module within the page |
| Element Name | Element name | String | Corresponds to Element Name in Locators |
| Actions | Action name | String | E.g., click, input, verify, etc. |
| Parameter Name | Parameters | Comma-separated string | Parameters needed for the action |
| Highlight | Whether to highlight the element | "Y" or "N" | Y means highlight, N means don't highlight |
| Screenshot | Whether to take a screenshot | "Y" or "N" | Y means take screenshot, N means don't |
| Wait | Wait time after action (in seconds) | Number | Pause execution for specified time |
| Run | Whether to execute this action | "Y" or "N" | Y means execute, N means skip |

### 5.7 WebEnvironments Sheet:
| Column Name | Description | Possible Values | Logic |
|-------------|-------------|-----------------|-------|
| Environment | Environment name | DEV, SIT, UAT, PROD, etc. | Corresponds to active_environment in config file |
| URL | Environment URL | Complete URL string | Base URL of the test environment |
| Browser | Browser type | chrome, firefox, edge, etc. | Specifies the browser to use |

### 5.8 CustomActions Sheet:
| Column Name   | Description              | Possible Values | Logic |
|---------------|--------------------------|-----------------|-------|
| Action Name   | Custom action name       | String | Unique identifier |
| CustomAction1 | CustomAction python code | String | Custom python to be executed |

## 6. Writing Test Cases

### 6.1 API Test Cases

1. Fill in the API sheet with test case details.
2. Create body templates in the BodyTemplates sheet.
3. Define default body values in the BodyDefaults sheet.
4. Create header templates in the Headers sheet.
5. Define endpoints in the Endpoints sheet.

#### Body-related fields:
- Body Template: Use Jinja2 syntax for dynamic values.
- Body Default: Provide default values in JSON format.
- Body Override: Override default values or add new fields in JSON format.
  - Supports dynamic values using `${variable_name}` syntax.
  - These variables are replaced with actual values from the Robot Framework variable scope.
- Use `{{variable_name}}` in templates for dynamic values.
- Supported dynamic values: uetr, uuid4, value_date, msg_id, timestamp, formated_timestamp, bic

#### Expected Results:
- Exp Result: Define expected results for assertions.
  - Supports dynamic values using `${variable_name}` syntax.
  - These variables are replaced with actual values from the Robot Framework variable scope.
- Use JSONPath for precise assertions on the response.

#### Headers:
- Define headers in YAML format in the Headers sheet.
- Use `{{variable_name}}` for dynamic values.
- Use `${variable_name}` for Robot Framework variables.

#### Example of using dynamic values:
```
Body Override: {"user_id": "${USER_ID}", "timestamp": "{{timestamp}}"}
Exp Result: $.response.status=${EXPECTED_STATUS}
```

### 6.2 Web UI Test Cases

1. Fill in the TestCases sheet with test case details.
2. Define test steps in the TestSteps sheet.
3. Provide test data in the TestData sheet.
4. Define element locators in the Locators sheet.
5. Create page objects and modules in the PageModules sheet.
6. Configure environments in the WebEnvironments sheet.
7. Define custom actions in the CustomActions sheet if needed.

## 7. Running Tests

### 7.1 API Tests
```bash
python main.py --api
```

### 7.2 Web UI Tests
```bash
python main.py --web
```

### 7.3 E2E Tests
```bash
python main.py --e2e
```

### 7.4 Running Specific Test Cases or Tags

You can specify test case IDs or tags in the respective configuration files (api_test_config.yaml, web_test_config.yaml, e2e_test_config.yaml) to run specific tests.

## 8. Viewing Results

- Test results are generated in the `report` folder.
- Open `report.html` for a detailed test report.
- Check `log.html` for step-by-step execution logs.
- Screenshots for Web UI tests are embedded in the logs.
- A custom dashboard (dashboard.html) is generated with test statistics and charts.

## 9. Best Practices

1. Use meaningful test case IDs and names.
2. Leverage tags for easy filtering and organization.
3. Maintain clear and concise test step descriptions.
4. Regularly update and maintain test data.
5. Keep locators and page objects up-to-date with the application.
6. Use parameterization to create data-driven tests.
7. Implement proper error handling and logging in test scripts.
8. Regularly review and optimize test suites for efficiency.
9. Use the 'sanity check' tag for critical tests that, if failed, should prevent further testing.
10. Order your test cases so that sanity checks run first, followed by other tests.

## 10. Troubleshooting

- Check log files for detailed error messages.
- Verify configuration files for correct settings.
- Ensure all required dependencies are installed.
- Validate Excel file structure and content.
- Check for proper WebDriver setup for Web UI tests.
- If you encounter "ModuleNotFoundError", ensure you've installed all required packages (see Section 2.2).

## 11. Advanced Features

### 11.1 Dynamic Values in API Tests

The framework supports the use of dynamic values in two key areas of API tests:

1. Body Override
2. Expected Results (Exp Result)

#### Usage:
- Use the syntax `${variable_name}` in these fields to reference Robot Framework variables.
- These variables will be dynamically replaced with their actual values during test execution.
- This feature allows for more flexible and reusable test cases, especially when combined with Robot Framework's variable management capabilities.

#### Example:
```yaml
Body Override: {"token": "${AUTH_TOKEN}", "user_id": "${CURRENT_USER_ID}"}
Exp Result: $.status_code=200
$.response.user.name=${EXPECTED_USER_NAME}
```

### 11.2 Custom Python Actions in Web UI Tests

You can define custom Python actions in the CustomActions sheet of the Web UI test cases Excel file. These actions can be called from your test steps to perform complex operations or validations.

### 11.3 Sanity Check Implementation

The framework now supports a 'sanity check' feature:

- Tests tagged with 'sanity check' (case-insensitive) are treated as critical tests.
- If a sanity check test fails, all subsequent tests in the suite will be automatically skipped.
- This feature helps to quickly identify fundamental issues and saves time by not running further tests when basic functionality fails.

To use this feature:
1. Add the tag 'sanity check' to critical test cases in your Excel file.
2. Run your test suite as usual.
3. If a sanity check fails, you'll see skip messages for subsequent tests in the logs.

Example log output when a sanity check fails:
```
FAIL: Sanity Check Test
SKIP: Subsequent Test 1 - Skip current test TC002 due to Sanity Check failure
SKIP: Subsequent Test 2 - Skip current test TC003 due to Sanity Check failure
```

This feature is automatically enabled and requires no additional configuration beyond tagging your tests appropriately.

## 12. Maintenance and Updates

- Regularly update your Python packages to ensure compatibility and security:
  ```bash
  pip install --upgrade -r requirements.txt
  ```
- Keep your WebDrivers up-to-date with your browser versions.
- Periodically review and update your test cases to align with application changes.
- Consider version controlling your test cases and configurations for better tracking and collaboration.
- Implement a process for reviewing and updating test data to ensure it remains relevant and effective.
- Regularly backup your test artifacts, including Excel files, configurations, and custom scripts.
- Set up automated jobs to run your test suites on a scheduled basis, ensuring continuous validation of your application.

This comprehensive guide provides a complete overview of the automated testing framework, including setup, configuration, test case creation, execution, and maintenance. It covers both API and Web UI testing scenarios, as well as advanced features like dynamic value handling in API tests. By following this guide, users should be able to effectively leverage the framework for their testing needs.
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_configs_api_test_config_yaml">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\configs\api_test_config.yaml</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre># The active environment to be used for the tests.
# This should match one of the environment keys defined below in 'environments'.
active_environment: DEV
# Path to the excel file containing the test cases.
test_cases_path: 'test_cases/api_test_cases.xlsx'
clear_saved_fields_after_test: false
# List of Test Case IDs to run.
# Specify one or more Test Case IDs here.
# If this list is empty, all test cases will be run.
tc_id_list:


# List of tags to filter test cases.
# Only test cases which contain any of these tags will be run.
# If this list is empty, all test cases will be run.
tags:

database:
  DEV:
    type: postgresql  # or oracle
    user: vhuang1
    password: Apj.com1
    host: 10.191.111.77
    port: 5432
    database: postgres
  UAT:
    type: oracle
    user: uat_user
    password: uat_password
    host: uat_host
    port: 1521
    service_name: uat_service_name
    min_connections: 1
    max_connections: 10
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_configs_e2e_test_config_yaml">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\configs\e2e_test_config.yaml</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>active_environment: SIT
test_cases_path : test_cases/e2e_test_cases.xlsx
# List of Test Case IDs to run.
# Specify one or more Test Case IDs here.
# If this list is empty, all test cases will be run.
tc_id_list:
- TC001
- TC002
- TC003
# List of tags to filter test cases.
# Only test cases which contain any of these tags will be run.
# If this list is empty, all test cases will be run.
tags:
  - tag1
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_configs_logging_config_yaml">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\configs\logging_config.yaml</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>version: 1
disable_existing_loggers: False

formatters:
  standard:
    format: "%(asctime)s - %(name)s - %(levelname)s - %(message)s"

handlers:
  console:
    class: logging.StreamHandler
    formatter: standard
    level: DEBUG
    stream: ext://sys.stdout
  file:
    class: logging.FileHandler
    formatter: standard
    level: DEBUG
    mode: "w"


root:
  level: INFO
  handlers: [console,file]</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_configs_saved_fields_yaml">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\configs\saved_fields.yaml</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>MyToken: vt9EoVlxRKGWWMwx6iJoaGQQLlvAE4zXwuOTfeXKHZFaqO9US2iudZ5B5-BtFFS_3t3mrFKLj2oPo5aEw2rQ0wudQo9b6JRbB4LV0LbzQMrbWFA-EXfhMg==</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_configs_web_pt_config_yaml">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\configs\web_pt_config.yaml</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>active_environment: SIT
test_cases_path : test_cases/web_pt_cases.xlsx
# List of Test Case IDs to run.
# Specify one or more Test Case IDs here.
# If this list is empty, all test cases will be run.
tc_id_list:

# List of tags to filter test cases.
# Only test cases which contain any of these tags will be run.
# If this list is empty, all test cases will be run.
tags:

</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_configs_web_test_config_yaml">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\configs\web_test_config.yaml</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>active_environment: SIT
test_cases_path : test_cases/web_test_cases.xlsx
# List of Test Case IDs to run.
# Specify one or more Test Case IDs here.
# If this list is empty, all test cases will be run.
tc_id_list:

# List of tags to filter test cases.
# Only test cases which contain any of these tags will be run.
# If this list is empty, all test cases will be run.
tags:

</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries___init___py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\__init__.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre></pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api___init___py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\api\__init__.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre></pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api_api_robot_generator_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\api\api_robot_generator.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import logging
import os
from typing import Dict, List
import pandas as pd
from libraries.api.api_test_loader import APITestLoader
from libraries.common.config_manager import ConfigManager
from libraries.common.utility_helpers import PROJECT_ROOT
from robot.api import TestSuite
from libraries.common.log_manager import logger_instance

class APIRobotCasesGenerator:
    def __init__(self, test_config_path: str = None, test_cases_path: str = None) -&gt; None:
        self.project_root: str = PROJECT_ROOT
        self.test_config_path = test_config_path
        self.test_cases_path = test_cases_path

        try:
            self._load_configuration()
            self._initialize_components()
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Initialization failed: {str(e)}")
            raise RuntimeError(f"{self.__class__.__name__}: Initialization failed: {str(e)}")

    def _load_configuration(self):
        try:
            self.test_config_path = (
                os.path.join(self.project_root, 'configs', 'api_test_config.yaml')
                if self.test_config_path is None
                else self.test_config_path
            )
            self.test_config: Dict = ConfigManager.load_yaml(self.test_config_path)
            logging.info(f"{self.__class__.__name__}: Configuration loaded successfully from {self.test_config_path}")
        except FileNotFoundError:
            logging.error(f"{self.__class__.__name__}: Config file not found at {self.test_config_path}")
            raise
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error loading configuration: {str(e)}")
            raise

    def _initialize_components(self):
        try:
            default_test_cases_path: str = os.path.join('test_cases', 'api_test_cases.xlsx')
            self.test_cases_path: str = (
                os.path.join(self.project_root, self.test_config.get('test_cases_path', default_test_cases_path))
                if self.test_cases_path is None
                else self.test_cases_path
            )

            if not os.path.exists(self.test_cases_path):
                logging.error(f"{self.__class__.__name__}: Test cases file not found at {self.test_cases_path}")
                raise FileNotFoundError(f"Test cases file does not exist: {self.test_cases_path}")

            self.test_cases_df = APITestLoader(self.test_cases_path)
            logging.info(f"{self.__class__.__name__}: Components initialized successfully")
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error initializing components: {str(e)}")
            raise

    def create_test_suite(self, tc_id_list: List[str] = None, tags: List[str] = None, test_suite=None) -&gt; TestSuite:
        try:
            self.api_suite = test_suite if test_suite else TestSuite('API TestSuite')
            self.api_suite.teardown.config(name='clear_saved_fields', args=[])
            self._configure_test_resources()
            tc_id_list = tc_id_list or self.test_config.get('tc_id_list', [])
            tags = tags or self.test_config.get('tags', [])

            try:
                filtered_cases = self.test_cases_df.filter_cases(tcid_list=tc_id_list, tags=tags)
                self._create_test_cases(filtered_cases)
            except Exception as e:
                logging.error(f"{self.__class__.__name__}: Failed to create test cases: {str(e)}")
                raise

            logging.info(f"{self.__class__.__name__}: Test suite created successfully")
            return self.api_suite

        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error creating test suite: {str(e)}")
            raise RuntimeError(f"Failed to create test suite: {str(e)}")

    def _configure_test_resources(self):
        try:
            test_cases_path_arg = os.path.normpath(self.test_cases_path).replace(os.path.sep, '/')
            logging.info(f"{self.__class__.__name__}: Using test cases from {test_cases_path_arg}")
            self.api_suite.resource.imports.library(
                'libraries.api.api_test_keywords.APITestKeywords',
                args=[None, test_cases_path_arg]
            )
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error configuring test resources: {str(e)}")
            raise

    def _create_test_cases(self, filtered_cases) -&gt; None:
        try:
            for _, test_case in filtered_cases.iterrows():
                self._create_single_test_case(test_case)
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error creating test cases: {str(e)}")
            raise

    def _create_single_test_case(self, test_case) -&gt; None:
        try:
            robot_api_test_name = f"API.{test_case['TCID']}.{test_case['Name']}"
            robot_api_test = self.api_suite.tests.create(
                name=robot_api_test_name,
                doc=test_case['Descriptions']
            )
            robot_api_test.body.create_keyword(name='api_sanity_check', args=[])
            self._add_test_tags(robot_api_test, test_case)
            robot_api_test.body.create_keyword(
                name='execute_api_test_case',
                args=[test_case['TCID']]
            )
            self._configure_test_conditions(robot_api_test, test_case)
            logging.info(f"{self.__class__.__name__}: Test case {test_case['TCID']} created successfully")

        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error creating test case {test_case.get('TCID', 'Unknown')}: {str(e)}")
            raise

    def _add_test_tags(self, robot_api_test, test_case) -&gt; None:
        try:
            if 'Tags' in test_case and pd.notna(test_case['Tags']):
                tags = [tag.strip() for tag in test_case['Tags'].split(',')]
                for tag in tags:
                    robot_api_test.tags.add(tag)
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error adding tags to test case: {str(e)}")
            raise

    def _configure_test_conditions(self, robot_api_test, test_case) -&gt; None:
        try:
            if pd.notna(test_case['Conditions']):
                conditions = test_case['Conditions'].splitlines()
                for condition in conditions:
                    self._process_condition(condition, robot_api_test)
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error configuring test conditions: {str(e)}")
            raise

    def _process_condition(self, condition: str, robot_api_test) -&gt; None:
        try:
            condition_mapping = {
                '[TestSetup]': (robot_api_test.setup, 'Test setup'),
                '[TestTeardown]': (robot_api_test.teardown, 'Test teardown'),
                '[SuiteSetup]': (self.api_suite.setup, 'Suite setup'),
                '[SuiteTeardown]': (self.api_suite.teardown, 'Suite teardown')
            }

            for condition_type, (config_object, condition_name) in condition_mapping.items():
                if condition_type in condition:
                    case_ids = condition.strip(condition_type).split(',')
                    config_object.config(
                        name='execute_multiple_api_test_cases',
                        args=[case_ids]
                    )
                    logging.info(f"{self.__class__.__name__}: Configured {condition_name} with case IDs: {case_ids}")

        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error processing condition '{condition}': {str(e)}")
            raise
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api_api_test_keywords_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\api\api_test_keywords.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import logging
import os
import re
from time import sleep
from typing import Dict, List
import pandas as pd
from libraries.common.config_manager import ConfigManager
from libraries.common.db_validator import DBValidator
from libraries.common.utility_helpers import PROJECT_ROOT
from libraries.api.request_sender import RequestSender
from libraries.api.body_generator import BodyGenerator
from libraries.api.headers_generator import HeadersGenerator
from libraries.api.saved_fields_manager import SavedFieldsManager
from libraries.api.response_handler import ResponseValidator, ResponseFieldSaver
from libraries.api.api_test_loader import APITestLoader
from robot.libraries.BuiltIn import BuiltIn
from robot.api.deco import keyword, library
from robot.api import logger
from libraries.common.log_manager import ColorLogger

builtin_lib = BuiltIn()


@library
class APITestKeywords:
    ROBOT_LIBRARY_SCOPE = 'TEST SUITE'

    def __init__(self, test_config_path: str = None, test_cases_path: str = None) -&gt; None:
        self.project_root: str = PROJECT_ROOT
        self._load_configuration(test_config_path, test_cases_path)
        self._initialize_components()

    def _load_configuration(self, test_config_path, test_cases_path):

        self.test_config_path = test_config_path or os.path.join(self.project_root, 'configs', 'api_test_config.yaml')

        self.test_config: Dict = ConfigManager.load_yaml(self.test_config_path)

        default_test_cases_path: str = os.path.join('test_cases', 'api_test_cases.xlsx')
        self.test_cases_path: str = test_cases_path or os.path.join(self.project_root, self.test_config.get('test_cases_path', default_test_cases_path))

        self.active_environment = self.test_config['active_environment']
        self.db_config = self.test_config.get('database', {}).get(self.active_environment, {})
        if not self.db_config:
            raise ValueError(f"No database configuration for environment: {self.active_environment}")

    def _load_endpoints(self):
        endpoints = self.api_test_loader.get_endpoints()
        self.endpoints = {}
        for _, row in endpoints[endpoints['Environment'] == self.active_environment].iterrows():
            self.endpoints[row['Endpoint']] = {
                'method': row['Method'],
                'path': row['Path']
            }

    def _initialize_components(self):
        self.saved_fields_manager: SavedFieldsManager = SavedFieldsManager()
        self.api_test_loader = APITestLoader(self.test_cases_path)
        self._load_endpoints()
        self.body_generator: BodyGenerator = BodyGenerator(self.api_test_loader)
        self.headers_generator: HeadersGenerator = HeadersGenerator(self.api_test_loader)
        self.api_response_asserter: ResponseValidator = ResponseValidator()
        self.response_field_saver: ResponseFieldSaver = ResponseFieldSaver()
        self.db_validator = DBValidator()


    @keyword
    def api_sanity_check(self) -&gt; None:
        skip_on_sanity_check_failure = BuiltIn().get_variable_value('${skip_on_sanity_check_failure}', default=False)
        if skip_on_sanity_check_failure:
            BuiltIn().skip("Skipping current test as sanity check failed.")
        else:
            logging.info(f"{self.__class__.__name__}: Sanity check succeeded, continuing with the test.")

    @keyword
    def clear_saved_fields(self):
        if self.test_config.get('clear_saved_fields_after_test', False):
            self.saved_fields_manager.clear_saved_fields()
            logging.info(f"{self.__class__.__name__}: Cleared saved fields")

    @keyword
    def execute_multiple_api_test_cases(self, test_case_ids: List[str] = None):

        test_cases = self.api_test_loader = APITestLoader(self.test_cases_path).get_api_test_cases()

        if test_case_ids is None:
            test_case_ids = [tc['TCID'] for tc in test_cases]

        results = {}
        for tcid in test_case_ids:
            logging.info(f"{self.__class__.__name__}: Executing test case: {tcid}")
            result = self.execute_api_test_case(tcid)
            results[tcid] = result

        return results

    @keyword
    def execute_api_test_case(self, test_case_id: str, is_dynamic_check: bool = False):
        try:

            test_cases = self.api_test_loader = APITestLoader(self.test_cases_path).get_api_test_cases()
            test_case = next((tc for _, tc in test_cases.iterrows() if tc['TCID'] == test_case_id), None)

            if test_case is None:
                raise ValueError(f"{self.__class__.__name__}: Test case with ID {test_case_id} not found.")

            check_with_tcids = self._extract_check_with_tcids(test_case)

            if check_with_tcids:
                pre_check_responses = self._execute_check_with_cases(check_with_tcids)
                response, execution_time = self._execute_single_test_case(test_case)
                logging.info("============================================")
                post_check_responses = self._execute_check_with_cases(check_with_tcids)
                self._validate_dynamic_checks(test_case, pre_check_responses, post_check_responses)
            else:
                response, execution_time = self._execute_single_test_case(test_case)
            logger.info(ColorLogger.success(f"{self.__class__.__name__}: Test case [ {test_case_id} ]: PASS."), html=True)
            logging.info(f"{self.__class__.__name__}: Finished execution of test case {test_case_id}")
            logging.info("============================================")

            return True if not is_dynamic_check else (response, execution_time)
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Failed to execute test case {test_case_id}: {str(e)}")
            raise e

    def _execute_single_test_case(self, test_case):
        response, execution_time = self.send_request(test_case)
        logging.info(f"{self.__class__.__name__}: Time taken to execute test case {test_case['TCID']}: {execution_time:.2f} seconds")
        self.api_response_asserter.validate_response(test_case['Exp Result'], response)
        self.response_field_saver.save_fields_to_robot_variables(response, test_case)
        self.validate_data_base(test_case)
        wait = float(test_case['Wait']) if test_case['Wait'] != '' else 0
        if wait &gt; 0:
            sleep(wait)
            logging.info(f"{self.__class__.__name__}: Waiting for results of {test_case['TCID']} in {wait} seconds.")

        return response, execution_time

    def validate_data_base(self, test_case):
        try:
            if 'DB.' in test_case['Exp Result']:
                self.db_validator.setup_database(self.db_config)
                for line in test_case['Exp Result'].splitlines():
                    if line.strip().startswith('DB.'):
                        self.db_validator.validate_database_value(line.strip())
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Failed to validate database: {str(e)}")
            raise e

    def _extract_check_with_tcids(self, test_case):
        conditions = test_case['Conditions']
        if pd.isna(conditions):
            return []

        check_with_match = re.search(r'\[Checkwith\](.*)', conditions)
        if check_with_match:
            return [tcid.strip() for tcid in check_with_match.group(1).split(',')]
        return []

    def _execute_check_with_cases(self, check_with_tcids):
        responses = {}
        for tcid in check_with_tcids:
            logging.info(f"{self.__class__.__name__}: Executing test case {tcid} for dynamic check")
            response, _ = self.execute_api_test_case(tcid, is_dynamic_check=True)
            responses[tcid] = response
        return responses

    def _validate_dynamic_checks(self, test_case, pre_check_responses, post_check_responses):
        logging.info(f"{self.__class__.__name__}: Validating dynamic checks for test case {test_case['TCID']}:")
        self.api_response_asserter.validate_response_dynamic(test_case, pre_check_responses, post_check_responses)

    def send_request(self, test_case):
        ex_endpoint = test_case['Endpoint']
        current_endpoint = self.endpoints.get(ex_endpoint, None)
        if current_endpoint is None:
            raise Exception(f"{self.__class__.__name__}: Endpoint {ex_endpoint} not found in config file")
        method: str = current_endpoint['method']
        url: str = current_endpoint['path']

        saved_fields = self.saved_fields_manager.load_saved_fields()
        headers = self.headers_generator.prepare_headers(test_case, saved_fields)
        self.saved_fields_manager.apply_saved_fields(test_case, saved_fields)
        self.saved_fields_manager.apply_suite_variables(test_case)
        body, format_type = self.body_generator.generate_request_body(test_case, method)

        logging.info(f"{self.__class__.__name__}: Sending request to {url} with method: {method} for test step {test_case['TCID']}.")
        response, execution_time = RequestSender.send_request(url, method, headers, body, format_type)

        return response, execution_time
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api_api_test_loader_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\api\api_test_loader.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import json
import logging
import pandas as pd
import yaml
from typing import List, Dict

class APITestLoader:
    _instances = {}

    def __new__(cls, excel_path: str):
        if excel_path not in cls._instances:
            instance = super().__new__(cls)
            instance.__init__(excel_path)
            cls._instances[excel_path] = instance
        return cls._instances[excel_path]

    def __init__(self, excel_path: str):
        if hasattr(self, 'initialized'):
            return
        self.excel_path = excel_path
        self.data: Dict[str, pd.DataFrame] = {}
        self._load_all_excel_data()
        self.validate_excel_structure()
        self.initialized = True

    def _load_all_excel_data(self):
        try:
            excel_file = pd.ExcelFile(self.excel_path)
            for sheet_name in excel_file.sheet_names:
                self.data[sheet_name] = excel_file.parse(sheet_name).fillna('')
            excel_file.close()
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error loading Excel file: {e}")
            raise ValueError(f"Error loading Excel file: {e}")

    def validate_excel_structure(self):
        required_sheets = ['API', 'BodyTemplates', 'BodyDefaults', 'Headers', 'Endpoints']
        missing_sheets = set(required_sheets) - set(self.data.keys())
        if missing_sheets:
            logging.error(f"{self.__class__.__name__}: Missing required sheets: {', '.join(missing_sheets)}")
            raise ValueError(f"Missing required sheets: {', '.join(missing_sheets)}")

        for sheet_name, df in self.data.items():
            self.validate_sheet_data(sheet_name, df)

    def get_data(self, sheet_name: str) -&gt; pd.DataFrame:
        if sheet_name not in self.data:
            raise ValueError(f"Sheet '{sheet_name}' not found in the Excel file")
        return self.data[sheet_name]

    def get_api_test_cases(self) -&gt; pd.DataFrame:
        return self.get_data('API')

    def get_body_templates(self) -&gt; pd.DataFrame:
        return self.get_data('BodyTemplates')

    def get_body_defaults(self) -&gt; pd.DataFrame:
        return self.get_data('BodyDefaults')

    def get_headers(self) -&gt; pd.DataFrame:
        return self.get_data('Headers')

    def get_endpoints(self) -&gt; pd.DataFrame:
        return self.get_data('Endpoints')

    def filter_cases(self, tcid_list: List[str] = None, tags: List[str] = None) -&gt; pd.DataFrame:
        test_cases = self.get_api_test_cases()

        if tcid_list:
            test_cases = test_cases[test_cases['TCID'].isin(tcid_list)]

        if tags:
            test_cases = test_cases[test_cases['Tags'].apply(lambda x: any(tag in str(x).split(',') for tag in tags))]

        return test_cases[test_cases['Run'] == 'Y']

    def validate_sheet_data(self, sheet_name: str, df: pd.DataFrame):
        validation_methods = {
            'API': self._validate_api_sheet,
            'BodyTemplates': self._validate_body_templates_sheet,
            'BodyDefaults': self._validate_body_defaults_sheet,
            'Headers': self._validate_headers_sheet,
            'Endpoints': self._validate_endpoints_sheet
        }
        if sheet_name in validation_methods:
            validation_methods[sheet_name](df)

    def _validate_api_sheet(self, df: pd.DataFrame):
        required_columns = ['TCID', 'Name', 'Run', 'Endpoint', 'Body Template', 'Body Default', 'Body Override', 'Headers', 'Exp Result']
        self._check_required_columns(df, required_columns, 'API')

        if df['TCID'].duplicated().any():
            raise ValueError("Duplicate TCID found in API sheet")

        if not df['Run'].isin(['Y', 'N']).all():
            raise ValueError("Invalid values in 'Run' column. Only 'Y' or 'N' are allowed.")

        for _, row in df.iterrows():
            self._validate_api_row(row)

    def _validate_api_row(self, row: pd.Series):
        method = self.get_endpoints().loc[self.get_endpoints()['Endpoint'] == row['Endpoint'], 'Method'].iloc[0]

        # Validate references to other sheets
        self._validate_sheet_reference(row['Body Template'], 'BodyTemplates', 'TemplateName', row['TCID'])
        self._validate_sheet_reference(row['Body Default'], 'BodyDefaults', 'Name', row['TCID'])
        self._validate_sheet_reference(row['Headers'], 'Headers', 'HeaderName', row['TCID'])
        self._validate_sheet_reference(row['Endpoint'], 'Endpoints', 'Endpoint', row['TCID'])

        # Validate mandatory fields based on HTTP method
        if method in ['GET', 'DELETE']:
            mandatory_fields = ['TCID', 'Name', 'Endpoint', 'Headers', 'Exp Status']
        else:
            mandatory_fields = ['TCID', 'Name', 'Endpoint', 'Body Template', 'Body Default', 'Headers', 'Exp Status']

        for field in mandatory_fields:
            if pd.isna(row[field]) or row[field] == '':
                raise ValueError(f"Empty value found in mandatory column '{field}' for TCID '{row['TCID']}' in API sheet")

    def _validate_body_templates_sheet(self, df: pd.DataFrame):
        required_columns = ['TemplateName', 'Content', 'Format']
        self._check_required_columns(df, required_columns, 'BodyTemplates')

        if df['TemplateName'].duplicated().any():
            raise ValueError("Duplicate TemplateName found in BodyTemplates sheet")

        if not df['Format'].isin(['json', 'xml']).all():
            raise ValueError("Invalid values in 'Format' column. Only 'json' or 'xml' are allowed.")

    def _validate_body_defaults_sheet(self, df: pd.DataFrame):
        required_columns = ['Name', 'Content']
        self._check_required_columns(df, required_columns, 'BodyDefaults')

        if df['Name'].duplicated().any():
            raise ValueError("Duplicate Name found in BodyDefaults sheet")

        for _, row in df.iterrows():
            try:
                json.loads(row['Content'])
            except json.JSONDecodeError:
                raise ValueError(f"Invalid JSON in BodyDefaults sheet for Name: {row['Name']}")

    def _validate_headers_sheet(self, df: pd.DataFrame):
        required_columns = ['HeaderName', 'Content']
        self._check_required_columns(df, required_columns, 'Headers')

        if df['HeaderName'].duplicated().any():
            raise ValueError("Duplicate HeaderName found in Headers sheet")

        for _, row in df.iterrows():
            try:
                yaml.safe_load(row['Content'])
            except yaml.YAMLError:
                raise ValueError(f"Invalid YAML in Headers sheet for HeaderName: {row['HeaderName']}")

    def _validate_endpoints_sheet(self, df: pd.DataFrame):
        required_columns = ['Environment', 'Endpoint', 'Method', 'Path']
        self._check_required_columns(df, required_columns, 'Endpoints')

        if df.duplicated(subset=['Environment', 'Endpoint']).any():
            raise ValueError("Duplicate Environment-Endpoint combination found in Endpoints sheet")

        valid_methods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH']
        if not df['Method'].isin(valid_methods).all():
            raise ValueError(f"Invalid values in 'Method' column. Allowed values are: {', '.join(valid_methods)}")

    def _check_required_columns(self, df: pd.DataFrame, required_columns: List[str], sheet_name: str):
        missing_columns = set(required_columns) - set(df.columns)
        if missing_columns:
            raise ValueError(f"Missing required columns in {sheet_name} sheet: {', '.join(missing_columns)}")

    def _validate_sheet_reference(self, value: str, sheet_name: str, column_name: str, tcid: str):
        if value:
            referenced_sheet = self.get_data(sheet_name)
            if value not in referenced_sheet[column_name].values:
                raise ValueError(f"Referenced value '{value}' in '{sheet_name}' sheet not found for TCID '{tcid}'")</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api_body_generator_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\api\body_generator.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import json
import logging
import re

from typing import Any, Dict, Union
from libraries.common.utility_helpers import UtilityHelpers
from libraries.api.template_renderer import TemplateRenderer
from libraries.api.variable_generator import VariableGenerator


class BodyGenerator:
    def __init__(self, api_test_loader):
        self.api_test_loader = api_test_loader
        self.format_json = UtilityHelpers.format_json
        self.format_xml = UtilityHelpers.format_xml

    def generate_request_body(self, test_case, method) -&gt; (Union[Dict, str], str):
        try:
            if method in ['GET', 'DELETE']:
                return {}, 'json'

            template_content, template_format = self.load_template(test_case['Body Template'])
            default_values = self.load_default_values(test_case['Body Default'])
            user_defined_fields = self.parse_user_defined_fields(test_case['Body Override'])
            logging.info(f"{self.__class__.__name__}:Body Override for test case {test_case['TCID']}: \n{user_defined_fields}")
            combined_data = self.merge_values(default_values, user_defined_fields, test_case)
            request_data = self.generate_dynamic_values(combined_data, test_case)
            logging.info(f"{self.__class__.__name__}:Request data for test case {test_case['TCID']}: \n{self.format_json(request_data)}")

            # Generating request body
            body = TemplateRenderer.render_template(template_content, request_data, template_format)
            if template_format == 'json':
                logging.info(f"{self.__class__.__name__}:Request body for test case {test_case['TCID']}: \n{self.format_json(body)}")
            else:
                logging.info(f"{self.__class__.__name__}:Request body for test case {test_case['TCID']}: \n{self.format_xml(body)}")
            return body, template_format
        except Exception as e:
            logging.error(f"{self.__class__.__name__}:Error in generate_request_body for test case {test_case['TCID']}: {str(e)}")
            raise

    def load_template(self, template_name):
        templates = self.api_test_loader.get_body_templates()
        try:
            template = templates[templates['TemplateName'] == template_name]
            if template.empty:
                raise ValueError(f"Template '{template_name}' not found.")
            content = template.iloc[0]['Content']
            format = template.iloc[0]['Format']
            return content, format
        except Exception as e:
            logging.error(f"Error loading template: {e}")
            raise

    def load_default_values(self, default_name):
        defaults = self.api_test_loader.get_body_defaults()
        try:
            default = defaults[defaults['Name'] == default_name]
            if default.empty:
                raise ValueError(f"Default values '{default_name}' not found.")
            return json.loads(default.iloc[0]['Content'])
        except Exception as e:
            logging.error(f"Error loading default values: {e}")
            raise

    def parse_user_defined_fields(self, field_string):
        try:
            return json.loads(field_string)
        except json.JSONDecodeError as e:
            logging.error(f"Error parsing user-defined fields: {e}")
            raise

    def merge_values(self, base_values: Dict[str, Any], custom_values: Dict[str, Any], test_case: Dict[str, Any]) -&gt; Dict[str, Any]:
        try:
            for key, value in custom_values.items():
                if key in base_values and isinstance(value, dict) and isinstance(base_values[key], dict):
                    base_values[key] = self.merge_values(base_values.get(key, {}), value, test_case)
                else:
                    base_values[key] = value
            return base_values
        except Exception as e:
            logging.error(f"{self.__class__.__name__}:Error merging default values and custom values in test case {test_case['TCID']} : {str(e)}")
            raise

    def generate_dynamic_values(self, data: Union[Dict[str, Any], list], test_case: Dict[str, Any]) -&gt; Union[
        Dict[str, Any], list]:
        try:
            if isinstance(data, dict):
                return {key: self.generate_dynamic_values(value, test_case) if isinstance(value, (dict, list))
                        else self.replace_placeholders(value, test_case) for key, value in data.items()}
            elif isinstance(data, list):
                return [self.generate_dynamic_values(item, test_case) if isinstance(item, (dict, list))
                        else self.replace_placeholders(item, test_case) for item in data]
            return data
        except Exception as e:
            logging.error(f"{self.__class__.__name__}:Error generating dynamic values in test case {test_case['TCID']} : {str(e)}")
            raise

    def replace_placeholders(self, value: Any, test_case) -&gt; Any:
        try:
            if isinstance(value, str) and re.match(r'\{\{\s*[^}]+?\s*\}\}', value):
                placeholder = re.findall(r'\{\{\s*([^}]+?)\s*\}\}', value)[0]
                return VariableGenerator.generate_dynamic_value(placeholder)
            return value
        except Exception as e:
            logging.error(f"{self.__class__.__name__}:Error replacing placeholders in test case {test_case['TCID']}: {str(e)}")
            raise
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api_headers_generator_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\api\headers_generator.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import logging
import re
import yaml
from typing import Dict, Any
import pandas as pd
from libraries.common.utility_helpers import UtilityHelpers
from libraries.api.variable_generator import VariableGenerator
from robot.libraries.BuiltIn import BuiltIn

builtin_lib = BuiltIn()


class HeadersGenerator:
    def __init__(self, api_test_loader) -&gt; None:
        self.format_json = UtilityHelpers.format_json
        self.api_test_loader = api_test_loader

    def prepare_headers(self, testcase, saved_fields):
        try:
            headers_name = testcase['Headers']
            headers = self.api_test_loader.get_headers()

            # Ensure headers_name exists and is valid
            if headers_name not in headers['HeaderName'].values:
                raise ValueError(f"Headers name '{headers_name}' not found in the headers dataframe.")

            # Convert to string explicitly before checking
            header_content = str(headers[headers['HeaderName'] == headers_name]['Content'].iloc[0])
            logging.info(f"{self.__class__.__name__}: Headers for test case '{testcase['TCID']}' loaded from file: \n{header_content}")

            # Check if header_content is empty
            if pd.isna(header_content):
                raise ValueError("Header content is empty.")

            # Parse the YAML-like content
            original_headers = yaml.safe_load(header_content)

            headers = {k: self.replace_placeholders(v, saved_fields, testcase) for k, v in original_headers.items()}
            logging.info(f"{self.__class__.__name__}: Headers for test case '{testcase['TCID']}' replaced placeholders: \n{self.format_json(headers)}")

            return headers

        except KeyError as e:
            logging.error(f"{self.__class__.__name__}: Headers file '{headers_name}' not found in test case '{testcase['TCID']}': {str(e)}")
            raise

        except yaml.YAMLError as e:
            logging.error(f"{self.__class__.__name__}: Invalid YAML format in headers file '{headers_name}' for test case '{testcase['TCID']}': {str(e)}")
            raise

        except pd.errors.EmptyDataError as e:
            logging.error(f"{self.__class__.__name__}: No data found in headers dataframe: {str(e)}")
            raise

        except TypeError as e:
            logging.error(f"{self.__class__.__name__}: TypeError when parsing YAML content for headers file '{headers_name}' for test case '{testcase['TCID']}': {str(e)}")
            raise

        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error processing headers file '{headers_name}' for test case '{testcase['TCID']}': {str(e)}")
            raise

    def replace_placeholders(self, value: Any, saved_fields: Dict[str, Any], testcase) -&gt; Any:
        headers_filename = testcase['Headers']
        try:
            if isinstance(value, str):
                # Replace {{...}}
                value = re.sub(r'\{\{\s*([^}]+?)\s*\}\}', lambda m: self._get_placeholder_value(m.group(1), saved_fields, testcase), value,
                               flags=re.DOTALL | re.MULTILINE)

                # Replace ${...}
                value = re.sub(r'\$\{([^}]+)\}', lambda m: str(builtin_lib.get_variable_value('${' + m.group(1) + '}')), value, flags=re.DOTALL | re.MULTILINE)

                # Logging for ${...} replacements
                for match in re.findall(r'\$\{([^}]+)\}', value):
                    replacement_value = builtin_lib.get_variable_value(f'${{{match}}}')
                    logging.info(f"{self.__class__.__name__}:Replaced ${{{match}}} with variable value '{replacement_value}' for test case '{testcase['TCID']}'")

            return value
        except Exception as e:
            logging.error(
                f"{self.__class__.__name__}:Unexpected error replacing placeholders in headers file '{headers_filename}' for test case '{testcase['TCID']}': {str(e)}"
            )
            raise

    def _get_placeholder_value(self, placeholder: str, saved_fields: Dict[str, Any], testcase: Dict[str, Any]) -&gt; str:
        if placeholder in saved_fields:
            value = str(saved_fields[placeholder])
            logging.info(f"{self.__class__.__name__}:Replaced {{{{{placeholder}}}}} with saved field '{value}' for test case '{testcase['TCID']}'")
        else:
            try:
                value = str(VariableGenerator.generate_dynamic_value(placeholder))
                logging.info(f"{self.__class__.__name__}:Replaced {{{{{placeholder}}}}} with dynamic value '{value}' for test case '{testcase['TCID']}'")
            except Exception as e:
                logging.warning(f"{self.__class__.__name__}:Failed to generate dynamic value for {{{{{placeholder}}}}} in test case '{testcase['TCID']}': {str(e)}")
                value = f"{{{{UNKNOWN_PLACEHOLDER_{placeholder}}}}}"
        return value
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api_request_sender_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\api\request_sender.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import requests
import urllib3
from typing import Dict, Union, Optional
import time
import logging


class RequestSender:
    @staticmethod
    def send_request(url: str, method: str, headers: Optional[Dict[str, str]] = None,
                     body: Optional[Union[Dict, str]] = None, format_type: str = 'json') -&gt; (requests.Response, float, Optional[str]):
        requests_method = RequestSender._get_request_method(method)
        start_time = time.time()
        urllib3.disable_warnings()
        try:
            if format_type == 'json':
                response = requests_method(url, headers=headers, json=body, verify=False)
            elif format_type == 'xml':
                if headers is not None:
                    headers['Content-Type'] = 'application/xml'
                response = requests_method(url, headers=headers, data=body, verify=False)
            else:
                logging.error(f"Unsupported format type: {format_type}")
                raise ValueError(f"RequestSender: Unsupported format type: {format_type}")
            response.raise_for_status()
        except requests.exceptions.SSLError as e:
            logging.error(f"SSL verification failed: {str(e)}")
            raise
        except requests.RequestException as e:
            logging.error(f"Sending request error: {str(e)}")
            raise
        except ValueError as e:
            logging.error(str(e))
            raise

        execution_time = time.time() - start_time
        return response, execution_time

    @staticmethod
    def _get_request_method(method: str):
        methods = {
            'GET': requests.get,
            'POST': requests.post,
            'PUT': requests.put,
            'DELETE': requests.delete,
            'PATCH': requests.patch
        }

        if method in methods:
            return methods[method]
        else:
            logging.warning(f"Unsupported HTTP method: {method}")
            return methods['GET']  # 返回默认方法 GET
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api_response_handler_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\api\response_handler.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import logging
import json
import re
from typing import Any, Union, Tuple
from jsonpath_ng import parse
import xmltodict
from requests import Response
from robot.libraries.BuiltIn import BuiltIn
from robot.api import logger
from libraries.common.log_manager import ColorLogger
from libraries.common.utility_helpers import UtilityHelpers

builtin_lib = BuiltIn()

class ResponseHandler:
    def get_content_and_format(self, response: Union[str, Response]) -&gt; Tuple[str, str]:
        try:
            content = response.text.strip() if isinstance(response, Response) else response.strip()

            if self._is_json(content):
                return content, 'json'
            if self._is_xml(content):
                return UtilityHelpers.format_xml(content), 'xml'

            raise ValueError(f"{self.__class__.__name__}: Response content is neither valid JSON nor XML.")
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error processing response: {str(e)}")
            raise

    def _extract_value_from_response(self, response: Union[str, Response], json_path: str) -&gt; Any:
        response_content, response_format = self.get_content_and_format(response)

        if response_format == 'json':
            return self._get_value_by_json_path(response_content, json_path)
        elif response_format == 'xml':
            json_content = json.dumps(xmltodict.parse(response_content))
            return self._get_value_by_json_path(json_content, json_path)
        else:
            raise ValueError(f"{self.__class__.__name__}: Unsupported response format. Use 'xml' or 'json'.")

    def _is_json(self, content: str) -&gt; bool:
        try:
            json.loads(content)
            return True
        except json.JSONDecodeError:
            return False

    def _is_xml(self, content: str) -&gt; bool:
        try:
            xmltodict.parse(content)
            return True
        except Exception:
            return False

    def _get_value_by_json_path(self, json_string: str, json_path: str) -&gt; Any:
        parsed_json = json.loads(json_string)
        jsonpath_expr = parse(f'$.{json_path}')
        matches = [match.value for match in jsonpath_expr.find(parsed_json)]
        if matches:
            return matches[0]
        else:
            raise ValueError(f"{self.__class__.__name__}: No match found for JSONPath: {json_path}")

class ResponseValidator(ResponseHandler):
    def validate_response(self, expected_results: str, actual_response: Union[str, Response]) -&gt; None:
        response_content, response_format = self.get_content_and_format(actual_response)
        logging.info(f"{self.__class__.__name__}: Actual response:\n{response_content}")

        expected_lines = expected_results.splitlines()
        assertion_errors = []

        for line in expected_lines:
            if line.strip().startswith('$'):
                try:
                    self._assert_line(line.strip(), response_content, response_format)
                except AssertionError as e:
                    logging.error(f"{self.__class__.__name__}: Assertion failed: {str(e)}")
                    assertion_errors.append(str(e))

        if assertion_errors:
            raise AssertionError(f"{self.__class__.__name__}: Assertions failed:\n" + "\n".join(assertion_errors))
        logging.info(f"{self.__class__.__name__}: All assertions passed successfully.")
        # logger.info(ColorLogger.info(f"{self.__class__.__name__}: All assertions passed successfully."), html=True)

    def validate_response_dynamic(self, test_case: dict, pre_check_responses: dict, post_check_responses: dict) -&gt; None:
        exp_results = test_case['Exp Result'].splitlines()
        for exp_result in exp_results:
            dynamic_checks = re.findall(r'(\w+)\.(\$[.\[\]\w]+)=([+-]\d+)', exp_result)
            pre_post_checks = re.findall(r'(\w+)\.(precheck|postcheck)\.(\$[.\[\]\w]+)=(.+)', exp_result)

            if dynamic_checks:
                self._handle_dynamic_checks(dynamic_checks, pre_check_responses, post_check_responses)
            elif pre_post_checks:
                self._handle_pre_post_checks(pre_post_checks, pre_check_responses, post_check_responses)
        logging.info(f"{self.__class__.__name__}: All dynamic and pre/post checks passed successfully.")
        # logger.info(ColorLogger.info(f"{self.__class__.__name__}: All dynamic and pre/post checks passed successfully."), html=True)

    def _handle_dynamic_checks(self, checks, pre_check_responses, post_check_responses):
        for tcid, json_path, expected_value in checks:
            pre_value = self._extract_value_from_response(pre_check_responses[tcid], json_path)
            post_value = self._extract_value_from_response(post_check_responses[tcid], json_path)

            actual_value = round(float(post_value) - float(pre_value), 2)

            logging.info(f"{self.__class__.__name__}: Actual diff: {actual_value}, Expected diff: {round(float(expected_value), 2)}")

            if not self._compare_diff(actual_value, expected_value):
                raise AssertionError(
                    f"{self.__class__.__name__}: Dynamic check failed for {tcid}.{json_path}. Expected diff: {expected_value}, Actual diff: {actual_value}")

    def _handle_pre_post_checks(self, checks, pre_check_responses, post_check_responses):
        for tcid, check_type, json_path, expected_value in checks:
            if check_type == 'precheck':
                actual_value = self._extract_value_from_response(pre_check_responses[tcid], json_path)
            elif check_type == 'postcheck':
                actual_value = self._extract_value_from_response(post_check_responses[tcid], json_path)
            else:
                raise ValueError(f"{self.__class__.__name__}: Invalid check type: {check_type}")

            logging.info(f"{self.__class__.__name__}: {check_type.capitalize()} - Actual value: {actual_value}, Expected value: {expected_value}")

            if str(actual_value) != str(expected_value.strip()):
                raise AssertionError(f"{self.__class__.__name__}: {check_type.capitalize()} failed for {tcid}.{json_path}. Expected: {expected_value}, Actual: {actual_value}")

    def _assert_line(self, line: str, response_content: str, response_format: str) -&gt; None:
        key, expected_value = map(str.strip, line.split('=', 1))

        actual_value = self._extract_value_from_response(response_content, key)

        # Convert values to the same type for comparison
        try:
            expected_value = type(actual_value)(expected_value)
        except (ValueError, TypeError):
            pass  # Keep the original type if conversion fails

        logging.info(f"{self.__class__.__name__}: Asserting: {key}, Expected: {expected_value}, Actual: {actual_value}")
        assert actual_value == expected_value, f"{self.__class__.__name__}: Assertion failed for key '{key}'. Expected: {expected_value}, Actual: {actual_value}"

    def _compare_diff(self, actual_diff: float, expected_diff: str) -&gt; bool:
        expected_operator = expected_diff[0]
        expected_value = float(expected_diff[1:])

        if expected_operator == '+':
            return actual_diff == expected_value
        elif expected_operator == '-':
            return actual_diff == -expected_value
        else:
            raise ValueError(f"{self.__class__.__name__}: Unsupported operator in expected diff: {expected_operator}")

class ResponseFieldSaver(ResponseHandler):
    def save_fields_to_robot_variables(self, response: Union[str, Response], test_case: dict) -&gt; None:
        response_content, response_format = self.get_content_and_format(response)
        save_fields = test_case.get('Save Fields', '').splitlines()

        for field in save_fields:
            try:
                value = self._extract_value_from_response(response_content, field)
                field_name = f'{test_case["TCID"]}.{field.strip()}'
                # logging.info(f"{self.__class__.__name__}: Setting global variable {field_name} to {value}.")
                logger.info(ColorLogger.info(f"{self.__class__.__name__}: Setting global variable {field_name} to {value}."), html=True)
                BuiltIn().set_global_variable(f'${{{field_name}}}', value)
            except Exception as e:
                logging.error(f"{self.__class__.__name__}: Failed to process field '{field}': {e}")</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api_saved_fields_manager_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\api\saved_fields_manager.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import logging
import re
import yaml
import os
from typing import Dict, Any
from libraries.common.utility_helpers import PROJECT_ROOT
from robot.libraries.BuiltIn import BuiltIn


builtin_lib = BuiltIn()


class SavedFieldsManager:
    def __init__(self, file_path: str = None) -&gt; None:
        self.project_root: str = PROJECT_ROOT
        self.file_path: str = file_path or os.path.join(self.project_root, 'configs', 'saved_fields.yaml')

    def clear_saved_fields(self):
        with open(self.file_path, 'w') as f:
            f.write('')

    def load_saved_fields(self) -&gt; Dict[str, Any]:
        if not os.path.exists(self.file_path):
            return {}
        try:
            with open(self.file_path, 'r') as f:
                saved_fields: Dict[str, Any] = yaml.safe_load(f) or {}
            return saved_fields
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Failed to load saved fields from the yaml file: {str(e)}")
            raise

    def save_fields(self, field_data: Dict[str, Any]) -&gt; None:
        saved_fields: Dict[str, Any] = self.load_saved_fields()
        saved_fields.update(field_data)
        try:
            with open(self.file_path, 'w') as f:
                yaml.safe_dump(saved_fields, f, default_flow_style=False)
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Failed to save fields to the yaml file: {str(e)}")
            raise

    def apply_saved_fields(self, test_case, saved_fields: Dict) -&gt; None:
        try:
            for key, value in saved_fields.items():
                for column in ['Body Override', 'Exp Result']:
                    if column in test_case and test_case[column] != '':
                        lines = test_case[column].splitlines()
                        replaced_lines = [line.replace(f"${{{key}}}", str(value)) for line in lines]
                        test_case[column] = "\n".join(replaced_lines)
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Failed to apply saved fields to [Body Override], [Exp Result]: {str(e)}")
            raise

    def apply_suite_variables(self, test_case) -&gt; None:
        try:
            for key in ['Body Override', 'Exp Result']:
                matches = re.findall(r'\$\{[^}]+\}', test_case[key])
                for match in matches:
                    replacement_value = builtin_lib.get_variable_value(match)
                    test_case[key] = test_case[key].replace(match, str(replacement_value))
                    logging.info(f"{self.__class__.__name__}: [{key}] Replaced {match} variable value {replacement_value}")

        except Exception as e:
            logging.error(f"{self.__class__.__name__}: [{key}] Replaced {match} with {replacement_value} failed: {str(e)}")
            raise
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api_template_renderer_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\api\template_renderer.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import json
from jinja2 import Environment, TemplateNotFound
from typing import Dict, Any, Union


class TemplateRenderer:
    @staticmethod
    def render_template(template_content, render_by: Dict[str, Any], format_type: str) -&gt; Union[Dict, str]:
        try:
            env = TemplateRenderer._create_environment()
            template = env.from_string(template_content)
            rendered_body: str = template.render(render_by)
            format_body = TemplateRenderer._format_rendered_body(rendered_body, format_type)
            return format_body
        except (TemplateNotFound, json.JSONDecodeError) as e:
            raise ValueError(f"TemplateRenderer: Error rendering template: {str(e)}")
        except Exception as e:
            raise ValueError(f"TemplateRenderer: An unexpected error occurred while rendering template: {str(e)}")

    @staticmethod
    def _create_environment() -&gt; Environment:
        env = Environment()
        env.filters['json_bool'] = lambda value: str(value).lower()
        return env

    @staticmethod
    def _format_rendered_body(rendered_body: str, format_type: str) -&gt; Union[Dict, str]:
        if format_type == 'json':
            return json.loads(rendered_body)
        elif format_type == 'xml':
            return rendered_body
        else:
            raise ValueError(f"TemplateRenderer: Unsupported format type: {format_type}")
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api_variable_generator_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\api\variable_generator.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import random
import string
import uuid
import datetime
from typing import Any, Dict, Callable


class VariableGenerator:
    @staticmethod
    def generate_dynamic_value(field_name: str) -&gt; Any:
        handlers: Dict[str, Callable[[str], Any]] = {
            'uetr': VariableGenerator._generate_uuid4,
            'uuid4': VariableGenerator._generate_uuid4,
            'value_date': VariableGenerator._generate_current_day,
            'msg_id': VariableGenerator._generate_msg_id,
            'timestamp': VariableGenerator._generate_timestamp,
            'formated_timestamp': VariableGenerator._generate_formated_timestamp,
            'bic': VariableGenerator._generate_bic
        }
        return handlers.get(field_name, VariableGenerator._generate_error_handling)()

    @staticmethod
    def _generate_uuid4() -&gt; str:
        return str(uuid.uuid4())

    @staticmethod
    def _generate_current_day(date_format: str = "%Y%m%d") -&gt; str:
        return datetime.datetime.now().strftime(date_format)

    @staticmethod
    def _generate_msg_id() -&gt; str:
        prefix = 'MSG'
        suffix = ''.join(random.choices(string.ascii_lowercase, k=5))
        timestamp = VariableGenerator._generate_timestamp()
        msg_id = f'{prefix}{timestamp}{suffix}'
        return msg_id

    @staticmethod
    def _generate_timestamp() -&gt; str:
        return str(int(datetime.datetime.now().timestamp()))

    @staticmethod
    def _generate_formated_timestamp() -&gt; str:
        now = datetime.datetime.now()
        timestamp_str = now.strftime("%m%d%H%M%S") + f"{now.microsecond // 1000:03d}"
        return timestamp_str

    @staticmethod
    def _generate_bic() -&gt; str:
        return ''.join(random.choices(string.ascii_uppercase, k=8))

    @staticmethod
    def _generate_error_handling() -&gt; str:
        raise ValueError(f"VariableGenerator: No handler registered for this field.")
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_common___init___py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\common\__init__.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre></pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_common_config_manager_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\common\config_manager.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import yaml
import json
import os
from typing import Dict


class ConfigManager:

    @staticmethod
    def load_json(file_path: str) -&gt; Dict:
        with open(file_path, 'r') as file:
            config = json.load(file)
        return config

    @staticmethod
    def load_yaml(file_path: str) -&gt; Dict:
        with open(file_path, 'r') as file:
            config = yaml.safe_load(file)
        return config

    @staticmethod
    def load_templates(template_dir: str) -&gt; Dict[str, str]:
        templates = {}
        for filename in os.listdir(template_dir):
            if filename.endswith('.json') or filename.endswith('.xml'):
                template_name = os.path.splitext(filename)[0]
                templates[template_name] = os.path.join(template_dir, filename)
        return templates
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_common_db_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\common\db.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>from typing import List, Dict, Any, Optional, Type
from abc import ABC, abstractmethod
import cx_Oracle
import psycopg2
from psycopg2.extras import RealDictCursor
from psycopg2.pool import ThreadedConnectionPool
from contextlib import contextmanager


class DatabaseError(Exception):
    """Custom exception for database operations"""
    pass


class Database(ABC):
    @abstractmethod
    def connect(self, **kwargs) -&gt; None:
        pass

    @abstractmethod
    def disconnect(self) -&gt; None:
        pass

    @abstractmethod
    def execute_query(self, table: str, fields: Optional[List[str]] = None, where: Optional[str] = None) -&gt; List[Dict]:
        pass

    @abstractmethod
    def update(self, table: str, values: Dict, where: Optional[str] = None) -&gt; bool:
        pass

    @abstractmethod
    def insert(self, table: str, data: List[Dict]) -&gt; int:
        pass

    @contextmanager
    def transaction(self):
        """Context manager for handling transactions"""
        try:
            yield
            self.connection.commit()
        except Exception as e:
            self.connection.rollback()
            raise DatabaseError(f"Transaction failed: {str(e)}")


class OracleDatabase(Database):
    def __init__(self):
        self.pool = None
        self.connection = None

    def connect(self, user: str, password: str, host: str, port: int, service_name: str, min_connections: int = 1, max_connections: int = 10):
        try:
            dsn = cx_Oracle.makedsn(host, port, service_name=service_name)
            self.pool = cx_Oracle.SessionPool(user, password, dsn, min=min_connections, max=max_connections, increment=1, threaded=True)
        except cx_Oracle.Error as e:
            raise DatabaseError(f"Failed to create connection pool for Oracle: {str(e)}")

    def _get_connection(self):
        if not self.pool:
            raise DatabaseError("Connection pool not initialized")
        try:
            return self.pool.acquire()
        except cx_Oracle.Error as e:
            raise DatabaseError(f"Failed to acquire connection from pool: {str(e)}")

    def _release_connection(self):
        if self.connection:
            self.pool.release(self.connection)
            self.connection = None

    def disconnect(self):
        if self.pool:
            try:
                self.pool.close()
            finally:
                self.pool = None

    def execute_query(self, table: str, fields: Optional[List[str]] = None, where: Optional[str] = None) -&gt; List[Dict]:
        if fields:
            field_str = ', '.join(fields)
        else:
            field_str = '*'

        query = f"SELECT {field_str} FROM {table}"
        if where:
            query += f" WHERE {where}"

        connection = self._get_connection()
        try:
            with connection.cursor() as cursor:
                try:
                    cursor.execute(query)
                    if fields:
                        return [{field: row[fields.index(field)] for field in fields} for row in cursor]
                    else:
                        return [dict(zip([desc[0].lower() for desc in cursor.description], row))
                                for row in cursor.fetchall()]
                except cx_Oracle.Error as e:
                    raise DatabaseError(f"Query execution failed: {str(e)}")
        finally:
            self._release_connection()

    def update(self, table: str, values: Dict, where: Optional[str] = None) -&gt; bool:
        update_clause = ", ".join([f"{key} = :{key}" for key in values.keys()])
        query = f"UPDATE {table} SET {update_clause}"
        if where:
            query += f" WHERE {where}"

        connection = self._get_connection()
        try:
            with connection.cursor() as cursor:
                try:
                    cursor.execute(query, values)
                    connection.commit()
                    return True
                except cx_Oracle.Error as e:
                    connection.rollback()
                    raise DatabaseError(f"Update failed: {str(e)}")
        finally:
            self._release_connection()

    def insert(self, table: str, data: List[Dict]) -&gt; int:
        if not data:
            return 0

        columns = ', '.join(data[0].keys())
        placeholders = ', '.join([':' + key for key in data[0].keys()])
        query = f"INSERT INTO {table} ({columns}) VALUES ({placeholders})"

        connection = self._get_connection()
        try:
            with connection.cursor() as cursor:
                try:
                    cursor.executemany(query, data)
                    connection.commit()
                    return cursor.rowcount
                except cx_Oracle.Error as e:
                    connection.rollback()
                    raise DatabaseError(f"Insert failed: {str(e)}")
        finally:
            self._release_connection()


class PostgreSQLDatabase(Database):
    def __init__(self):
        self.pool = None
        self.connection = None

    def connect(self, user: str, password: str, host: str, port: int, database: str, minconn: int = 1, maxconn: int = 10):
        try:
            self.pool = ThreadedConnectionPool(minconn, maxconn,
                                                             user=user, password=password,
                                                             host=host, port=port, database=database)
        except psycopg2.Error as e:
            raise DatabaseError(f"Failed to create connection pool for PostgreSQL: {str(e)}")

    def _get_connection(self):
        if not self.pool:
            raise DatabaseError("Connection pool not initialized")
        try:
            return self.pool.getconn()
        except psycopg2.Error as e:
            raise DatabaseError(f"Failed to acquire connection from pool: {str(e)}")

    def _release_connection(self, connection):
        if connection:
            self.pool.putconn(connection)

    def disconnect(self):
        if self.pool:
            try:
                self.pool.closeall()
            except psycopg2.Error:
                pass  # Ignore if already closed or if there's an error during close

    def execute_query(self, table: str, fields: Optional[List[str]] = None, where: Optional[str] = None) -&gt; List[Dict]:
        if fields:
            field_str = ', '.join(fields)
        else:
            field_str = '*'

        query = f"SELECT {field_str} FROM {table}"
        if where:
            query += f" WHERE {where}"

        connection = self._get_connection()
        try:
            with connection.cursor(cursor_factory=RealDictCursor) as cursor:
                try:
                    cursor.execute(query)
                    if fields:
                        return [dict((k, row[k]) for k in fields if k in row)
                                for row in cursor.fetchall()]
                    return cursor.fetchall()
                except psycopg2.Error as e:
                    raise DatabaseError(f"Query execution failed: {str(e)}")
        finally:
            self._release_connection(connection)

    def update(self, table: str, values: Dict, where: Optional[str] = None) -&gt; bool:
        update_clause = ", ".join([f"{key} = %({key})s" for key in values.keys()])
        query = f"UPDATE {table} SET {update_clause}"
        if where:
            query += f" WHERE {where}"

        connection = self._get_connection()
        try:
            with connection.cursor() as cursor:
                try:
                    cursor.execute(query, values)
                    connection.commit()
                    return True
                except psycopg2.Error as e:
                    connection.rollback()
                    raise DatabaseError(f"Update failed: {str(e)}")
        finally:
            self._release_connection(connection)

    def insert(self, table: str, data: List[Dict]) -&gt; int:
        if not data:
            return 0

        columns = ', '.join(data[0].keys())
        placeholders = ', '.join(['%(' + key + ')s' for key in data[0].keys()])
        query = f"INSERT INTO {table} ({columns}) VALUES ({placeholders})"

        connection = self._get_connection()
        try:
            with connection.cursor() as cursor:
                try:
                    cursor.executemany(query, data)
                    connection.commit()
                    return cursor.rowcount
                except psycopg2.Error as e:
                    connection.rollback()
                    raise DatabaseError(f"Insert failed: {str(e)}")
        finally:
            self._release_connection(connection)


def get_database(db_type: str) -&gt; Type[Database]:
    """Factory function to get the appropriate database class"""
    databases = {
        'oracle': OracleDatabase,
        'postgresql': PostgreSQLDatabase
    }
    if db_type.lower() not in databases:
        raise ValueError(f"Unsupported database type: {db_type}")
    return databases[db_type.lower()]


def create_database(db_type: str, **kwargs) -&gt; Database:
    """Factory function to create and connect to a database"""
    DatabaseClass = get_database(db_type)
    db = DatabaseClass()
    db.connect(**kwargs)
    return db</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_common_db_validator_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\common\db_validator.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import logging
import re
from libraries.common.db import create_database
from robot.libraries.BuiltIn import BuiltIn

builtin_lib = BuiltIn()


class DBValidator:
    def __init__(self):
        self.db = None

    def setup_database(self, db_config):
        db_type = db_config['type'].lower()
        db_config.pop('type')
        self.db = create_database(db_type, **db_config)

    def validate_database_value(self, db_clause):
        if not self.db:
            raise ValueError("Database connection is not configured.")

        # Parse the format DB.TableName.FieldName[FilterFieldName=FilterValue;AnotherField=AnotherValue]=ExpectedValue
        pattern = r'^DB\.(?P&lt;Table&gt;\w+)\.(?P&lt;Field&gt;\w+)\s*\[(?P&lt;Filters&gt;[^\]]+)\]\s*=\s*(?P&lt;ExpectedValue&gt;.+)$'

        match = re.match(pattern, db_clause)
        if not match:
            raise ValueError(f"Invalid format for validate_database_value: {db_clause}")

        # Extract components using named groups
        table_name = match.group('Table')
        field_name = match.group('Field')
        filters = match.group('Filters')
        expected_value = match.group('ExpectedValue').strip()

        # Check if there's a filter part and process it
        if filters:
            filter_conditions = filters.split(';')
            where_clauses = []
            for condition in filter_conditions:
                filter_field, filter_value = condition.split('=')
                where_clauses.append(f"{filter_field} = '{filter_value}'")
            where_clause = ' AND '.join(where_clauses)
        else:
            where_clause = None

        # Query the database
        result = self.db.execute_query(table_name, fields=[field_name], where=where_clause)

        if not result:
            if where_clause:
                raise AssertionError(f"No data found for {field_name} in {table_name} where {where_clause}")
            else:
                raise AssertionError(f"No data found for {field_name} in {table_name}")

        actual_value = result[0][field_name]

        if actual_value != expected_value:
            raise AssertionError(f"Database value mismatch. Expected {expected_value} but got {actual_value} for {field_name} in {table_name}")

        logging.info(f"{self.__class__.__name__}: Database value matched for {field_name} in {table_name}. Expected: {expected_value}, Actual: {actual_value}")
        logging.info(f"{self.__class__.__name__}: {db_clause} passed.")


</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_common_gen_temp_default_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\common\gen_temp_default.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import os
import re
import json
from collections import defaultdict

TEMPLATE_DIR = '../../configs/api/body_templates'
OUTPUT_DIR = '../../report'


def extract_placeholders(template_content):
    # 提取{{}}中的占位符，支持嵌套
    placeholders = re.findall(r'\{\{\s*([^}]+?)\s*\}\}', template_content)
    return placeholders


def nest_keys(keys):
    nested_dict = {}
    for key in keys:
        parts = key.split('.')
        current_level = nested_dict
        for part in parts[:-1]:
            if part not in current_level:
                current_level[part] = {}
            current_level = current_level[part]
        current_level[parts[-1]] = ""
    return nested_dict


def merge_dicts(dict1, dict2):
    for key in dict2:
        if key in dict1:
            if isinstance(dict1[key], dict) and isinstance(dict2[key], dict):
                merge_dicts(dict1[key], dict2[key])
            else:
                dict1[key] = dict2[key]
        else:
            dict1[key] = dict2[key]
    return dict1


def generate_json_from_template(template_filename):
    template_path = os.path.join(TEMPLATE_DIR, template_filename)
    if not os.path.exists(template_path):
        raise FileNotFoundError(f"The template file {template_filename} does not exist in {TEMPLATE_DIR}")

    with open(template_path, 'r', encoding='utf-8') as file:
        template_content = file.read()

    placeholders = extract_placeholders(template_content)
    nested_structure = {}

    for placeholder in placeholders:
        nested_dict = nest_keys([placeholder])
        nested_structure = merge_dicts(nested_structure, nested_dict)

    output_path = os.path.join(OUTPUT_DIR, f"{os.path.splitext(template_filename)[0]}_placeholders.json")
    os.makedirs(OUTPUT_DIR, exist_ok=True)
    with open(output_path, 'w', encoding='utf-8') as outfile:
        json.dump(nested_structure, outfile, indent=4)

    print(f"Generated JSON file with placeholders: {output_path}")


if __name__ == "__main__":
    template_filename = 'pacs.008_out.xml'  # 你可以更改为你想指定的模板文件名
    generate_json_from_template(template_filename)</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_common_log_manager_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\common\log_manager.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import logging
import logging.config
import os
import yaml
from libraries.common.utility_helpers import PROJECT_ROOT


class Logger:
    _instance = None

    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super(Logger, cls).__new__(cls)
        return cls._instance

    def __init__(self, config_path=None):
        if not hasattr(self, 'initialized'):
            self.config_path = config_path or os.path.join(PROJECT_ROOT, 'configs', 'logging_config.yaml')
            self.log_file_name = "robot_testing"
            self.load_config()
            self.initialized = True

    def load_config(self):
        if os.path.exists(self.config_path):
            with open(self.config_path, 'r', encoding='utf-8') as file:
                config = yaml.safe_load(file)

            log_file_path = os.path.join(PROJECT_ROOT, 'report', f"{self.log_file_name}.log")
            os.makedirs(os.path.dirname(log_file_path), exist_ok=True)

            if 'file' in config['handlers']:
                config['handlers']['file']['filename'] = log_file_path

            logging.config.dictConfig(config)
        else:
            logging.basicConfig(level=logging.DEBUG)

        self.logger = logging.getLogger('e2e_testing')

    def get_logger(self):
        return self.logger


class ColorLogger:
    @staticmethod
    def success(message):
        return f'&lt;span style="background-color: #90EE90; padding: 2px 5px; border-radius: 3px;"&gt;{message}&lt;/span&gt;'

    @staticmethod
    def error(message):
        return f'&lt;span style="background-color: #FFB6C1; padding: 2px 5px; border-radius: 3px;"&gt;{message}&lt;/span&gt;'

    @staticmethod
    def info(message):
        return f'&lt;span style="background-color: #B8E2F2; padding: 2px 5px; border-radius: 3px;"&gt;{message}&lt;/span&gt;'

logger_instance = Logger()
logger = logger_instance.get_logger()

__all__ = ['logger', 'logger_instance', 'ColorLogger']
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_common_utility_helpers_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\common\utility_helpers.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import json
import os
import time
from functools import wraps
from lxml import etree


class UtilityHelpers:
    @staticmethod
    def get_file_format(file_path: str) -&gt; str:
        """
        Determine the format of the file based on its extension.
        """
        if file_path.endswith('.json'):
            return 'json'
        elif file_path.endswith('.xml'):
            return 'xml'
        else:
            raise ValueError(f"UtilityHelpers: Unsupported file format for file: {file_path}")

    @staticmethod
    def escape_xml(value):
        """Escape XML characters."""
        return (
            value.replace("&amp;", "&amp;amp;")
            .replace("&lt;", "&amp;lt;")
            .replace("&gt;", "&amp;gt;")
            .replace('"', "&amp;quot;")
            .replace("'", "&amp;apos;")
        )

    @staticmethod
    def format_json(data):
        """
        Formats a given dictionary as a pretty-printed JSON string.

        :param data: Dictionary to format.
        :return: Pretty-printed JSON string.
        """
        return json.dumps(data, indent=4)

    @staticmethod
    def format_xml(xml_string: str) -&gt; str:
        """
        Formats a given XML string as a pretty-printed XML string without extra newlines.

        :param xml_string: XML string to format.
        :return: Pretty-printed XML string.
        """
        try:
            # check for XML declaration
            xml_declaration = ""
            if xml_string.startswith("&lt;?xml"):
                declaration_end_index = xml_string.find("?&gt;") + 2
                xml_declaration = xml_string[:declaration_end_index]
                xml_string = xml_string[declaration_end_index:].strip()

            parser = etree.XMLParser(remove_blank_text=True, strip_cdata=False)
            xml_element = etree.fromstring(xml_string, parser)

            # Ensure CDATA sections are preserved
            def _preserve_cdata(element):
                if element.text and isinstance(element.text, etree.CDATA):
                    element.text = etree.CDATA(element.text)
                for child in element:
                    _preserve_cdata(child)
                    if child.tail and isinstance(child.tail, etree.CDATA):
                        child.tail = etree.CDATA(child.tail)

            _preserve_cdata(xml_element)
            formatted_xml = etree.tostring(xml_element, pretty_print=True, encoding='unicode')
            if xml_declaration:
                formatted_xml = xml_declaration + "\n" + formatted_xml
            return formatted_xml.strip()
        except Exception as e:
            raise ValueError(f"UtilityHelpers: Invalid XML data: {str(e)}")

    @staticmethod
    def time_calculation():
        def decorator(func):
            @wraps(func)
            def wrapper(*args, **kwargs):
                start_time = time.time()
                result = func(*args, **kwargs)
                end_time = time.time()
                execution_time = end_time - start_time
                from libraries.common.log_manager import logger
                logger.info(f"UtilityHelpers: Function {func.__name__} executed in {execution_time:.4f} seconds")
                return result

            return wrapper

        return decorator

    @staticmethod
    def _find_project_root(current_dir=os.getcwd()):
        while True:
            if os.path.exists(os.path.join(current_dir, '.project_root')):
                return current_dir
            parent = os.path.dirname(current_dir)
            if parent == current_dir:
                raise FileNotFoundError("UtilityHelpers: Project root not found")
            current_dir = parent

    @staticmethod
    def get_project_root():
        # 尝试从脚本所在目录查找
        script_dir = os.path.dirname(os.path.abspath(__file__))
        project_root = UtilityHelpers._find_project_root(script_dir)

        if project_root is None:
            # 如果失败，尝试从当前工作目录查找
            current_dir = os.getcwd()
            project_root = UtilityHelpers._find_project_root(current_dir)

        if project_root is None:
            raise FileNotFoundError("UtilityHelpers: Project root not found")

        return project_root


PROJECT_ROOT = UtilityHelpers.get_project_root()
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_e2e___init___py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\e2e\__init__.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre></pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_e2e_e2e_robot_generator_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\e2e\e2e_robot_generator.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import logging
import os
from typing import Dict, List
import pandas as pd
from robot.api import TestSuite
from libraries.api.api_robot_generator import APIRobotCasesGenerator
from libraries.common.config_manager import ConfigManager
from libraries.common.utility_helpers import PROJECT_ROOT
from libraries.web.web_test_loader import WebTestLoader


class E2ERobotCasesGenerator:
    def __init__(self, test_config_path: str = None, test_cases_path: str = None):
        self.project_root: str = PROJECT_ROOT
        self.test_config_path: str = test_config_path
        self.test_cases_path: str = test_cases_path

        try:
            self._load_configuration()
            self._initialize_components()
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Initialization failed: {str(e)}")
            raise RuntimeError(f"{self.__class__.__name__}: Initialization failed: {str(e)}")

    def _load_configuration(self):
        try:
            self.test_config_path = (
                os.path.join(self.project_root, 'configs', 'e2e_test_config.yaml')
                if self.test_config_path is None
                else self.test_config_path
            )
            self.test_config: Dict = ConfigManager.load_yaml(self.test_config_path)
        except FileNotFoundError:
            logging.error(f"{self.__class__.__name__}: Config file not found at {self.test_config_path}")
            raise
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error loading configuration: {str(e)}")
            raise

    def _initialize_components(self):
        try:
            default_test_cases_path: str = os.path.join('test_cases', 'e2e_test_cases.xlsx')
            self.test_cases_path: str = (
                os.path.join(self.project_root, self.test_config.get('test_cases_path', default_test_cases_path))
                if self.test_cases_path is None
                else self.test_cases_path
            )

            if not os.path.exists(self.test_cases_path):
                logging.error(f"{self.__class__.__name__}: Test cases file not found at {self.test_cases_path}")
                raise FileNotFoundError(f"Test cases file does not exist: {self.test_cases_path}")

            self.web_test_loader = WebTestLoader(self.test_cases_path, self.test_config)
            self.api_robot_generator = APIRobotCasesGenerator(None, self.test_cases_path)
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error initializing components: {str(e)}")
            raise

    def create_test_suite(self, tc_id_list: List[str] = None, tags: List[str] = None) -&gt; TestSuite:
        try:
            # Create main test suite
            self.robot_suite = TestSuite('End To End TestSuite')

            # Filter test cases
            tc_id_list = tc_id_list or self.test_config.get('tc_id_list', [])
            tags = tags or self.test_config.get('tags', [])
            test_cases = self.web_test_loader.filter_cases(tc_id_list, tags)

            if test_cases.empty:
                logging.warning(f"{self.__class__.__name__}: No test cases found matching criteria.")
                return self.robot_suite

            # Iterate through test cases and generate tests
            for _, test_case in test_cases.iterrows():
                self.create_test_case(test_case)

            return self.robot_suite
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error creating test suite: {str(e)}")
            raise RuntimeError(f"Failed to create test suite: {str(e)}")

    def create_test_case(self, test_case: Dict):
        try:
            # Load test steps and data sets
            case_id = test_case['Case ID']
            test_steps = self.web_test_loader.get_test_steps(case_id)
            test_data_sets = self.web_test_loader.get_test_data(case_id)

            # Create empty data set if none exists
            if not test_data_sets:
                test_data_sets = [{}]

            # Create child test suite
            self.child_suite = TestSuite(name=case_id, doc=test_case['Descriptions'])
            self.robot_suite.suites.append(self.child_suite)

            # Import required libraries
            self._import_required_libraries()

            # Iterate through data sets and generate tests
            for data_set_index, data_set in enumerate(test_data_sets, 1):
                test_name = f"UI.{case_id}.{test_case['Name']}.{data_set_index}"
                robot_ui_test = self.child_suite.tests.create(name=test_name)
                robot_ui_test.body.create_keyword(name='sanity_check', args=[])

                # Add tags
                if 'Tags' in test_case and pd.notna(test_case['Tags']):
                    tags = [tag.strip() for tag in test_case['Tags'].split(',')]
                    for tag in tags:
                        robot_ui_test.tags.add(tag)

                # Create test steps
                self.create_test_steps(robot_ui_test, test_steps, data_set)
                logging.info(f"{self.__class__.__name__}: Test case {case_id}.{data_set_index} created successfully.")

        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error creating test case {test_case.get('Case ID', 'Unknown')}: {str(e)}")
            raise

    def _import_required_libraries(self):
        try:
            test_config_path_arg = os.path.normpath(self.test_config_path).replace(os.path.sep, '/')
            test_cases_path_arg = os.path.normpath(self.test_cases_path).replace(os.path.sep, '/')
            self.child_suite.resource.imports.library(
                'libraries.web.page_object.PageObject', args=[test_config_path_arg, test_cases_path_arg]
            )
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error importing required libraries: {str(e)}")
            raise

    def create_test_steps(self, robot_ui_test, test_steps: List[Dict], data_set: Dict):
        try:
            for _, step in test_steps.iterrows():
                # Get step information
                page_name = step['Page Name']
                module_name = step['Module Name']


                # Generate steps based on module type
                if module_name == 'API':
                    self._generate_api_step(step, robot_ui_test)
                else:
                    self._generate_ui_step(robot_ui_test,step, page_name, module_name, data_set)

        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error creating test steps: {str(e)}")
            raise

    def _generate_api_step(self, step, robot_ui_test):
        try:
            self.child_suite.tests.remove(robot_ui_test)
            self.child_suite.name = f"APISubSuite.{step['Page Name']}.{step['Case ID']}"
            tc_id_list = step['APIs'].split(',')
            self.api_robot_generator.create_test_suite(tc_id_list, None, self.child_suite)
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error generating API step: {str(e)}")
            raise

    def _generate_ui_step(self, robot_ui_test,step, page_name, module_name, params):
        try:
            self.child_suite.name = f"UISubSuite.{page_name}.{step['Case ID']}"
            robot_ui_test.body.create_keyword(name='execute_module', args=[page_name, module_name, params])
            self.child_suite.teardown.config(name='close_browser', args=[])
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error generating UI step for {page_name}.{module_name}: {str(e)}")
            raise

</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_performance___init___py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\performance\__init__.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre></pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_performance_web_pt_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\performance\web_pt.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import logging
import os
import json
import time
from typing import Dict, Tuple
from libraries.common.utility_helpers import PROJECT_ROOT
from libraries.common.config_manager import ConfigManager
from libraries.performance.web_pt_loader import PerformanceTestLoader
from libraries.web.webdriver_factory import WebDriverFactory
from libraries.web.web_actions import WebElementActions
from libraries.performance.web_pt_reporter import WebPerformanceReporter

class WebPerformanceTester:
    def __init__(self, test_config_path: str = None, test_cases_path: str = None):
        self.project_root = PROJECT_ROOT
        self.test_config_path = test_config_path or os.path.join(self.project_root, 'configs', 'web_pt_config.yaml')
        self.test_cases_path = test_cases_path or os.path.join(self.project_root, 'test_cases', 'web_pt_cases.xlsx')

        self._web_actions_instance = None
        self._driver = None
        self.current_case_id = None
        self.response_time_data = []
        self.memory_usage_data = []

        self._load_configuration()
        self._initialize_components()

    def _load_configuration(self):
        self.test_config = ConfigManager.load_yaml(self.test_config_path)
        self.performance_test_loader = PerformanceTestLoader(self.test_cases_path, self.test_config)
        self.env_config = self._load_environment_config()
        self.main_config = self._load_main_config()

    def _load_main_config(self):
        web_environments = self.performance_test_loader.get_web_environments()
        active_env = self.test_config['active_environment']
        env_config = web_environments[web_environments['Environment'] == active_env].iloc[0].to_dict()
        return {
            'Target URL': env_config['TargetURL'],
            'Rounds': env_config['Rounds'],
            'Log Details': env_config['LogDetails']
        }

    def _load_environment_config(self):
        web_environments = self.performance_test_loader.get_web_environments()
        active_env = self.test_config['active_environment']
        env_config = web_environments[web_environments['Environment'] == active_env].iloc[0].to_dict()
        env_config['BrowserOptions'] = json.loads(env_config['BrowserOptions'])

        return {
            'environments': {
                active_env: {
                    'browser': env_config['Browser'],
                    'is_remote': env_config['IsRemote'],
                    'remote_url': env_config['RemoteURL'],
                    'chrome_path': env_config['ChromePath'],
                    'chrome_driver_path': env_config['ChromeDriverPath'],
                    'edge_path': env_config['EdgePath'],
                    'edge_driver_path': env_config['EdgeDriverPath'],
                    'browser_options': env_config['BrowserOptions']
                }
            }
        }

    def _initialize_components(self):
        self.test_cases = self.performance_test_loader.get_test_cases()
        self.test_functions = self.performance_test_loader.get_test_functions()
        self.sub_functions = self.performance_test_loader.get_sub_functions()
        self.locators = self.performance_test_loader.get_locators()
        self.page_elements = self._load_page_elements()
        self.custom_actions = self.performance_test_loader.get_custom_actions()

    @property
    def driver(self):
        if self._driver is None:
            active_env_config = self.env_config['environments'][self.test_config['active_environment']]
            self._driver = WebDriverFactory.create_driver(active_env_config)
        return self._driver

    @property
    def web_actions(self):
        if self._web_actions_instance is None:
            self._web_actions_instance = WebElementActions(self.driver)
        return self._web_actions_instance

    def get_js_memory(self):
        try:
            js_memory = self.driver.execute_script("return window.performance.memory;")
            if js_memory:
                used_js_memory_mb = js_memory.get("usedJSHeapSize", 0) / (1024 * 1024)
                return round(used_js_memory_mb, 2)
        except Exception as e:
            logging.error(f"Error in get_js_memory: {e}")
        return None

    def execute_single_test(self, case_id: str):
        case_name = self.test_cases[self.test_cases['Case ID'] == case_id]['Name'].iloc[0]
        logging.info(f"Executing test case: {case_id} - {case_name}")


        try:
            rounds = int(self.main_config['Rounds'])
            target_url = self.main_config['Target URL']

            test_case = self.test_cases[self.test_cases['Case ID'] == case_id].iloc[0]
            if test_case['Run'] != 'Y':
                logging.warning(f"Test case {case_id} is not marked to run.")
                return

            case_functions = self.test_functions[self.test_functions['Case ID'] == case_id].sort_values('Execution Order')

            for round_num in range(rounds):
                self.driver.get(target_url)
                memory_usage = self.get_js_memory()
                if memory_usage is not None:
                    self.memory_usage_data.append({"round": round_num + 1, "case_id": case_id, "used_MB": memory_usage})

                for _, function in case_functions.iterrows():
                    function_name = function['Function Name']
                    self._execute_test_function(round_num, function_name, case_id)
        finally:
            logging.info(f"Finished executing test case: {case_id} - {case_name}")

    def _execute_test_function(self, round_num, function_name, case_id):
        function_steps = self.test_functions[self.test_functions['Function Name'] == function_name].iloc[0]

        precondition_steps = self.sub_functions[self.sub_functions['Sub Function Name'] == function_steps['Precondition subFunction']].sort_values('Step Order')
        operation_steps = self.sub_functions[self.sub_functions['Sub Function Name'] == function_steps['Operation subFunction']].sort_values('Step Order')
        postcondition_steps = self.sub_functions[self.sub_functions['Sub Function Name'] == function_steps['Postcondition subFunction']].sort_values('Step Order')

        for _, step in precondition_steps.iterrows():
            self._execute_step(step)
        start_time = time.time()
        for _, step in operation_steps.iterrows():
            self._execute_step(step)
        end_time = time.time()
        response_time = round(end_time - start_time, 2)
        self.response_time_data.append({
            "round": round_num + 1,
            "case_id": case_id,
            "function_name": function_name,
            "response_time": response_time
        })
        for _, step in postcondition_steps.iterrows():
            self._execute_step(step)

    def _execute_step(self, step):
        action_name = step['Action'].lower()
        page = step['Page']
        element = step['Element']
        input_value = step['Input Value (if applicable)']
        locator = self.page_elements[page][element] if element else None

        logging.info(
            f"{self.__class__.__name__}: Executing action:[{action_name}] on page:[{page}]"
            + (f" element:[{element}]" if element else "")
            + (f" with input:[{input_value}]" if input_value else "")
        )
        self.change_log_level = self.main_config['Log Details']
        if self.change_log_level != 'Y':
            # Temporarily set the logging level to WARNING
            logger = logging.getLogger()
            original_level = logger.level
            logger.setLevel(logging.WARNING)

        try:
            if hasattr(self.web_actions, action_name):
                action = getattr(self.web_actions, action_name)
                if locator is not None:
                    if input_value:
                        action(locator, input_value)
                    else:
                        action(locator)
                else:
                    if input_value:
                        action(input_value)
                    else:
                        action()
            else:
                raise ValueError(f"Unknown action type: {step['Action']}")
            logging.info("="*100)
        finally:

            # Restore the original logging level after execution
            if self.change_log_level != 'Y':
                logger.setLevel(original_level)

    def _load_page_elements(self) -&gt; Dict[str, Dict[str, Tuple[str, str]]]:
        elements = {}
        for _, row in self.locators.iterrows():
            elements.setdefault(row['Page'], {})[row['Element']] = (row['Locator Type'], row['Locator Value'])
        return elements

    def generate_reports(self, case_id: str = None):
        if case_id is None:
            case_id = self.current_case_id

        # Get the case name from the test cases
        case_name = self.test_cases[self.test_cases['Case ID'] == case_id]['Name'].iloc[0]

        filtered_response_time_data = [data for data in self.response_time_data if data['case_id'] == case_id]
        filtered_memory_usage_data = [data for data in self.memory_usage_data if data['case_id'] == case_id]

        reporter = WebPerformanceReporter(filtered_response_time_data, filtered_memory_usage_data)

        return {
            'memory_chart': reporter.generate_memory_usage_chart(case_id, case_name),
            'response_time_stats_chart': reporter.generate_response_time_statistics_chart(case_id, case_name),
            'response_time_trend_chart': reporter.generate_response_time_trend_chart(case_id, case_name),
            'response_time_table': reporter.generate_response_time_statistics_table(case_id, case_name)
        }

    def save_to_csv(self):
        reporter = WebPerformanceReporter(self.response_time_data, self.memory_usage_data)
        reporter.save_to_csv()

    def close(self):
        if self._driver:
            self._driver.quit()
            self._driver = None</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_performance_web_pt_loader_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\performance\web_pt_loader.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import json
import logging
import pandas as pd
import os
from typing import Dict, List

class PerformanceTestLoader:
    _instances = {}

    def __new__(cls, excel_path, test_config):
        key = (excel_path, id(test_config))  # Use a tuple of excel_path and test_config id as the key
        if key not in cls._instances:
            instance = super().__new__(cls)
            instance.__init__(excel_path, test_config)
            cls._instances[key] = instance
        return cls._instances[key]

    def __init__(self, excel_path, test_config):
        if hasattr(self, 'initialized'):
            return
        self.excel_path = excel_path
        self.test_config = test_config
        self.data = self._load_excel_data()
        self._validate_data()
        self.initialized = True

    def _load_excel_data(self) -&gt; Dict[str, pd.DataFrame]:
        sheets = [
            'TestCases', 'TestFunctions', 'SubFunctions', 'Locators', 'WebEnvironments', 'CustomActions'
        ]
        return {sheet: pd.read_excel(self.excel_path, sheet_name=sheet).fillna("") for sheet in sheets}

    def _validate_data(self):
        self._validate_test_cases()
        self._validate_test_functions()
        self._validate_sub_functions()
        self._validate_locators()
        self._validate_web_environments()
        self._validate_custom_actions()

    def _validate_test_cases(self):
        test_cases = self.get_data_by_sheet_name('TestCases')
        required_columns = ['Case ID', 'Description', 'Run']
        missing_columns = set(required_columns) - set(test_cases.columns)
        if missing_columns:
            logging.error(f"PerformanceTestLoader: Missing required columns in TestCases sheet: {', '.join(missing_columns)}")

        for index, row in test_cases.iterrows():
            if pd.isna(row['Case ID']) or row['Case ID'] == '':
                logging.error(f"PerformanceTestLoader: Empty Case ID in TestCases row {index + 2}")
            if row['Run'] not in ['Y', 'N']:
                logging.error(f"PerformanceTestLoader: Invalid Run value in TestCases row {index + 2}. Must be 'Y' or 'N'")

    def _validate_test_functions(self):
        test_functions = self.get_data_by_sheet_name('TestFunctions')
        required_columns = ['Case ID', 'Execution Order', 'Function Name', 'Precondition subFunction', 'Operation subFunction', 'Postcondition subFunction', 'Description']
        missing_columns = set(required_columns) - set(test_functions.columns)
        if missing_columns:
            logging.error(f"PerformanceTestLoader: Missing required columns in TestFunctions sheet: {', '.join(missing_columns)}")

        for index, row in test_functions.iterrows():
            if pd.isna(row['Case ID']) or row['Case ID'] == '':
                logging.error(f"PerformanceTestLoader: Empty Case ID in TestFunctions row {index + 2}")
            if pd.isna(row['Function Name']) or row['Function Name'] == '':
                logging.error(f"PerformanceTestLoader: Empty Function Name in TestFunctions row {index + 2}")

    def _validate_sub_functions(self):
        sub_functions = self.get_data_by_sheet_name('SubFunctions')
        required_columns = ['Sub Function Name', 'Step Order', 'Page', 'Element', 'Action', 'Input Value (if applicable)', 'Description']
        missing_columns = set(required_columns) - set(sub_functions.columns)
        if missing_columns:
            logging.error(f"PerformanceTestLoader: Missing required columns in SubFunctions sheet: {', '.join(missing_columns)}")

        for index, row in sub_functions.iterrows():
            if pd.isna(row['Sub Function Name']) or row['Sub Function Name'] == '':
                logging.error(f"PerformanceTestLoader: Empty Sub Function Name in SubFunctions row {index + 2}")

    def _validate_locators(self):
        locators = self.get_data_by_sheet_name('Locators')
        required_columns = ['Page', 'Element', 'Locator Type', 'Locator Value', 'Description']
        missing_columns = set(required_columns) - set(locators.columns)
        if missing_columns:
            logging.error(f"PerformanceTestLoader: Missing required columns in Locators sheet: {', '.join(missing_columns)}")

        for index, row in locators.iterrows():
            if pd.isna(row['Page']) or row['Page'] == '':
                logging.error(f"PerformanceTestLoader: Empty Page in Locators row {index + 2}")
            if pd.isna(row['Element']) or row['Element'] == '':
                logging.error(f"PerformanceTestLoader: Empty Element in Locators row {index + 2}")
            if row['Locator Type'] not in ['id', 'name', 'xpath', 'css', 'class', 'tag', 'link_text', 'partial_link_text']:
                logging.error(f"PerformanceTestLoader: Invalid Locator Type '{row['Locator Type']}' in Locators row {index + 2}")

    def _validate_web_environments(self):
        web_environments = self.get_data_by_sheet_name('WebEnvironments')

        if web_environments.empty:
            logging.error("PerformanceTestLoader: WebEnvironments sheet is empty or does not exist.")
            return

        required_columns = ['Environment', 'TargetURL', 'Rounds', 'LogDetails', 'Browser', 'IsRemote', 'RemoteURL', 'ChromePath', 'ChromeDriverPath', 'EdgePath', 'EdgeDriverPath',
                            'BrowserOptions']
        missing_columns = set(required_columns) - set(web_environments.columns)
        if missing_columns:
            logging.error(f"PerformanceTestLoader: Missing required columns in WebEnvironments sheet: {', '.join(missing_columns)}")
            return

        # Check if active_environment exists in WebEnvironments
        active_environment = self.test_config.get('active_environment')
        if active_environment and active_environment not in web_environments['Environment'].values:
            logging.error(f"PerformanceTestLoader: Active environment '{active_environment}' specified in config file does not exist in WebEnvironments sheet.")

        for index, row in web_environments.iterrows():
            if self.test_config.get('active_environment') != row['Environment']:
                continue
            if pd.isna(row['Environment']) or row['Environment'] == '':
                logging.error(f"PerformanceTestLoader: Empty Environment name in WebEnvironments row {index + 2}")

            if pd.isna(row['TargetURL']) or row['TargetURL'] == '':
                logging.error(f"PerformanceTestLoader: TargetURL cannot be empty in WebEnvironments row {index + 2}")

            if pd.isna(row['Rounds']) or row['Rounds'] == '':
                logging.error(f"PerformanceTestLoader: Rounds cannot be empty in WebEnvironments row {index + 2}")
            else:
                try:
                    rounds = int(row['Rounds'])
                    if rounds &lt;= 0:
                        logging.error(f"PerformanceTestLoader: Rounds must be a positive integer in WebEnvironments row {index + 2}")
                except ValueError:
                    logging.error(f"PerformanceTestLoader: Rounds must be a valid integer in WebEnvironments row {index + 2}")

            if row['Browser'].lower() not in ['chrome', 'edge']:
                logging.error(f"PerformanceTestLoader: Invalid Browser '{row['Browser']}' in WebEnvironments row {index + 2}. Must be 'chrome' or 'edge'.")

            if not isinstance(row['IsRemote'], bool):
                logging.error(f"PerformanceTestLoader: IsRemote must be a boolean value in WebEnvironments row {index + 2}")

            if row['IsRemote']:
                if pd.isna(row['RemoteURL']) or row['RemoteURL'] == '':
                    logging.error(f"PerformanceTestLoader: RemoteURL is required when IsRemote is True in WebEnvironments row {index + 2}")
            else:
                if row['Browser'].lower() == 'chrome':
                    for path_column in ['ChromePath', 'ChromeDriverPath']:
                        if pd.isna(row[path_column]) or row[path_column] == '':
                            logging.error(f"PerformanceTestLoader: {path_column} is required when IsRemote is False and Browser is Chrome in WebEnvironments row {index + 2}")
                        elif not os.path.exists(row[path_column]):
                            logging.warning(f"PerformanceTestLoader: {path_column} '{row[path_column]}' does not exist in WebEnvironments row {index + 2}")
                elif row['Browser'].lower() == 'edge':
                    for path_column in ['EdgePath', 'EdgeDriverPath']:
                        if pd.isna(row[path_column]) or row[path_column] == '':
                            logging.error(f"PerformanceTestLoader: {path_column} is required when IsRemote is False and Browser is Edge in WebEnvironments row {index + 2}")
                        elif not os.path.exists(row[path_column]):
                            logging.warning(f"PerformanceTestLoader: {path_column} '{row[path_column]}' does not exist in WebEnvironments row {index + 2}")

            try:
                if not pd.isna(row['BrowserOptions']) and row['BrowserOptions'] != '':
                    json.loads(row['BrowserOptions'])
            except json.JSONDecodeError:
                logging.error(f"PerformanceTestLoader: Invalid JSON in BrowserOptions in WebEnvironments row {index + 2}")

        logging.info("PerformanceTestLoader: WebEnvironments data validation completed.")

    def _validate_custom_actions(self):
        custom_actions = self.get_data_by_sheet_name('CustomActions')
        required_columns = ['Action Name', 'Description', 'Python Code']
        missing_columns = set(required_columns) - set(custom_actions.columns)
        if missing_columns:
            logging.error(f"PerformanceTestLoader: Missing required columns in CustomActions sheet: {', '.join(missing_columns)}")

        for index, row in custom_actions.iterrows():
            if pd.isna(row['Action Name']) or row['Action Name'] == '':
                logging.error(f"PerformanceTestLoader: Empty Action Name in CustomActions row {index + 2}")
            if pd.isna(row['Python Code']) or row['Python Code'] == '':
                logging.error(f"PerformanceTestLoader: Empty Python Code for Action '{row['Action Name']}' in CustomActions row {index + 2}")

    def get_data_by_sheet_name(self, sheet_name: str) -&gt; pd.DataFrame:
        return self.data.get(sheet_name, pd.DataFrame())

    def get_test_cases(self) -&gt; pd.DataFrame:
        return self.get_data_by_sheet_name('TestCases')

    def get_test_functions(self) -&gt; pd.DataFrame:
        return self.get_data_by_sheet_name('TestFunctions')

    def get_sub_functions(self) -&gt; pd.DataFrame:
        return self.get_data_by_sheet_name('SubFunctions')

    def get_locators(self) -&gt; pd.DataFrame:
        return self.get_data_by_sheet_name('Locators')

    def get_web_environments(self) -&gt; pd.DataFrame:
        return self.get_data_by_sheet_name('WebEnvironments')

    def get_custom_actions(self) -&gt; pd.DataFrame:
        return self.get_data_by_sheet_name('CustomActions')
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_performance_web_pt_reporter_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\performance\web_pt_reporter.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import os

import pandas as pd
import matplotlib.pyplot as plt
from io import BytesIO
import base64
import logging
from libraries.common.utility_helpers import PROJECT_ROOT


class WebPerformanceReporter:
    def __init__(self, response_time_data, memory_usage_data):
        self.response_time_data = response_time_data
        self.memory_usage_data = memory_usage_data

    def generate_memory_usage_chart(self, case_id, case_name):
        df = pd.DataFrame(self.memory_usage_data)
        plt.figure(figsize=(10, 6))
        plt.plot(df["round"], df["used_MB"], marker="o", label="Used Memory (MB)", color="blue")
        plt.title(f"JavaScript Memory Usage Trend - Case ID: {case_id}, Case Name: {case_name}")
        plt.xlabel("Round")
        plt.ylabel("Memory (MB)")
        plt.grid()
        plt.legend()
        return self._save_fig_as_base64()

    def generate_response_time_statistics_chart(self, case_id, case_name):
        df = pd.DataFrame(self.response_time_data)
        stats = df.groupby("function_name").agg({"response_time": ["mean", "max"]})
        stats.columns = ["Mean", "Max"]
        stats.reset_index(inplace=True)

        stats.plot(kind="bar", x="function_name", figsize=(10, 6), colormap="coolwarm")
        plt.title(f"Response Time Statistics - Case ID: {case_id}, Case Name: {case_name}")
        plt.xlabel("Function Name")
        plt.ylabel("Time (s)")
        plt.grid(axis="y")
        plt.xticks(rotation=45)
        return self._save_fig_as_base64()

    def generate_response_time_trend_chart(self, case_id, case_name):
        df = pd.DataFrame(self.response_time_data)
        plt.figure(figsize=(10, 6))
        for func in df["function_name"].unique():
            func_data = df[df["function_name"] == func]
            plt.plot(func_data["round"], func_data["response_time"], marker="o", label=func)

        plt.title(f"Response Time Trend - Case ID: {case_id}, Case Name: {case_name}")
        plt.xlabel("Round")
        plt.ylabel("Response Time (s)")
        plt.legend(title="Function Points")
        plt.grid()
        return self._save_fig_as_base64()

    def generate_response_time_statistics_table(self, case_id, case_name):
        df = pd.DataFrame(self.response_time_data)
        stats = df.groupby("function_name").agg({
            "response_time": [
                lambda x: round(x.mean(), 2),
                lambda x: round(x.max(), 2),
                lambda x: round(x.min(), 2),
                lambda x: round(x.median(), 2),
                lambda x: round(x.quantile(0.9), 2),
                lambda x: round(x.quantile(0.95), 2),
                lambda x: round(x.quantile(0.99), 2)
            ]
        }).reset_index()

        stats.columns = ["Function Name", "Mean (s)", "Max (s)", "Min (s)",
                         "Median (s)", "P90 (s)", "P95 (s)", "P99 (s)"]

        fig, ax = plt.subplots(figsize=(10, len(stats) * 0.5))
        ax.axis("tight")
        ax.axis("off")
        table = plt.table(cellText=stats.values, colLabels=stats.columns, cellLoc="center", loc="center")
        table.auto_set_font_size(False)
        table.set_fontsize(10)
        table.scale(1.3, 1.5)
        plt.title(f"Response Time Statistics Table - Case ID: {case_id}, Case Name: {case_name}", y=1.1)
        return self._save_fig_as_base64()

    def save_to_csv(self):
        output_dir = os.path.join(PROJECT_ROOT, 'report')
        response_time_data_path = os.path.join(output_dir, 'response_time_data.csv')
        memory_usage_data_path = os.path.join(output_dir, 'memory_usage_data.csv')

        if self.response_time_data:
            response_time_df = pd.DataFrame(self.response_time_data)
            response_time_df.to_csv(response_time_data_path, index=False)
            logging.info("Response time data saved to 'response_time_data.csv'.")

        if self.memory_usage_data:
            memory_usage_df = pd.DataFrame(self.memory_usage_data)
            memory_usage_df.to_csv(memory_usage_data_path, index=False)
            logging.info("Memory usage data saved to 'memory_usage_data.csv'.")

    def _save_fig_as_base64(self):
        buf = BytesIO()
        plt.savefig(buf, format="png", bbox_inches="tight")
        buf.seek(0)
        base64_image = base64.b64encode(buf.getvalue()).decode("utf-8")
        plt.close()
        return base64_image
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_performance_web_pt_robot_generator_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\performance\web_pt_robot_generator.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import os
from robot.api import TestSuite
from libraries.common.config_manager import ConfigManager
from libraries.performance.web_pt_loader import PerformanceTestLoader
from libraries.common.utility_helpers import PROJECT_ROOT

class WebPerformanceRobotCasesGenerator:
    def __init__(self, test_config_path: str = None, test_cases_path: str = None):
        self.project_root = PROJECT_ROOT
        self.test_config_path = test_config_path or os.path.join(self.project_root, 'configs', 'web_pt_config.yaml')
        self.test_cases_path = test_cases_path or os.path.join(self.project_root, 'test_cases', 'web_pt_cases.xlsx')

        self._load_configuration()
        self._initialize_components()

    def _load_configuration(self):
        self.test_config = ConfigManager.load_yaml(self.test_config_path)

    def _initialize_components(self):
        self.performance_test_loader = PerformanceTestLoader(self.test_cases_path, self.test_config)

    def create_test_suite(self):
        # Create main test suite
        self.robot_suite = TestSuite('Web Performance TestSuite')
        self._import_required_libraries()

        # Load test cases
        test_cases = self.performance_test_loader.get_test_cases()

        for _, test_case in test_cases.iterrows():
            if test_case['Run'] == 'Y':
                case_id = test_case['Case ID']
                test_name = f"Performance.{case_id}"
                robot_test = self.robot_suite.tests.create(name=test_name, doc=test_case['Description'])

                # Create a single execute_single_test keyword for each test case
                robot_test.body.create_keyword(name='execute_single_test', args=[case_id])
                robot_test.body.create_keyword(name='generate_reports', args=[case_id])

        # Add setup and teardown for the entire suite
        self.robot_suite.setup.config(name='initialize_tester', args=[])
        self.robot_suite.teardown.config(name='finalize_and_close_tester', args=[])
        return self.robot_suite

    def _import_required_libraries(self):
        self.robot_suite.resource.imports.library(
            'libraries.performance.web_pt_robot_keyword.RobotFrameworkWebTester')
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_performance_web_pt_robot_keyword_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\performance\web_pt_robot_keyword.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>from robot.api import logger
from libraries.performance.web_pt import WebPerformanceTester

class RobotFrameworkWebTester:
    ROBOT_LIBRARY_SCOPE = 'TEST SUITE'
    def __init__(self):
        self.tester = None

    def initialize_tester(self, test_config_path=None, test_cases_path=None):
        """Initialize the performance tester."""
        self.tester = WebPerformanceTester(test_config_path, test_cases_path)
        logger.info("Performance tester initialized successfully.")

    def execute_single_test(self, case_id: str):
        """Execute a single performance test case."""
        if not self.tester:
            raise ValueError("Tester is not initialized.")
        self.tester.execute_single_test(case_id)

    def generate_reports(self, case_id: str):
        """Generate performance reports (charts and tables) for a specific case."""
        if not self.tester:
            raise ValueError("Tester is not initialized.")

        report_data = self.tester.generate_reports(case_id)

        logger.info('&lt;h2&gt;Memory Usage Trend Chart&lt;/h2&gt;', html=True)
        logger.info(f'&lt;img src="data:image/png;base64,{report_data["memory_chart"]}" alt="Memory Usage Trend"/&gt;', html=True)

        logger.info('&lt;h2&gt;Response Time Statistics Chart&lt;/h2&gt;', html=True)
        logger.info(f'&lt;img src="data:image/png;base64,{report_data["response_time_stats_chart"]}" alt="Response Time Statistics"/&gt;', html=True)

        logger.info('&lt;h2&gt;Response Time Trend Chart&lt;/h2&gt;', html=True)
        logger.info(f'&lt;img src="data:image/png;base64,{report_data["response_time_trend_chart"]}" alt="Response Time Trend"/&gt;', html=True)

        logger.info('&lt;h2&gt;Response Time Statistics Table&lt;/h2&gt;', html=True)
        logger.info(f'&lt;img src="data:image/png;base64,{report_data["response_time_table"]}" alt="Response Time Statistics Table"/&gt;', html=True)


    def finalize_and_close_tester(self):
        """Finalize the test by saving data to CSV, then close the tester and release resources."""
        if self.tester:
            self.tester.save_to_csv()
            self.tester.close()
            logger.info("Tester finalized and closed successfully.")</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_robot___init___py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\robot\__init__.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre></pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_robot_robot_dashboard_generator_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\robot\robot_dashboard_generator.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import os
import codecs
from robot.api import ExecutionResult
from jinja2 import Environment, FileSystemLoader

from libraries.robot.robot_result_visitor import CustomResultVisitor
from libraries.robot.robot_report_data import ReportData
from libraries.common.utility_helpers import PROJECT_ROOT


class DashboardGenerator:
    def __init__(self):
        self.result = None
        self.visitor = CustomResultVisitor()
        self.suite_list = []
        self.test_list = []
        self.suite_stats = {}
        self.test_stats = {}

    def _load_data(self, robot_output_path):
        self.result = ExecutionResult(robot_output_path)
        self.result.visit(self.visitor)
        self.suite_list = self.visitor.suite_list
        self.test_list = self.visitor.test_list
        report_data = ReportData()
        self.suite_stats = report_data.get_suite_statistics(self.suite_list)
        self.test_stats = report_data.get_test_statistics(self.test_list)

    def generate_dashboard(self, robot_output_path):
        self._load_data(robot_output_path)
        result_file_name = 'dashboard.html'
        result_file_directory = os.path.join(PROJECT_ROOT, 'report')
        os.makedirs(result_file_directory, exist_ok=True)
        result_file_path = os.path.join(result_file_directory, result_file_name)
        templates_dir = os.path.join(PROJECT_ROOT, 'templates')
        file_loader = FileSystemLoader(templates_dir)
        env = Environment(loader=file_loader)
        template = env.get_template('rf_report_template.html')
        with codecs.open(result_file_path, 'w', 'utf-8') as fh:
            fh.write(template.render(
                suite_stats=self.suite_stats,
                test_stats=self.test_stats,
                suites=self.suite_list,
                tests=self.test_list,
            ))


if __name__ == '__main__':
    # Example usage:
    generator = DashboardGenerator()
    generator.generate_dashboard(os.path.join(PROJECT_ROOT, 'report', 'output.xml'))
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_robot_robot_report_data_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\robot\robot_report_data.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import pandas as pd


class ReportData:

    def __init__(self):
        pass

    @classmethod
    def get_suite_statistics(self, suite_list):
        suite_data_frame = pd.DataFrame.from_records(suite_list)
        suite_stats = {
            "Total": suite_data_frame.Name.count(),
            "Pass": (suite_data_frame.Status == 'PASS').sum(),
            "Fail": (suite_data_frame.Status == 'FAIL').sum(),
            "Skip": (suite_data_frame.Status == 'SKIP').sum(),
            "Time": suite_data_frame.Time.sum(),
            "Min": suite_data_frame.Time.min(),
            "Max": suite_data_frame.Time.max(),
            "Avg": suite_data_frame.Time.mean()
        }
        return suite_stats

    @classmethod
    def get_test_statistics(self, test_list):
        test_data_frame = pd.DataFrame.from_records(test_list)
        test_stats = {
            "Total": test_data_frame.Status.count(),
            "Pass": (test_data_frame.Status == 'PASS').sum(),
            "Fail": (test_data_frame.Status == 'FAIL').sum(),
            "Skip": (test_data_frame.Status == 'SKIP').sum(),
            "Time": test_data_frame.Time.sum(),
            "Min": test_data_frame.Time.min(),
            "Max": test_data_frame.Time.max(),
            "Avg": test_data_frame.Time.mean()
        }
        return test_stats
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_robot_robot_result_visitor_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\robot\robot_result_visitor.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>from robot.api import ResultVisitor


class CustomResultVisitor(ResultVisitor):

    def __init__(self):
        self.suite_list = []
        self.test_list = []

    def start_suite(self, suite):
        if suite.tests:
            try:
                stats = suite.statistics.all
            except:
                stats = suite.statistics

            try:
                skipped = stats.skipped
            except:
                skipped = 0

            suite_json = {
                "Name": suite.longname,
                "Id": suite.id,
                "Status": suite.status,
                "Total": stats.total,
                "Pass": stats.passed,
                "Fail": stats.failed,
                "Skip": skipped,
                "startTime": suite.starttime,
                "endTime": suite.endtime,
                "Time": suite.elapsedtime
            }
            self.suite_list.append(suite_json)

    def visit_test(self, test):
        test_json = {
            "Suite Name": test.parent.longname,
            "Suite Id": test.parent.id,
            "Test Name": test.name,
            "Test Id": test.id,
            "Status": test.status,
            "startTime": test.starttime,
            "endTime": test.endtime,
            "Time": test.elapsedtime,
            "Message": test.message,
            "Tags": test.tags
        }
        self.test_list.append(test_json)
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web___init___py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\__init__.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre></pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_custom_action_executor_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\custom_action_executor.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import ast
from typing import Any, Dict
import inspect


class CustomActionExecutor:
    def __init__(self, custom_actions: Dict[str, str]):
        self.custom_actions = custom_actions
        self.parsed_actions = {}

    def execute_custom_action(self, action_name: str, element=None, web_actions=None, *args, **kwargs):
        if action_name not in self.custom_actions:
            raise ValueError(f"Custom action '{action_name}' not found")

        if action_name not in self.parsed_actions:
            code = self.custom_actions[action_name]
            try:
                parsed = ast.parse(code)
                # self._check_code_safety(parsed, action_name)
                self.parsed_actions[action_name] = code
            except SyntaxError:
                raise ValueError(f"Syntax error in custom action '{action_name}'")

        # 创建一个新的命名空间来执行代码
        namespace = {'element': element, 'web_action': web_actions, **kwargs}
        exec(self.parsed_actions[action_name], namespace)

        if 'execute' not in namespace:
            raise ValueError(f"Custom action '{action_name}' must define an 'execute' function")

        execute_func = namespace['execute']
        sig = inspect.signature(execute_func)

        # 检查 execute 函数是否需要 element 参数
        if 'element' in sig.parameters:
            return execute_func(element, web_actions, *args, **kwargs)
        else:
            return execute_func(web_actions, *args, **kwargs)

    def _check_code_safety(self, node, action_name):
        allowed_nodes = (
            ast.Module,
            ast.FunctionDef,
            ast.ClassDef,
            ast.Return,
            ast.Expr,
            ast.Call,
            ast.Name,
            ast.Attribute,
            ast.arguments,
            ast.arg,
            ast.Constant,
            ast.List,
            ast.Dict,
            ast.If,
            ast.For,
            ast.While,
            ast.Compare,
            ast.BinOp,
            ast.UnaryOp,
            ast.Assign,
            ast.AugAssign,
            ast.Break,
            ast.Continue,
            ast.Pass,
        )

        if not isinstance(node, allowed_nodes):
            raise ValueError(f"Unsupported Python construct in custom action '{action_name}': {type(node).__name__}")

        # 递归检查子节点
        # for child in ast.iter_child_nodes(node):
        #     self._check_code_safety(child, action_name)

        # 检查是否使用了不允许的内建函数
        if isinstance(node, ast.Call) and isinstance(node.func, ast.Name):
            disallowed_builtins = {'eval', 'exec', 'compile', '__import__', 'open'}
            if node.func.id in disallowed_builtins:
                raise ValueError(f"Use of '{node.func.id}' is not allowed in custom action '{action_name}'")</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_page_object_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\page_object.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import json
import logging
import os
import re
from typing import Dict, Tuple, List
from robot.api.deco import keyword
from libraries.web.web_actions import WebElementActions
from libraries.common.utility_helpers import PROJECT_ROOT
from libraries.common.config_manager import ConfigManager
from libraries.web.web_test_loader import WebTestLoader
from libraries.web.webdriver_factory import WebDriverFactory
from libraries.web.custom_action_executor import CustomActionExecutor
from robot.libraries.BuiltIn import BuiltIn

builtin_lib = BuiltIn()


class WebDriverSingleton:
    _instance = None

    @classmethod
    def get_instance(cls, driver_config=None):
        logging.info("WebDriverSingleton: Getting WebDriver instance")
        if cls._instance is None:
            if driver_config is None:
                raise ValueError("WebDriverSingleton: Config path must be provided when creating the first instance")
            cls._instance = WebDriverFactory.create_driver(driver_config)
            logging.info("WebDriverSingleton: WebDriver instance created")
        return cls._instance

    @classmethod
    def quit(cls):
        if cls._instance:
            cls._instance.close()
            cls._instance = None
            logging.info("WebDriverSingleton: WebDriver instance closed")


class PageObject:
    def __init__(self, test_config_path: str = None, test_cases_path: str = None):
        self.project_root = PROJECT_ROOT
        self.test_config_path = test_config_path or os.path.join(self.project_root, 'configs', 'web_test_config.yaml')
        self.test_cases_path = test_cases_path or os.path.join(self.project_root, 'test_cases', 'web_test_cases.xlsx')

        self._web_actions_instance = None
        self._driver = None
        self._load_configuration()
        self._initialize_components()

    def _load_configuration(self):
        self.test_config = ConfigManager.load_yaml(self.test_config_path)
        self.web_test_loader = WebTestLoader(self.test_cases_path, self.test_config)
        self.env_config = self._load_environment_config()

    def _load_environment_config(self):
        environments = self.web_test_loader.get_web_environments()
        active_env = self.test_config['active_environment']
        env_config = environments[environments['Environment'] == active_env].iloc[0].to_dict()
        env_config['BrowserOptions'] = json.loads(env_config['BrowserOptions'])

        return {
            'environments': {
                active_env: {
                    'browser': env_config['Browser'],
                    'is_remote': env_config['IsRemote'],
                    'remote_url': env_config['RemoteURL'],
                    'chrome_path': env_config['ChromePath'],
                    'chrome_driver_path': env_config['ChromeDriverPath'],
                    'edge_path': env_config['EdgePath'],
                    'edge_driver_path': env_config['EdgeDriverPath'],
                    'browser_options': env_config['BrowserOptions']
                }
            }
        }

    def _initialize_components(self):
        self.locators_df = self.web_test_loader.get_locators()
        self.page_object_df = self.web_test_loader.get_page_objects()
        self.page_elements = self._load_page_elements()
        self.page_modules = self._load_page_modules()
        self.custom_action_executor = CustomActionExecutor(self.web_test_loader.get_custom_actions())

    @property
    def driver(self):
        if self._driver is None:
            active_env_config = self.env_config['environments'][self.test_config['active_environment']]
            self._driver = WebDriverSingleton.get_instance(active_env_config)
            # self._driver.minimize_window()
        return self._driver

    @property
    def web_actions(self):
        if self._web_actions_instance is None:
            self._web_actions_instance = WebElementActions(self.driver)
        return self._web_actions_instance

    def _load_page_elements(self) -&gt; Dict[str, Dict[str, Tuple[str, str]]]:
        elements = {}
        for _, row in self.locators_df.iterrows():
            elements.setdefault(row['Page Name'], {})[row['Element Name']] = (row['Locator Type'], row['Locator Value'])
        return elements

    def _load_page_modules(self) -&gt; Dict[str, Dict[str, List[Dict]]]:
        modules = {}
        for _, row in self.page_object_df.iterrows():
            action_info = {
                'element_name': row['Element Name'],
                'web_action': row['Actions'],
                'parameter_name': row['Parameter Name'].split(',') if row['Parameter Name'] else [],
                'highlight': row['Highlight'],
                'screen_capture': row['Screenshot'],
                'wait': row['Wait']
            }
            modules.setdefault(row['Page Name'], {}).setdefault(row['Module Name'], []).append(action_info)
        return modules

    @keyword
    def execute_module(self, page_name: str, module_name: str, data_set: Dict = None):

        module_actions = self.page_modules[page_name][module_name]

        for action_info in module_actions:
            element_name = action_info['element_name']
            action = action_info['web_action']
            highlight = action_info['highlight']
            screen_capture = action_info['screen_capture']
            wait = action_info['wait']
            locator = self.page_elements[page_name][element_name] if element_name else None
            action_params = self._extract_parameters(data_set, action_info['parameter_name'])

            logging.info(
                f"{self.__class__.__name__}: Executing action:[{action}] on page:[{page_name}] module:[{module_name}]"
                + (f" element:[{element_name}]" if element_name else "")
                + (f" with parameters:{action_params}" if action_params else "")
            )

            if highlight:
                self.web_actions.highlight_element(locator)

            self._execute_action(action, locator, *action_params)

            if wait:
                try:
                    wait_time = float(wait)
                    if wait_time &gt; 0:
                        self.web_actions.wait(wait_time)
                except ValueError:
                    logging.warning(f"Invalid wait value: {wait}. Skipping wait.")

            if screen_capture:
                self.web_actions.capture_screenshot()

            logging.info("=" * 80)

    def _execute_action(self, action: str, locator, *args, **kwargs):
        action_map = {
            # Basic operations
            'open_url': self.web_actions.open_url,
            'send_keys': self.web_actions.send_keys,
            'click': self.web_actions.click,
            'clear': self.web_actions.clear,
            'select_by_value': self.web_actions.select_by_value,
            'select_by_visible_text': self.web_actions.select_by_visible_text,
            'select_by_index': self.web_actions.select_by_index,
            'hover': self.web_actions.hover,
            'double_click': self.web_actions.double_click,
            'right_click': self.web_actions.right_click,
            'scroll_into_view': self.web_actions.scroll_into_view,
            'scroll_to_element': self.web_actions.scroll_to_element,
            'get_text': self.web_actions.get_text,
            'get_attribute': self.web_actions.get_attribute,
            'select_radio_by_value': self.web_actions.select_radio_by_value,
            'fill_by_js': self.web_actions.fill_by_js,
            'click_by_js': self.web_actions.click_by_js,

            # Element state verification
            'element_text_should_be': self.web_actions.element_text_should_be,
            'element_text_should_contains': self.web_actions.element_text_should_contains,
            'title_should_be': self.web_actions.title_should_be,
            'title_should_contains': self.web_actions.title_should_contains,
            'is_element_present': self.web_actions.is_element_present,
            'is_element_visible': self.web_actions.is_element_visible,
            'is_element_clickable': self.web_actions.is_element_clickable,
            'is_element_selected': self.web_actions.is_element_selected,
            'is_element_enabled': self.web_actions.is_element_enabled,

            # Wait operations
            'wait_for_element_present': self.web_actions.wait_for_element_present,
            'wait_for_element_visible': self.web_actions.wait_for_element_visible,
            'wait_for_element_clickable': self.web_actions.wait_for_element_clickable,
            'wait_for_text_present_in_element': self.web_actions.wait_for_text_present_in_element,
            'wait_for_element_to_disappear': self.web_actions.wait_for_element_to_disappear,
            'wait_for_staleness_of': self.web_actions.wait_for_staleness_of,
            'wait': self.web_actions.wait,

            # Frame and window operations
            'switch_to_frame': self.web_actions.switch_to_frame,
            'switch_to_default_content': self.web_actions.switch_to_default_content,
            'switch_to_window': self.web_actions.switch_to_window,
            'get_window_handles': self.web_actions.get_window_handles,
            'close_current_window': self.web_actions.close_current_window,

            # JavaScript execution
            'execute_script': self.web_actions.execute_script,
            'execute_async_script': self.web_actions.execute_async_script,

            # Alert operations
            'accept_alert': self.web_actions.accept_alert,
            'dismiss_alert': self.web_actions.dismiss_alert,
            'get_alert_text': self.web_actions.get_alert_text,

            # Screenshot and highlight
            'capture_screenshot': self.web_actions.capture_screenshot,
            'highlight_element': self.web_actions.highlight_element,

            # Table operations
            'verify_table_exact': self.web_actions.verify_table_exact,
            'verify_table_row_exact': self.web_actions.verify_table_row_exact,
            'verify_specific_cell_exact': self.web_actions.verify_specific_cell_exact,
            'verify_table_partial': self.web_actions.verify_table_partial,
            'verify_table_row_partial': self.web_actions.verify_table_row_partial,
            'verify_specific_cell_partial': self.web_actions.verify_specific_cell_partial,
            'verify_table_regex': self.web_actions.verify_table_regex,
            'verify_table_row_regex': self.web_actions.verify_table_row_regex,
            'verify_specific_cell_regex': self.web_actions.verify_specific_cell_regex,
            'verify_table_is_empty': self.web_actions.verify_table_is_empty,
            'verify_unique_column_values': self.web_actions.verify_unique_column_values,
            'verify_value_in_table': self.web_actions.verify_value_in_table,
            'verify_row_count': self.web_actions.verify_row_count,
            'verify_column_sorted': self.web_actions.verify_column_sorted,
            'select_table_row_checkbox': self.web_actions.select_table_row_checkbox,
            'select_multiple_table_row_checkboxes': self.web_actions.select_multiple_table_row_checkboxes,

            # Browser navigation
            'refresh_page': self.web_actions.refresh_page,
            'go_back': self.web_actions.go_back,
            'go_forward': self.web_actions.go_forward,
            'get_current_url': self.web_actions.get_current_url,

            # Window management
            'set_window_size': self.web_actions.set_window_size,
            'maximize_window': self.web_actions.maximize_window,
            'minimize_window': self.web_actions.minimize_window,
            'fullscreen_window': self.web_actions.fullscreen_window,

            # Cookie operations
            'add_cookie': self.web_actions.add_cookie,
            'get_cookie': self.web_actions.get_cookie,
            'delete_cookie': self.web_actions.delete_cookie,
            'delete_all_cookies': self.web_actions.delete_all_cookies,

            # JavaScript enhanced operations
            'js_click': self.web_actions.js_click,
            'js_send_keys': self.web_actions.js_send_keys,
            'js_clear': self.web_actions.js_clear,
            'js_scroll_into_view': self.web_actions.js_scroll_into_view,
            'js_select_option': self.web_actions.js_select_option,
            'js_hover': self.web_actions.js_hover,

            # Value capture and assertion
            'capture_element_value': self.web_actions.capture_element_value,
            'assert_value_change': self.web_actions.assert_value_change,
        }

        if action not in action_map and action not in self.custom_action_executor.custom_actions:
            raise ValueError(f"{self.__class__.__name__}: Unsupported web_action: {action}")

        # Create a new list to store the modified arguments
        new_args = []
        for arg in args:
            if isinstance(arg, str):
                # Use regex to find all occurrences of ${...} in the string
                matches = re.findall(r'\$\{([^}]+)\}', arg)
                if matches:
                    for match in matches:
                        # Retrieve the actual value for the variable using builtin_lib
                        replacement_value = builtin_lib.get_variable_value(f'${{{match}}}')
                        # Replace the ${...} placeholder with the actual value
                        arg = arg.replace(f'${{{match}}}', str(replacement_value))

                        logging.info(f"{self.__class__.__name__}: Replaced {match} with value: {replacement_value} for web_action: {action}")

            # Add the processed (or original) argument to the new list
            new_args.append(arg)

        if action in action_map:
            return action_map[action](locator, *new_args, **kwargs) if locator else action_map[action](*new_args, **kwargs)
        elif action in self.custom_action_executor.custom_actions:
            return self.custom_action_executor.execute_custom_action(action, locator, self.web_actions, *new_args, **kwargs)
        else:
            raise ValueError(f"{self.__class__.__name__}: Unsupported web_action: {action}")

    @keyword
    def close_browser(self):
        WebDriverSingleton.quit()

    @keyword
    def sanity_check(self) -&gt; None:
        skip_on_sanity_check_failure = BuiltIn().get_variable_value('${skip_on_sanity_check_failure}', default=False)
        if skip_on_sanity_check_failure:
            BuiltIn().skip("Skipping current test as sanity check failed.")
        else:
            logging.info(f"{self.__class__.__name__}: Sanity check succeeded, continuing with the test.")

    def _extract_parameters(self, data_set: Dict, parameter_names: List[str]) -&gt; List:
        try:
            parameters = []
            if data_set and parameter_names:
                for name in parameter_names:
                    if name in data_set:
                        parameters.append(data_set[name])
                    else:
                        logging.warning(f"{self.__class__.__name__}: Parameter {name} not found in data set")
            return parameters
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: PageObject: Error extracting parameters: {str(e)}")
            raise</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_table_verifier_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\table_verifier.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import logging
from selenium.webdriver.common.by import By
import re


class TableVerifier:
    def __init__(self, driver):
        self.driver = driver
        self.logger = logging.getLogger(__name__)

    def verify_table(self, table_element, expected_data, match_type='exact'):
        """
        Verify the entire table data.

        :param table_element: WebElement of the table
        :param expected_data: List of dictionaries, each representing a row
        :param match_type: Type of matching to perform ('exact', 'partial', 'regex')
        """
        try:
            rows = table_element.find_elements(By.TAG_NAME, "tr")
            headers = [header.text.strip().lower() for header in rows[0].find_elements(By.XPATH, ".//th | .//td")]

            for row_index, expected_row in enumerate(expected_data, start=1):
                if row_index &gt;= len(rows):
                    raise ValueError(f"Not enough rows in table. Expected at least {row_index}, but found {len(rows) - 1}")

                row = rows[row_index]
                cells = row.find_elements(By.XPATH, ".//td|.//th")

                for column, expected_value in expected_row.items():
                    cell_index = self._get_cell_index(headers, column)
                    if cell_index &gt;= len(cells):
                        raise ValueError(f"Column '{column}' is out of range. Row has {len(cells)} cells.")

                    actual_value = cells[cell_index].text.strip()
                    self._verify_cell_value(column, actual_value, expected_value, match_type)

            self.logger.info("All table data verified successfully.")
        except Exception as e:
            self.logger.error(f"Error verifying table data: {str(e)}")
            raise

    def verify_table_row(self, table_element, row_index, expected_data, match_type='exact'):
        """
        Verify the data in a specific row of a table.

        :param table_element: WebElement of the table
        :param row_index: Index of the row to verify (1-based index)
        :param expected_data: Dictionary of column name (or index) and expected value
        :param match_type: Type of matching to perform ('exact', 'partial', 'regex')
        """
        try:
            rows = table_element.find_elements(By.TAG_NAME, "tr")
            headers = [header.text.strip().lower() for header in rows[0].find_elements(By.XPATH, ".//th | .//td")]

            if row_index &lt; 1 or row_index &gt;= len(rows):
                raise ValueError(f"Invalid row index: {row_index}. Table has {len(rows) - 1} data rows.")

            row = rows[row_index]
            cells = row.find_elements(By.XPATH, ".//td|.//th")

            for column, expected_value in expected_data.items():
                cell_index = self._get_cell_index(headers, column)
                if cell_index &gt;= len(cells):
                    raise ValueError(f"Column '{column}' is out of range. Row has {len(cells)} cells.")

                actual_value = cells[cell_index].text.strip()
                self._verify_cell_value(column, actual_value, expected_value, match_type)

            self.logger.info(f"All expected data in row {row_index} verified successfully.")
        except Exception as e:
            self.logger.error(f"Error verifying table row data: {str(e)}")
            raise

    def verify_specific_cell(self, table_element, row_index, column, expected_value, match_type='exact'):
        """
        Verify the data in a specific cell of a table.

        :param table_element: WebElement of the table
        :param row_index: Index of the row to verify (1-based index)
        :param column: Column name or index (1-based if index)
        :param expected_value: Expected value of the cell
        :param match_type: Type of matching to perform ('exact', 'partial', 'regex')
        """
        try:
            rows = table_element.find_elements(By.TAG_NAME, "tr")
            headers = [header.text.strip().lower() for header in rows[0].find_elements(By.XPATH, ".//th | .//td")]

            if row_index &lt; 1 or row_index &gt;= len(rows):
                raise ValueError(f"Invalid row index: {row_index}. Table has {len(rows) - 1} data rows.")

            row = rows[row_index]
            cells = row.find_elements(By.XPATH, ".//td|.//th")

            cell_index = self._get_cell_index(headers, column)
            if cell_index &gt;= len(cells):
                raise ValueError(f"Column '{column}' is out of range. Row has {len(cells)} cells.")

            actual_value = cells[cell_index].text.strip()
            self._verify_cell_value(column, actual_value, expected_value, match_type)

            self.logger.info(f"Cell at row {row_index}, column '{column}' verified successfully.")
        except Exception as e:
            self.logger.error(f"Error verifying specific cell: {str(e)}")
            raise

    def _get_cell_index(self, headers, column):
        """
        Get the index of a cell based on column name or index.
        """
        if isinstance(column, int):
            return column - 1  # Convert to 0-based index

        column_lower = column.lower()
        for i, header in enumerate(headers):
            if header == column_lower:
                return i

        raise ValueError(f"Column '{column}' not found in table headers.")

    def _verify_cell_value(self, column, actual_value, expected_value, match_type):
        """
        Verify cell value based on the specified match type.
        """
        if match_type == 'exact':
            assert actual_value == expected_value, f"Mismatch in column '{column}'. Expected: {expected_value}, Actual: {actual_value}"
            self.logger.info(f"Verified column '{column}': expected: {expected_value}, actual: {actual_value}")
        elif match_type == 'partial':
            assert expected_value in actual_value, f"Value '{expected_value}' not found in column '{column}'. Actual: {actual_value}"
            self.logger.info(f"Verified column '{column}': partial match: {expected_value} in {actual_value}")
        elif match_type == 'regex':
            assert re.search(expected_value, actual_value), f"Regex '{expected_value}' did not match in column '{column}'. Actual: {actual_value}"
            self.logger.info(f"Verified column '{column}': regex match: {expected_value} in {actual_value}")
        else:
            raise ValueError(f"Invalid match_type: {match_type}")

        self.logger.info(f"Verified column '{column}': {actual_value}")

    def verify_table_is_empty(self, table_element):
        """
        Verify that the table contains no data rows.

        :param table_element: WebElement of the table
        """
        try:
            rows = table_element.find_elements(By.TAG_NAME, "tr")
            assert len(rows) == 1, f"Table is not empty. Found {len(rows) - 1} data rows."

            self.logger.info("Table is empty as expected.")
        except Exception as e:
            self.logger.error(f"Error verifying if table is empty: {str(e)}")
            raise

    def verify_unique_column_values(self, table_element, column):
        """
        Verify that all values in a specific column are unique.

        :param table_element: WebElement of the table
        :param column: Column name or index to verify uniqueness
        """
        try:
            rows = table_element.find_elements(By.TAG_NAME, "tr")
            headers = [header.text.strip().lower() for header in rows[0].find_elements(By.XPATH, ".//th | .//td")]

            column_index = self._get_cell_index(headers, column)
            values = set()

            for row in rows[1:]:  # Skip header row
                cells = row.find_elements(By.XPATH, ".//td|.//th")
                if column_index &lt; len(cells):
                    value = cells[column_index].text.strip()
                    assert value not in values, f"Duplicate value found in column '{column}': {value}"
                    values.add(value)

            self.logger.info(f"All values in column '{column}' are unique.")
        except Exception as e:
            self.logger.error(f"Error verifying unique values in column: {str(e)}")
            raise

    def verify_value_in_table(self, table_element, search_value):
        """
        Verify if a specific value exists in the table.

        :param table_element: WebElement of the table
        :param search_value: The value to search for in the table
        """
        try:
            rows = table_element.find_elements(By.TAG_NAME, "tr")

            for row in rows[1:]:  # Skip header row
                cells = row.find_elements(By.XPATH, ".//td|.//th")
                for cell in cells:
                    if search_value in cell.text.strip():
                        self.logger.info(f"Value '{search_value}' found in table.")
                        return True

            raise ValueError(f"Value '{search_value}' not found in the table.")
        except Exception as e:
            self.logger.error(f"Error verifying presence of value in table: {str(e)}")
            raise

    def verify_row_count(self, table_element, expected_row_count):
        """
        Verify the number of rows in the table (excluding the header row).

        :param table_element: WebElement of the table
        :param expected_row_count: The expected number of data rows
        """
        try:
            rows = table_element.find_elements(By.TAG_NAME, "tr")
            actual_row_count = len(rows) - 1  # Exclude header row

            assert actual_row_count == expected_row_count, \
                f"Row count mismatch. Expected: {expected_row_count}, Actual: {actual_row_count}"

            self.logger.info(f"Row count verified successfully: {actual_row_count}")
        except Exception as e:
            self.logger.error(f"Error verifying row count: {str(e)}")
            raise

    def verify_column_sorted(self, table_element, column, expected_order='ascending', strip_spaces=True):
        """
        Verify if a specific column in the table is sorted in the expected order.

        :param table_element: WebElement of the table
        :param column: Column name (or 1-based index) to verify sorting
        :param expected_order: Expected sorting order, either 'ascending' or 'descending' (default is 'ascending')
        :param strip_spaces: Boolean to determine whether to remove leading/trailing spaces from cell values (default is True)
        """
        try:
            # Retrieve all rows and headers of the table
            rows = table_element.find_elements(By.TAG_NAME, "tr")
            headers = [header.text.strip().lower() for header in rows[0].find_elements(By.XPATH, ".//th | .//td")]

            # Get the index of the target column
            column_index = self._get_cell_index(headers, column)

            # Collect all values from the target column (skipping the header row)
            column_data = []
            for row in rows[1:]:
                cells = row.find_elements(By.XPATH, ".//td|.//th")
                if column_index &lt; len(cells):
                    cell_text = cells[column_index].text.strip()
                    if strip_spaces:
                        cell_text = cell_text.strip()  # Optionally strip spaces
                    column_data.append(cell_text)
                else:
                    raise ValueError(f"Column '{column}' is out of range. This row has {len(cells)} columns.")

            # Sort the column data based on the expected order
            sorted_data = sorted(column_data)
            if expected_order == 'descending':
                sorted_data.reverse()

            # Validate if the column data is sorted as expected
            assert column_data == sorted_data, f"Column '{column}' is not sorted in {expected_order} order."

            self.logger.info(f"Column '{column}' is correctly sorted in {expected_order} order.")
        except Exception as e:
            self.logger.error(f"Error verifying sorting for column '{column}': {str(e)}")
            raise

    def select_table_row_checkbox(self, table_element, identifier_column, identifier_value, checkbox_column=1):
        """
        Select the checkbox in a specific row based on an identifier value in a specific column.

        :param table_element: WebElement of the table
        :param identifier_column: Column name or index (1-based if index) containing the identifier
        :param identifier_value: Value to identify the row
        :param checkbox_column: Column index (1-based) of the checkbox (default is 1, assuming checkbox is in the first column)
        """
        try:
            rows = table_element.find_elements(By.TAG_NAME, "tr")
            headers = [header.text.strip().lower() for header in rows[0].find_elements(By.XPATH, ".//th | .//td")]

            identifier_index = self._get_cell_index(headers, identifier_column)
            checkbox_index = checkbox_column - 1  # Convert to 0-based index

            for row in rows[1:]:  # Skip header row
                cells = row.find_elements(By.XPATH, ".//td|.//th")
                if identifier_index &lt; len(cells) and cells[identifier_index].text.strip() == identifier_value:
                    if checkbox_index &lt; len(cells):
                        checkbox = cells[checkbox_index].find_element(By.TAG_NAME, "input")
                        if checkbox.get_attribute("type") == "checkbox":
                            if not checkbox.is_selected():
                                checkbox.click()
                            self.logger.info(f"Checkbox selected for row with {identifier_column}: {identifier_value}")
                            return
                    else:
                        raise ValueError(
                            f"Checkbox column index {checkbox_column} is out of range. Row has {len(cells)} cells.")

            raise ValueError(f"No row found with {identifier_column}: {identifier_value}")

        except Exception as e:
            self.logger.error(f"Error selecting row checkbox: {str(e)}")
            raise

    def select_multiple_table_row_checkboxes(self, table_element, identifier_column, identifier_values, checkbox_column=1):
        """
        Select checkboxes in multiple rows based on identifier values in a specific column.

        :param table_element: WebElement of the table
        :param identifier_column: Column name or index (1-based if index) containing the identifier
        :param identifier_values: List of values to identify the rows
        :param checkbox_column: Column index (1-based) of the checkbox (default is 1, assuming checkbox is in the first column)
        """
        for identifier_value in identifier_values:
            self.select_table_row_checkbox(table_element, identifier_column, identifier_value, checkbox_column)

</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action___init___py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\web_action\__init__.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre></pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_alert_actions_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\web_action\alert_actions.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>from .base import Base
import logging

class AlertActions(Base):
    def accept_alert(self):
        logging.info(f"{self.__class__.__name__}: Accepting alert")
        self.driver.switch_to.alert.accept()
        logging.info(f"{self.__class__.__name__}: Alert accepted successfully")

    def dismiss_alert(self):
        logging.info(f"{self.__class__.__name__}: Dismissing alert")
        self.driver.switch_to.alert.dismiss()
        logging.info(f"{self.__class__.__name__}: Alert dismissed successfully")

    def get_alert_text(self):
        logging.info(f"{self.__class__.__name__}: Getting alert text")
        alert_text = self.driver.switch_to.alert.text
        logging.info(f"{self.__class__.__name__}: Alert text retrieved: '{alert_text}'")
        return alert_text</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_base_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\web_action\base.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import logging
from selenium.webdriver.remote.webdriver import WebDriver
from selenium.webdriver.remote.webelement import WebElement
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException


class Base:
    def __init__(self, driver: WebDriver, default_timeout: int = 60):
        self.driver = driver
        self.default_timeout = default_timeout


    def _get_element_description(self, element):
        if isinstance(element, WebElement):
            tag_name = element.tag_name
            element_id = element.get_attribute('id')
            element_class = element.get_attribute('class')
            element_name = element.get_attribute('name')
            element_text = element.text[:30] if element.text else ''

            description = f"&lt;{tag_name}"
            if element_id:
                description += f" id='{element_id}'"
            if element_class:
                classes = element_class.split()
                if len(classes) &gt; 2:
                    description += f" class='{' '.join(classes[:2])}...'"
                else:
                    description += f" class='{element_class}'"
            if element_name:
                description += f" name='{element_name}'"
            description += "&gt;"
            if element_text:
                description += f" text='{element_text}...'"

            return description
        elif isinstance(element, tuple):
            return f"locator: {element}"
        else:
            return str(element)

    def wait_for_element(self, locator, condition="presence", timeout=None):
        if timeout is None:
            timeout = self.default_timeout

        logging.info(
            f"{self.__class__.__name__}: Waiting for element with locator {locator}, condition: {condition}, timeout: {timeout}")
        wait = WebDriverWait(self.driver, timeout)

        try:
            if condition == "presence":
                result = wait.until(EC.presence_of_element_located(locator))
            elif condition == "visibility":
                result = wait.until(EC.visibility_of_element_located(locator))
            elif condition == "clickable":
                result = wait.until(EC.element_to_be_clickable(locator))
            elif condition == "invisibility":
                result = wait.until(EC.invisibility_of_element_located(locator))
            else:
                raise ValueError(f"{self.__class__.__name__}: Unsupported condition: {condition}")

            element_desc = self._get_element_description(result)
            logging.info(f"{self.__class__.__name__}: Element found successfully: {element_desc}")
            return result
        except TimeoutException:
            logging.error(f"{self.__class__.__name__}: Timeout waiting for element: {locator}, condition: {condition}")
            raise</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_basic_actions_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\web_action\basic_actions.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>from selenium.webdriver import ActionChains
from selenium.webdriver.support.select import Select
import logging
from .base import Base
from .decorators import wait_and_perform
from .js import fill_by_js_script, click_by_js_script


class BasicActions(Base):
    def open_url(self, url):
        logging.info(f"{self.__class__.__name__}: Opening URL: {url}")
        self.driver.maximize_window()
        self.driver.get(url)
        logging.info(f"{self.__class__.__name__}: URL opened successfully: {url}")

    @wait_and_perform(default_condition="presence")
    def send_keys(self, element, value):
        element_desc = self._get_element_description(element)
        logging.info(f"{self.__class__.__name__}: Sending keys to element: {element_desc}")
        logging.info(f"{self.__class__.__name__}: Value to be sent: {value}")
        element.send_keys(value)
        logging.info(f"{self.__class__.__name__}: Keys sent successfully to element: {element_desc}")

    @wait_and_perform(default_condition="presence")
    def fill_by_js(self, element, value):
        element_desc = self._get_element_description(element)
        logging.info(f"{self.__class__.__name__}: Sending keys to element: {element_desc}")
        logging.info(f"{self.__class__.__name__}: Value to be sent: {value}")
        js = fill_by_js_script.format(text=value)
        self.driver.execute_script(js, element)
        logging.info(f"{self.__class__.__name__}: Keys sent successfully to element: {element_desc} by js")

    @wait_and_perform(default_condition="clickable")
    def click(self, element):
        element_desc = self._get_element_description(element)
        logging.info(f"{self.__class__.__name__}: Clicking element: {element_desc}")
        element.click()
        logging.info(f"{self.__class__.__name__}: Element clicked successfully: {element_desc}")

    @wait_and_perform(default_condition="clickable")
    def click_by_js(self, element):
        element_desc = self._get_element_description(element)
        logging.info(f"{self.__class__.__name__}: Clicking element: {element_desc}")
        js = click_by_js_script
        self.driver.execute_script(js, element)
        logging.info(f"{self.__class__.__name__}: Element clicked successfully: {element_desc} by js")

    @wait_and_perform(default_condition="presence")
    def clear(self, element):
        element_desc = self._get_element_description(element)
        logging.info(f"{self.__class__.__name__}: Clearing element: {element_desc}")
        element.clear()
        logging.info(f"{self.__class__.__name__}: Element cleared successfully: {element_desc}")

    @wait_and_perform(default_condition="presence")
    def get_text(self, element):
        element_desc = self._get_element_description(element)
        logging.info(f"{self.__class__.__name__}: Getting text from element: {element_desc}")
        text = element.text
        logging.info(f"{self.__class__.__name__}: Text retrieved: '{text}' from element: {element_desc}")
        return text

    @wait_and_perform(default_condition="presence")
    def get_attribute(self, element, attribute_name):
        element_desc = self._get_element_description(element)
        logging.info(f"{self.__class__.__name__}: Getting attribute '{attribute_name}' from element: {element_desc}")
        attribute_value = element.get_attribute(attribute_name)
        logging.info(f"{self.__class__.__name__}: Attribute '{attribute_name}' value: '{attribute_value}' for element: {element_desc}")
        return attribute_value

    @wait_and_perform(default_condition="presence")
    def select_by_value(self, element, value):
        element_desc = self._get_element_description(element)
        logging.info(f"{self.__class__.__name__}: Selecting option by value: {value} for element: {element_desc}")
        Select(element).select_by_value(value)
        logging.info(f"{self.__class__.__name__}: Option selected successfully: {value} for element: {element_desc}")

    @wait_and_perform(default_condition="presence")
    def select_by_visible_text(self, element, text):
        element_desc = self._get_element_description(element)
        logging.info(f"{self.__class__.__name__}: Selecting option by visible text: {text} for element: {element_desc}")
        Select(element).select_by_visible_text(text)
        logging.info(f"{self.__class__.__name__}: Option selected successfully: {text} for element: {element_desc}")

    @wait_and_perform(default_condition="presence")
    def select_by_index(self, element, index):
        element_desc = self._get_element_description(element)
        logging.info(f"{self.__class__.__name__}: Selecting option by index: {index} for element: {element_desc}")
        Select(element).select_by_index(int(index))
        logging.info(
            f"{self.__class__.__name__}: Option selected successfully at index: {index} for element: {element_desc}")

    @wait_and_perform(default_condition="visibility")
    def hover(self, element):
        element_desc = self._get_element_description(element)
        logging.info(f"{self.__class__.__name__}: Hovering over element: {element_desc}")
        ActionChains(self.driver).move_to_element(element).perform()
        logging.info(f"{self.__class__.__name__}: Hovered over element successfully: {element_desc}")

    @wait_and_perform(default_condition="clickable")
    def double_click(self, element):
        element_desc = self._get_element_description(element)
        logging.info(f"{self.__class__.__name__}: Double clicking element: {element_desc}")
        ActionChains(self.driver).double_click(element).perform()
        logging.info(f"{self.__class__.__name__}: Double clicked element successfully: {element_desc}")

    @wait_and_perform(default_condition="clickable")
    def right_click(self, element):
        element_desc = self._get_element_description(element)
        logging.info(f"{self.__class__.__name__}: Right clicking element: {element_desc}")
        ActionChains(self.driver).context_click(element).perform()
        logging.info(f"{self.__class__.__name__}: Right clicked element successfully: {element_desc}")

    @wait_and_perform(default_condition="presence")
    def scroll_into_view(self, element):
        element_desc = self._get_element_description(element)
        logging.info(f"{self.__class__.__name__}: Scrolling element into view: {element_desc}")
        self.driver.execute_script("arguments[0].scrollIntoView(true);", element)
        logging.info(f"{self.__class__.__name__}: Scrolled element into view successfully: {element_desc}")

    @wait_and_perform(default_condition="presence")
    def scroll_to_element(self, element):
        element_desc = self._get_element_description(element)
        logging.info(f"{self.__class__.__name__}: Scrolling to element: {element_desc}")
        self.driver.execute_script(
            "arguments[0].scrollIntoView({behavior: 'smooth', block: 'center', inline: 'nearest'});", element)
        logging.info(f"{self.__class__.__name__}: Scrolled to element successfully: {element_desc}")

    @wait_and_perform(default_condition="presence")
    def get_text(self, element):
        element_desc = self._get_element_description(element)
        logging.info(f"{self.__class__.__name__}: Getting text from element: {element_desc}")
        text = element.text
        logging.info(f"{self.__class__.__name__}: Text retrieved: '{text}' from element: {element_desc}")
        return text

    @wait_and_perform(default_condition="presence")
    def get_attribute(self, element, attribute_name):
        element_desc = self._get_element_description(element)
        logging.info(f"{self.__class__.__name__}: Getting attribute '{attribute_name}' from element: {element_desc}")
        attribute_value = element.get_attribute(attribute_name)
        logging.info(f"{self.__class__.__name__}: Attribute '{attribute_name}' value: '{attribute_value}' for element: {element_desc}")
        return attribute_value

    @wait_and_perform(default_condition="clickable")
    def select_radio(self, element):
        element.click()

    def select_radio_by_value(self, element, value):
        logging.info(f"{self.__class__.__name__}: Selecting radio button with value '{value}' in radio group: {element}")
        locator_type, locator = element
        locator = locator.format(value)
        element = (locator_type, locator)
        self.select_radio(element)
        logging.info(f"{self.__class__.__name__}: Selected radio button with value '{value}'")
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_browser_actions_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\web_action\browser_actions.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>from .base import Base
import logging

class BrowserActions(Base):
    def refresh_page(self):
        logging.info(f"{self.__class__.__name__}: Refreshing the current page")
        self.driver.refresh()
        logging.info(f"{self.__class__.__name__}: Page refreshed successfully")

    def go_back(self):
        logging.info(f"{self.__class__.__name__}: Navigating back in browser history")
        self.driver.back()
        logging.info(f"{self.__class__.__name__}: Navigated back successfully")

    def go_forward(self):
        logging.info(f"{self.__class__.__name__}: Navigating forward in browser history")
        self.driver.forward()
        logging.info(f"{self.__class__.__name__}: Navigated forward successfully")

    def get_current_url(self):
        logging.info(f"{self.__class__.__name__}: Getting current URL")
        url = self.driver.current_url
        logging.info(f"{self.__class__.__name__}: Current URL is: '{url}'")
        return url

    def set_window_size(self, width, height):
        logging.info(f"{self.__class__.__name__}: Setting window size to {width}x{height}")
        self.driver.set_window_size(width, height)
        logging.info(f"{self.__class__.__name__}: Window size set successfully")

    def maximize_window(self):
        logging.info(f"{self.__class__.__name__}: Maximizing window")
        self.driver.maximize_window()
        logging.info(f"{self.__class__.__name__}: Window maximized successfully")

    def minimize_window(self):
        logging.info(f"{self.__class__.__name__}: Minimizing window")
        self.driver.minimize_window()
        logging.info(f"{self.__class__.__name__}: Window minimized successfully")

    def fullscreen_window(self):
        logging.info(f"{self.__class__.__name__}: Setting window to full screen")
        self.driver.fullscreen_window()
        logging.info(f"{self.__class__.__name__}: Window set to full screen successfully")</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_cookie_actions_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\web_action\cookie_actions.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>from .base import Base
import logging

class CookieActions(Base):
    def add_cookie(self, cookie_dict):
        logging.info(f"{self.__class__.__name__}: Adding cookie: {cookie_dict}")
        self.driver.add_cookie(cookie_dict)
        logging.info(f"{self.__class__.__name__}: Cookie added successfully")

    def get_cookie(self, name):
        logging.info(f"{self.__class__.__name__}: Getting cookie with name: '{name}'")
        cookie = self.driver.get_cookie(name)
        logging.info(f"{self.__class__.__name__}: Cookie retrieved: {cookie}")
        return cookie

    def delete_cookie(self, name):
        logging.info(f"{self.__class__.__name__}: Deleting cookie with name: '{name}'")
        self.driver.delete_cookie(name)
        logging.info(f"{self.__class__.__name__}: Cookie deleted successfully")

    def delete_all_cookies(self):
        logging.info(f"{self.__class__.__name__}: Deleting all cookies")
        self.driver.delete_all_cookies()
        logging.info(f"{self.__class__.__name__}: All cookies deleted successfully")</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_decorators_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\web_action\decorators.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import time
from functools import wraps


def wait_and_perform(default_condition="presence"):
    def decorator(func):
        @wraps(func)
        def wrapper(self, locator, *args, condition=None, **kwargs):
            used_condition = condition or default_condition
            if isinstance(locator, tuple):
                element = self.wait_for_element(locator, condition=used_condition)
            else:
                element = locator
            return func(self, element, *args, **kwargs)
        return wrapper
    return decorator


def timer(func):
    """计算方法执行时间的装饰器"""
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f'Function {func.__name__} execution time: {end - start} seconds')
        return result

    return wrapper</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_frame_window_actions_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\web_action\frame_window_actions.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>from .base import Base
from .decorators import wait_and_perform
import logging

class FrameWindowActions(Base):
    @wait_and_perform(default_condition="presence")
    def switch_to_frame(self, element):
        element_desc = self._get_element_description(element)
        logging.info(f"{self.__class__.__name__}: Switching to frame: {element_desc}")
        self.driver.switch_to.frame(element)
        logging.info(f"{self.__class__.__name__}: Switched to frame successfully: {element_desc}")

    def switch_to_default_content(self):
        logging.info(f"{self.__class__.__name__}: Switching to default content")
        self.driver.switch_to.default_content()
        logging.info(f"{self.__class__.__name__}: Switched to default content successfully")

    def switch_to_window(self, window_handle):
        logging.info(f"{self.__class__.__name__}: Switching to window with handle: {window_handle}")
        self.driver.switch_to.window(window_handle)
        logging.info(f"{self.__class__.__name__}: Switched to window successfully")

    def get_window_handles(self):
        logging.info(f"{self.__class__.__name__}: Getting all window handles")
        handles = self.driver.window_handles
        logging.info(f"{self.__class__.__name__}: Retrieved {len(handles)} window handles")
        return handles

    def close_current_window(self):
        logging.info(f"{self.__class__.__name__}: Closing current window")
        self.driver.close()
        logging.info(f"{self.__class__.__name__}: Current window closed successfully")</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_javascript_actions_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\web_action\javascript_actions.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>from .base import Base
from .decorators import wait_and_perform
import logging

class JavaScriptActions(Base):
    def execute_script(self, script, *args):
        logging.info(f"{self.__class__.__name__}: Executing JavaScript: {script}, Arguments: {args}")
        result = self.driver.execute_script(script, *args)
        logging.info(f"{self.__class__.__name__}: JavaScript executed successfully, Result: {result}")
        return result

    def execute_async_script(self, script, *args):
        logging.info(f"{self.__class__.__name__}: Executing asynchronous JavaScript: {script}, Arguments: {args}")
        result = self.driver.execute_async_script(script, *args)
        logging.info(f"{self.__class__.__name__}: Asynchronous JavaScript executed successfully, Result: {result}")
        return result

    @wait_and_perform(default_condition="clickable")
    def js_click(self, element):
        element_desc = self._get_element_description(element)
        logging.info(f"{self.__class__.__name__}: Clicking element using JavaScript: {element_desc}")
        self.driver.execute_script("arguments[0].click();", element)
        logging.info(f"{self.__class__.__name__}: Element clicked successfully using JavaScript: {element_desc}")

    @wait_and_perform(default_condition="presence")
    def js_send_keys(self, element, value):
        element_desc = self._get_element_description(element)
        logging.info(f"{self.__class__.__name__}: Sending keys to element using JavaScript: {element_desc}")
        self.driver.execute_script(f"arguments[0].value = '{value}';", element)
        logging.info(f"{self.__class__.__name__}: Keys sent successfully using JavaScript: {element_desc}")

    @wait_and_perform(default_condition="presence")
    def js_clear(self, element):
        element_desc = self._get_element_description(element)
        logging.info(f"{self.__class__.__name__}: Clearing element using JavaScript: {element_desc}")
        self.driver.execute_script("arguments[0].value = '';", element)
        logging.info(f"{self.__class__.__name__}: Element cleared successfully using JavaScript: {element_desc}")

    @wait_and_perform(default_condition="presence")
    def js_scroll_into_view(self, element):
        element_desc = self._get_element_description(element)
        logging.info(f"{self.__class__.__name__}: Scrolling element into view using JavaScript: {element_desc}")
        self.driver.execute_script("arguments[0].scrollIntoView(true);", element)
        logging.info(f"{self.__class__.__name__}: Element scrolled into view successfully using JavaScript: {element_desc}")

    @wait_and_perform(default_condition="presence")
    def js_select_option(self, select_element, option_text):
        element_desc = self._get_element_description(select_element)
        logging.info(f"{self.__class__.__name__}: Selecting option '{option_text}' using JavaScript: {element_desc}")
        self.driver.execute_script(
            "var select = arguments[0];"
            "for(var i = 0; i &lt; select.options.length; i++) {"
            "  if(select.options[i].text == arguments[1]) {"
            "    select.options[i].selected = true;"
            "    var event = new Event('change', { bubbles: true });"
            "    select.dispatchEvent(event);"
            "    break;"
            "  }"
            "}", select_element, option_text
        )
        logging.info(f"{self.__class__.__name__}: Option selected successfully using JavaScript: {element_desc}")

    @wait_and_perform(default_condition="visibility")
    def js_hover(self, element):
        element_desc = self._get_element_description(element)
        logging.info(f"{self.__class__.__name__}: Hovering over element using JavaScript: {element_desc}")
        self.driver.execute_script(
            "var event = new MouseEvent('mouseover', {"
            "  'view': window,"
            "  'bubbles': true,"
            "  'cancelable': true"
            "});"
            "arguments[0].dispatchEvent(event);", element
        )
        logging.info(f"{self.__class__.__name__}: Hovered over element successfully using JavaScript: {element_desc}")
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_js_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\web_action\js.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>fill_by_js_script = '''
    function setNativeValue(element,value) {{
        const {{
            set: valueSetter
        }} = Object.getOwnPropertyDescriptor(element,'value') || {{}};
        const prototype = Object.getPrototypeOf(element);
        const {{
            set: prototypeValueSetter
        }} = Object.getOwnPropertyDescriptor(prototype,'value') || {{}};

        if (prototypeValueSetter &amp;&amp; valueSetter !== prototypeValueSetter) {{
            prototypeValueSetter.call(element,value);
        }}

        else if (valueSetter) {{
            valueSetter.call(element,value);
        }} else {{
            throw new Error('The given element does not have a value setter');
        }}
    }}
    function fireEvent(element,value) {{
    setNativeValue(element,value);
    element.dispatchEvent(new Event('change',{{bubbles: true}}));
    }}
    fireEvent(arguments[0], '{text}')
'''

click_by_js_script = '''
    function clickByJsFireEvent(element) {
        // Check if the element is not null and is an instance of HTMLElement
        if (element instanceof HTMLElement) {
            element.click(); // Programmatically click the element
            element.dispatchEvent(new Event('click', { bubbles: true })); // Dispatch the click event, making it bubble up
        } else {
            throw new Error('The given element is not a valid HTML element');
        }
    }
    clickByJsFireEvent(arguments[0]);
'''
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_screenshot_actions_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\web_action\screenshot_actions.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import base64
import datetime
import io
import logging
import time

from PIL import Image
from robot.libraries.BuiltIn import BuiltIn

from .base import Base
from .decorators import wait_and_perform


class ScreenshotActions(Base):
    def capture_screenshot(self):
        try:
            if self.driver:
                screenshot_binary = self.driver.get_screenshot_as_png()
                image = Image.open(io.BytesIO(screenshot_binary))
                base_width = 1440
                w_percent = (base_width / float(image.size[0]))
                h_size = int((float(image.size[1]) * float(w_percent)))
                image = image.resize((base_width, h_size), Image.LANCZOS)
                buffer = io.BytesIO()
                image.save(buffer, format="WebP", quality=30)
                encoded_string = base64.b64encode(buffer.getvalue()).decode('utf-8')
                logging.info(
                    f"{self.__class__.__name__}: Screenshot captured successfully at: " + str(datetime.datetime.now()))
                BuiltIn().log(f'&lt;img src="data:image/webp;base64,{encoded_string}" width="1440px"&gt;', html=True)
            else:
                logging.error(f"{self.__class__.__name__}: WebDriver is not initialized.")
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Failed to capture screenshot: {str(e)}")
            BuiltIn().log(f"{self.__class__.__name__}: Failed to capture screenshot: {str(e)}", level="ERROR")

    @wait_and_perform(default_condition="visibility")
    def highlight_element(self, element, duration=2, color="lightgreen", border="3px solid red"):
        element_desc = self._get_element_description(element)
        logging.info(f"{self.__class__.__name__}: Highlighting element: {element_desc}")

        def apply_style(s):
            self.driver.execute_script("arguments[0].setAttribute('style', arguments[1]);", element, s)

        original_style = element.get_attribute('style')

        for _ in range(int(duration)):
            apply_style(f"background: {color}; border: {border};")
            time.sleep(0.25)
            apply_style(original_style)
            time.sleep(0.25)

        logging.info(f"{self.__class__.__name__}: Finished highlighting element: {element_desc}")</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_table_actions_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\web_action\table_actions.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>from .base import Base
from typing import Union, List, Dict
from selenium.webdriver.remote.webelement import WebElement
import logging

class TableActions(Base):
    def verify_table_exact(self, table_locator: Union[tuple, WebElement], expected_data: List[Dict[str, str]]):
        logging.info(f"{self.__class__.__name__}: Verifying entire table with exact match")
        table_element = self.wait_for_element(table_locator) if isinstance(table_locator, tuple) else table_locator
        table_desc = self._get_element_description(table_element)
        self.table_verifier.verify_table(table_element, expected_data, match_type='exact')
        logging.info(f"{self.__class__.__name__}: Table verification (exact match) completed for table: {table_desc}")

    def verify_table_row_exact(self, table_locator: Union[tuple, WebElement], row_index: int, expected_data: Dict[str, str]):
        logging.info(f"{self.__class__.__name__}: Verifying table row at index {row_index} with exact match")
        table_element = self.wait_for_element(table_locator) if isinstance(table_locator, tuple) else table_locator
        table_desc = self._get_element_description(table_element)
        self.table_verifier.verify_table_row(table_element, row_index, expected_data, match_type='exact')
        logging.info(f"{self.__class__.__name__}: Table row verification (exact match) completed for table: {table_desc}, row: {row_index}")

    def verify_specific_cell_exact(self, table_locator: Union[tuple, WebElement], row_index: int, column: Union[str, int], expected_value: str):
        logging.info(f"{self.__class__.__name__}: Verifying specific cell at row {row_index}, column {column} with exact match")
        table_element = self.wait_for_element(table_locator) if isinstance(table_locator, tuple) else table_locator
        table_desc = self._get_element_description(table_element)
        self.table_verifier.verify_specific_cell(table_element, row_index, column, expected_value, match_type='exact')
        logging.info(f"{self.__class__.__name__}: Specific cell verification (exact match) completed for table: {table_desc}, row: {row_index}, column: {column}")

    def verify_table_partial(self, table_locator: Union[tuple, WebElement], expected_data: List[Dict[str, str]]):
        logging.info(f"{self.__class__.__name__}: Verifying entire table with partial match")
        table_element = self.wait_for_element(table_locator) if isinstance(table_locator, tuple) else table_locator
        table_desc = self._get_element_description(table_element)
        self.table_verifier.verify_table(table_element, expected_data, match_type='partial')
        logging.info(f"{self.__class__.__name__}: Table verification (partial match) completed for table: {table_desc}")

    def verify_table_row_partial(self, table_locator: Union[tuple, WebElement], row_index: int, expected_data: Dict[str, str]):
        logging.info(f"{self.__class__.__name__}: Verifying table row at index {row_index} with partial match")
        table_element = self.wait_for_element(table_locator) if isinstance(table_locator, tuple) else table_locator
        table_desc = self._get_element_description(table_element)
        self.table_verifier.verify_table_row(table_element, row_index, expected_data, match_type='partial')
        logging.info(f"{self.__class__.__name__}: Table row verification (partial match) completed for table: {table_desc}, row: {row_index}")

    def verify_specific_cell_partial(self, table_locator: Union[tuple, WebElement], row_index: int, column: Union[str, int], expected_value: str):
        logging.info(f"{self.__class__.__name__}: Verifying specific cell at row {row_index}, column {column} with partial match")
        table_element = self.wait_for_element(table_locator) if isinstance(table_locator, tuple) else table_locator
        table_desc = self._get_element_description(table_element)
        self.table_verifier.verify_specific_cell(table_element, row_index, column, expected_value, match_type='partial')
        logging.info(f"{self.__class__.__name__}: Specific cell verification (partial match) completed for table: {table_desc}, row: {row_index}, column: {column}")

    def verify_table_regex(self, table_locator: Union[tuple, WebElement], expected_data: List[Dict[str, str]]):
        logging.info(f"{self.__class__.__name__}: Verifying entire table with regex match")
        table_element = self.wait_for_element(table_locator) if isinstance(table_locator, tuple) else table_locator
        table_desc = self._get_element_description(table_element)
        self.table_verifier.verify_table(table_element, expected_data, match_type='regex')
        logging.info(f"{self.__class__.__name__}: Table verification (regex match) completed for table: {table_desc}")

    def verify_table_row_regex(self, table_locator: Union[tuple, WebElement], row_index: int, expected_data: Dict[str, str]):
        logging.info(f"{self.__class__.__name__}: Verifying table row at index {row_index} with regex match")
        table_element = self.wait_for_element(table_locator) if isinstance(table_locator, tuple) else table_locator
        table_desc = self._get_element_description(table_element)
        self.table_verifier.verify_table_row(table_element, row_index, expected_data, match_type='regex')
        logging.info(f"{self.__class__.__name__}: Table row verification (regex match) completed for table: {table_desc}, row: {row_index}")

    def verify_specific_cell_regex(self, table_locator: Union[tuple, WebElement], row_index: int, column: Union[str, int], expected_value: str):
        logging.info(f"{self.__class__.__name__}: Verifying specific cell at row {row_index}, column {column} with regex match")
        table_element = self.wait_for_element(table_locator) if isinstance(table_locator, tuple) else table_locator
        table_desc = self._get_element_description(table_element)
        self.table_verifier.verify_specific_cell(table_element, row_index, column, expected_value, match_type='regex')
        logging.info(f"{self.__class__.__name__}: Specific cell verification (regex match) completed for table: {table_desc}, row: {row_index}, column: {column}")

    def verify_table_is_empty(self, table_locator: Union[tuple, WebElement]):
        logging.info(f"{self.__class__.__name__}: Verifying table is empty")
        try:
            table_element = self.wait_for_element(table_locator) if isinstance(table_locator, tuple) else table_locator
            table_desc = self._get_element_description(table_element)
            self.table_verifier.verify_table_is_empty(table_element)
            logging.info(f"{self.__class__.__name__}: Table empty verification completed successfully for table: {table_desc}")
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error verifying table is empty: {str(e)}")
            raise

    def verify_unique_column_values(self, table_locator: Union[tuple, WebElement], column: Union[str, int]):
        logging.info(f"{self.__class__.__name__}: Verifying unique values in column: {column}")
        try:
            table_element = self.wait_for_element(table_locator) if isinstance(table_locator, tuple) else table_locator
            table_desc = self._get_element_description(table_element)
            self.table_verifier.verify_unique_column_values(table_element, column)
            logging.info(f"{self.__class__.__name__}: Unique column values verification completed successfully for table: {table_desc}, column: {column}")
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error verifying unique column values: {str(e)}")
            raise

    def verify_value_in_table(self, table_locator: Union[tuple, WebElement], search_value: str):
        logging.info(f"{self.__class__.__name__}: Verifying value '{search_value}' exists in table")
        try:
            table_element = self.wait_for_element(table_locator) if isinstance(table_locator, tuple) else table_locator
            table_desc = self._get_element_description(table_element)
            result = self.table_verifier.verify_value_in_table(table_element, search_value)
            logging.info(f"{self.__class__.__name__}: Value verification in table completed successfully for table: {table_desc}")
            return result
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error verifying value in table: {str(e)}")
            raise

    def verify_row_count(self, table_locator: Union[tuple, WebElement], expected_row_count: int):
        logging.info(f"{self.__class__.__name__}: Verifying row count: expected {expected_row_count}")
        try:
            table_element = self.wait_for_element(table_locator) if isinstance(table_locator, tuple) else table_locator
            table_desc = self._get_element_description(table_element)
            self.table_verifier.verify_row_count(table_element, expected_row_count)
            logging.info(f"{self.__class__.__name__}: Row count verification completed successfully for table: {table_desc}")
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error verifying row count: {str(e)}")
            raise

    def verify_column_sorted(self, table_locator: Union[tuple, WebElement], column: Union[str, int], expected_order='ascending', strip_spaces=True):
        logging.info(f"{self.__class__.__name__}: Verifying column '{column}' is sorted in {expected_order} order")
        try:
            table_element = self.wait_for_element(table_locator) if isinstance(table_locator, tuple) else table_locator
            table_desc = self._get_element_description(table_element)
            self.table_verifier.verify_column_sorted(table_element, column, expected_order, strip_spaces)
            logging.info(f"{self.__class__.__name__}: Column sorting verification completed successfully for table: {table_desc}, column: {column}")
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error verifying column sorting: {str(e)}")
            raise

    def select_table_row_checkbox(self, table_locator: Union[tuple, WebElement], identifier_column: Union[str, int], identifier_value: str, checkbox_column: int = 1):
        logging.info(f"{self.__class__.__name__}: Selecting checkbox for row with {identifier_column}: {identifier_value}")
        try:
            table_element = self.wait_for_element(table_locator) if isinstance(table_locator, tuple) else table_locator
            table_desc = self._get_element_description(table_element)
            self.table_verifier.select_table_row_checkbox(table_element, identifier_column, identifier_value, checkbox_column)
            logging.info(f"{self.__class__.__name__}: Checkbox selected successfully for row with {identifier_column}: {identifier_value} in table: {table_desc}")
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error selecting checkbox: {str(e)}")
            raise

    def select_multiple_table_row_checkboxes(self, table_locator: Union[tuple, WebElement], identifier_column: Union[str, int], identifier_values: List[str], checkbox_column: int = 1):
        logging.info(f"{self.__class__.__name__}: Selecting checkboxes for multiple rows with {identifier_column}: {identifier_values}")
        try:
            table_element = self.wait_for_element(table_locator) if isinstance(table_locator, tuple) else table_locator
            table_desc = self._get_element_description(table_element)
            self.table_verifier.select_multiple_table_row_checkboxes(table_element, identifier_column, identifier_values, checkbox_column)
            logging.info(f"{self.__class__.__name__}: Checkboxes selected successfully for rows with {identifier_column}: {identifier_values} in table: {table_desc}")
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error selecting multiple checkboxes: {str(e)}")
            raise</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_verification_actions_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\web_action\verification_actions.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>from numpy import around
from selenium.common import NoSuchElementException, TimeoutException

from .base import Base
from .decorators import wait_and_perform
import logging

class VerificationActions(Base):
    @wait_and_perform(default_condition="presence")
    def element_text_should_be(self, element, expected_text):
        element_desc = self._get_element_description(element)
        logging.info(f"{self.__class__.__name__}: Checking if element text matches expected: {element_desc}, expected text: '{expected_text}'")
        actual_text = element.text
        assert actual_text == expected_text, f"{self.__class__.__name__}: Expected text: '{expected_text}' is not matching actual text: '{actual_text}'"
        logging.info(f"{self.__class__.__name__}: Element text matches expected: '{expected_text}', Actual text: '{actual_text}'")

    @wait_and_perform(default_condition="presence")
    def element_text_should_contains(self, element, expected_text):
        element_desc = self._get_element_description(element)
        logging.info(f"{self.__class__.__name__}: Checking if element text contains expected: {element_desc}, expected text: '{expected_text}'")
        actual_text = element.text
        assert expected_text in actual_text, f"{self.__class__.__name__}: Expected text: '{expected_text}' is not in actual text: '{actual_text}'"
        logging.info(f"{self.__class__.__name__}: Element text contains expected: '{expected_text}', Actual text: '{actual_text}'")

    def title_should_be(self, expected_title):
        logging.info(f"{self.__class__.__name__}: Checking if page title matches expected: '{expected_title}'")
        actual_title = self.driver.title
        assert actual_title == expected_title, f"{self.__class__.__name__}: Expected title: '{expected_title}' is not matching actual title: '{actual_title}'"
        logging.info(f"{self.__class__.__name__}: Title matches expected: '{expected_title}', Actual title: '{actual_title}'")

    def title_should_contains(self, expected_title):
        logging.info(f"{self.__class__.__name__}: Checking if page title contains expected: '{expected_title}'")
        actual_title = self.driver.title
        assert expected_title in actual_title, f"{self.__class__.__name__}: Expected title: '{expected_title}' is not in actual title: '{actual_title}'"
        logging.info(f"{self.__class__.__name__}: Title contains expected: '{expected_title}', Actual title: '{actual_title}'")


    def is_element_present(self, locator):
        logging.info(f"{self.__class__.__name__}: Checking if element is present: {locator}")
        try:
            element = self.driver.find_element(*locator)
            element_desc = self._get_element_description(element)
            logging.info(f"{self.__class__.__name__}: Element is present: {element_desc}")
            return True
        except NoSuchElementException:
            logging.info(f"{self.__class__.__name__}: Element is not present: {locator}")
            return False

    def is_element_visible(self, locator, timeout=None):
        logging.info(f"{self.__class__.__name__}: Checking if element is visible: {locator}, timeout: {timeout}")
        try:
            element = self.wait_for_element(locator, condition="visibility", timeout=timeout)
            element_desc = self._get_element_description(element)
            logging.info(f"{self.__class__.__name__}: Element is visible: {element_desc}")
            return True
        except TimeoutException:
            logging.info(f"{self.__class__.__name__}: Element is not visible: {locator}")
            return False

    def is_element_clickable(self, locator, timeout=None):
        logging.info(f"{self.__class__.__name__}: Checking if element is clickable: {locator}, timeout: {timeout}")
        try:
            element = self.wait_for_element(locator, condition="clickable", timeout=timeout)
            element_desc = self._get_element_description(element)
            logging.info(f"{self.__class__.__name__}: Element is clickable: {element_desc}")
            return True
        except TimeoutException:
            logging.info(f"{self.__class__.__name__}: Element is not clickable: {locator}")
            return False

    @wait_and_perform(default_condition="presence")
    def is_element_selected(self, element):
        element_desc = self._get_element_description(element)
        logging.info(f"{self.__class__.__name__}: Checking if element is selected: {element_desc}")
        is_selected = element.is_selected()
        logging.info(f"{self.__class__.__name__}: Element selected status: {is_selected} for element: {element_desc}")
        return is_selected

    @wait_and_perform(default_condition="presence")
    def is_element_enabled(self, element):
        element_desc = self._get_element_description(element)
        logging.info(f"{self.__class__.__name__}: Checking if element is enabled: {element_desc}")
        is_enabled = element.is_enabled()
        logging.info(f"{self.__class__.__name__}: Element enabled status: {is_enabled} for element: {element_desc}")
        return is_enabled


    @wait_and_perform(default_condition="presence")
    def capture_element_value(self, element, variable_name):
        element_desc = self._get_element_description(element)
        logging.info(f"{self.__class__.__name__}: Capturing value from element: {element_desc}")
        value = self.get_text(element)
        self.builtin.set_global_variable(f"${{{variable_name}}}", value)
        logging.info(f"{self.__class__.__name__}: Saved value '{value}' to variable ${{{variable_name}}}")
        return value

    @wait_and_perform(default_condition="presence")
    def assert_value_change(self, element, initial_value_variable, expected_change):
        element_desc = self._get_element_description(element)
        logging.info(f"{self.__class__.__name__}: Asserting value change for element: {element_desc}")

        initial_value = float(self.builtin.get_variable_value(f"${{{initial_value_variable}}}"))
        current_value = float(self.get_text(element))
        actual_change = around(current_value - initial_value, 2)
        expected_change = float(expected_change)

        logging.info(f"{self.__class__.__name__}: Actual diff: {actual_change}, Expected diff: {expected_change}")

        if not self._compare_diff(actual_change, expected_change):
            raise AssertionError(f"{self.__class__.__name__}: Dynamic check failed for element: {element_desc}")
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_wait_actions_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\web_action\wait_actions.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>from .base import Base
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException
import logging
import time

class WaitActions(Base):
    def wait_for_element_present(self, locator, timeout=None):
        logging.info(f"{self.__class__.__name__}: Waiting for element to be present: {locator}")
        return self.wait_for_element(locator, condition="presence", timeout=timeout)

    def wait_for_element_visible(self, locator, timeout=None):
        logging.info(f"{self.__class__.__name__}: Waiting for element to be visible: {locator}")
        return self.wait_for_element(locator, condition="visibility", timeout=timeout)

    def wait_for_element_clickable(self, locator, timeout=None):
        logging.info(f"{self.__class__.__name__}: Waiting for element to be clickable: {locator}")
        return self.wait_for_element(locator, condition="clickable", timeout=timeout)

    def wait_for_text_present_in_element(self, locator, text, timeout=None):
        if timeout is None:
            timeout = self.default_timeout
        logging.info(f"{self.__class__.__name__}: Waiting for text '{text}' to be present in element: {locator}")
        try:
            wait = WebDriverWait(self.driver, timeout)
            element = wait.until(EC.text_to_be_present_in_element(locator, text))
            element_desc = self._get_element_description(element)
            logging.info(f"{self.__class__.__name__}: Text '{text}' is present in element: {element_desc}")
            return element
        except TimeoutException:
            logging.error(f"{self.__class__.__name__}: Text '{text}' not present in element: {locator}")
            raise

    def wait_for_element_to_disappear(self, locator, timeout=None):
        if timeout is None:
            timeout = self.default_timeout
        logging.info(f"{self.__class__.__name__}: Waiting for element to disappear: {locator}, timeout: {timeout}")
        try:
            self.wait_for_element(locator, condition="invisibility", timeout=timeout)
            logging.info(f"{self.__class__.__name__}: Element disappeared: {locator}")
            return True
        except TimeoutException:
            logging.warning(f"{self.__class__.__name__}: Element did not disappear: {locator} after {timeout} seconds")
            return False

    def wait_for_staleness_of(self, element, timeout=None):
        if timeout is None:
            timeout = self.default_timeout
        element_desc = self._get_element_description(element)
        logging.info(f"{self.__class__.__name__}: Waiting for staleness of element: {element_desc}")
        try:
            wait = WebDriverWait(self.driver, timeout)
            wait.until(EC.staleness_of(element))
            logging.info(f"{self.__class__.__name__}: Element is stale: {element_desc}")
            return True
        except TimeoutException:
            logging.error(f"{self.__class__.__name__}: Element not stale: {element_desc}")
            return False

    def wait(self, seconds):
        logging.info(f"{self.__class__.__name__}: Waiting for {seconds} seconds")
        time.sleep(int(seconds))</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_actions_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\web_actions.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>from libraries.web.web_action.alert_actions import AlertActions
from libraries.web.web_action.basic_actions import BasicActions
from libraries.web.web_action.browser_actions import BrowserActions
from libraries.web.web_action.cookie_actions import CookieActions
from libraries.web.web_action.frame_window_actions import FrameWindowActions
from libraries.web.web_action.javascript_actions import JavaScriptActions
from libraries.web.web_action.screenshot_actions import ScreenshotActions
from libraries.web.web_action.table_actions import TableActions
from libraries.web.web_action.verification_actions import VerificationActions
from libraries.web.web_action.wait_actions import WaitActions


class WebElementActions(
                        BasicActions,
                        VerificationActions,
                        WaitActions,
                        FrameWindowActions,
                        JavaScriptActions,
                        TableActions,
                        BrowserActions,
                        CookieActions,
                        AlertActions,
                        ScreenshotActions):
    pass
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_robot_generator_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\web_robot_generator.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import logging
import os
from typing import Dict, List
import pandas as pd
from robot.api import TestSuite
from libraries.common.config_manager import ConfigManager
from libraries.common.utility_helpers import PROJECT_ROOT
from libraries.web.web_test_loader import WebTestLoader

class WebUIRobotCasesGenerator:
    def __init__(self, test_config_path: str = None, test_cases_path: str = None):
        self.project_root: str = PROJECT_ROOT
        self.test_config_path: str = test_config_path
        self.test_cases_path: str = test_cases_path

        try:
            self._load_configuration()
            self._initialize_components()
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Initialization failed: {str(e)}")
            raise RuntimeError(f"{self.__class__.__name__}: Initialization failed: {str(e)}")

    def _load_configuration(self):
        try:
            self.test_config_path = (
                os.path.join(self.project_root, 'configs', 'web_test_config.yaml')
                if self.test_config_path is None
                else self.test_config_path
            )
            self.test_config: Dict = ConfigManager.load_yaml(self.test_config_path)
        except FileNotFoundError:
            logging.error(f"{self.__class__.__name__}: Config file not found at {self.test_config_path}")
            raise
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error loading configuration: {str(e)}")
            raise

    def _initialize_components(self):
        try:
            default_test_cases_path: str = os.path.join('test_cases', 'web_test_cases.xlsx')
            self.test_cases_path: str = (
                os.path.join(self.project_root, self.test_config.get('test_cases_path', default_test_cases_path))
                if self.test_cases_path is None
                else self.test_cases_path
            )

            if not os.path.exists(self.test_cases_path):
                logging.error(f"{self.__class__.__name__}: Test cases file not found at {self.test_cases_path}")
                raise FileNotFoundError(f"Test cases file does not exist: {self.test_cases_path}")

            self.web_test_loader = WebTestLoader(self.test_cases_path, self.test_config)
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error initializing components: {str(e)}")
            raise

    def create_test_suite(self, tc_id_list: List[str] = None, tags: List[str] = None) -&gt; TestSuite:
        try:
            # Create main test suite
            self.robot_suite = TestSuite('Web UI TestSuite')
            self._import_required_libraries()

            # Filter test cases
            tc_id_list = tc_id_list or self.test_config.get('tc_id_list', [])
            tags = tags or self.test_config.get('tags', [])
            test_cases = self.web_test_loader.filter_cases(tc_id_list, tags)

            if test_cases.empty:
                logging.warning(f"{self.__class__.__name__}: No test cases found matching criteria")
                return self.robot_suite

            # Create test cases
            for _, test_case in test_cases.iterrows():
                self.create_test_case(test_case)

            # Configure suite teardown
            self.robot_suite.teardown.config(name='close_browser', args=[])
            return self.robot_suite
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error creating test suite: {str(e)}")
            raise RuntimeError(f"Failed to create test suite: {str(e)}")

    def create_test_case(self, test_case: Dict):
        try:
            # Load test steps and data sets
            case_id = test_case['Case ID']
            test_steps = self.web_test_loader.get_test_steps(case_id)
            test_data_sets = self.web_test_loader.get_test_data(case_id)

            # Create empty data set if none exists
            if not test_data_sets:
                logging.warning(f"{self.__class__.__name__}: No data sets found for test case {case_id}. Using empty data")
                test_data_sets = [{}]

            # Generate tests for each data set
            for data_set_index, data_set in enumerate(test_data_sets, 1):
                test_name = f"UI.{case_id}.{test_case['Name']}.{data_set_index}"
                robot_test = self.robot_suite.tests.create(name=test_name, doc=test_case['Descriptions'])
                robot_test.body.create_keyword(name='sanity_check', args=[])

                # Add tags
                if 'Tags' in test_case and pd.notna(test_case['Tags']):
                    tags = [tag.strip() for tag in test_case['Tags'].split(',')]
                    for tag in tags:
                        robot_test.tags.add(tag)

                # Create test steps
                self.create_test_steps(robot_test, test_steps, data_set)
                logging.info(f"{self.__class__.__name__}: Test case {case_id}.{data_set_index} created successfully.")

        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error creating test case {test_case.get('Case ID', 'Unknown')}: {str(e)}")
            raise

    def _import_required_libraries(self):
        try:
            self.robot_suite.resource.imports.library('libraries.web.page_object.PageObject')
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error importing required libraries: {str(e)}")
            raise

    def create_test_steps(self, robot_test, test_steps: List[Dict], data_set: Dict):
        try:
            for _, step in test_steps.iterrows():
                if step['Run'] == 'Y':
                    # Get step information
                    page_name = step['Page Name']
                    module_name = step['Module Name']

                    # Create UI test step
                    self._generate_ui_step(robot_test, page_name, module_name, data_set)

        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error creating test steps: {str(e)}")
            raise

    def _generate_ui_step(self, robot_test, page_name: str, module_name: str, params: Dict):
        try:
            robot_test.body.create_keyword(name='execute_module', args=[page_name, module_name, params])
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error generating UI step for {page_name}.{module_name}: {str(e)}")
            raise

</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_test_loader_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\web_test_loader.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import json
import logging
import pandas as pd
import os
from typing import Dict, List

class WebTestLoader:
    _instances = {}

    def __new__(cls, excel_path, test_config):
        key = (excel_path, id(test_config))  # Use a tuple of excel_path and test_config id as the key
        if key not in cls._instances:
            instance = super().__new__(cls)
            instance.__init__(excel_path, test_config)
            cls._instances[key] = instance
        return cls._instances[key]

    def __init__(self, excel_path, test_config):
        if hasattr(self, 'initialized'):
            return
        self.excel_path = excel_path
        self.test_config = test_config
        self.data = self._load_excel_data()
        self._validate_data()
        self.initialized = True

    def _load_excel_data(self) -&gt; Dict[str, pd.DataFrame]:
        sheets = ['Locators', 'PageModules', 'TestCases', 'TestSteps', 'TestData', 'WebEnvironments', 'CustomActions']
        return {sheet: pd.read_excel(self.excel_path, sheet_name=sheet).fillna("") for sheet in sheets}

    def _validate_data(self):
        self._validate_test_cases()
        self._validate_test_steps()
        self._validate_page_objects()
        self._validate_test_data()
        self._validate_web_environments()
        self._validate_custom_actions()

    def _validate_test_cases(self):
        test_cases = self.get_data_by_sheet_name('TestCases')
        test_steps = self.get_data_by_sheet_name('TestSteps')

        case_ids_in_steps = set(test_steps['Case ID'].unique())
        for _, row in test_cases.iterrows():
            case_id = row['Case ID']
            if case_id not in case_ids_in_steps:
                logging.error(f"WebTestLoader: Case ID '{case_id}' does not have any steps defined in the TestSteps sheet.")

    def _validate_test_steps(self):
        test_steps = self.get_data_by_sheet_name('TestSteps')
        page_modules = self.get_data_by_sheet_name('PageModules')

        page_module_combinations = set(zip(page_modules[page_modules['Run'] == 'Y']['Page Name'],
                                           page_modules[page_modules['Run'] == 'Y']['Module Name']))
        for _, row in test_steps[test_steps['Run'] == 'Y'].iterrows():
            if (row['Page Name'], row['Module Name']) not in page_module_combinations and row['Module Name'] != 'API':
                logging.error(
                    f"WebTestLoader: Invalid Page Name '{row['Page Name']}' and Module Name '{row['Module Name']}' combination in TestSteps for Case ID '{row['Case ID']}'.")
            self._validate_parameters(row)

    def _validate_parameters(self, step_row):
        page_modules = self.get_data_by_sheet_name('PageModules')
        test_data = self.get_data_by_sheet_name('TestData')

        module_params = page_modules[(page_modules['Page Name'] == step_row['Page Name']) &amp;
                                     (page_modules['Module Name'] == step_row['Module Name'])]['Parameter Name'].tolist()
        module_params = [param for param in module_params if param]

        if module_params:
            expected_params = set()
            for param in module_params:
                expected_params.update(param.split(','))

            case_data = test_data[test_data['Case ID'] == step_row['Case ID']]
            for param in expected_params:
                if param not in case_data['Parameter Name'].values:
                    logging.error(f"No data provided for parameter '{param}' in TestData for Case ID '{step_row['Case ID']}'")

    def _validate_page_objects(self):
        page_objects = self.get_data_by_sheet_name('PageModules')
        locators = self.get_data_by_sheet_name('Locators')

        locator_map = set(zip(locators['Page Name'], locators['Element Name']))
        for _, row in page_objects[page_objects['Run'] == 'Y'].iterrows():
            if row['Element Name'] and (row['Page Name'], row['Element Name']) not in locator_map:
                logging.error(f"WebTestLoader: Element '{row['Element Name']}' on page '{row['Page Name']}' not found in Locators sheet.")

    def _validate_test_data(self):
        test_data = self.get_data_by_sheet_name('TestData')
        test_steps = self.get_data_by_sheet_name('TestSteps')

        case_ids_in_steps = set(test_steps['Case ID'].unique())
        for _, row in test_data.iterrows():
            if row['Case ID'] not in case_ids_in_steps:
                logging.error(f"WebTestLoader: Test data for Case ID '{row['Case ID']}' does not have corresponding test steps.")

    def _validate_web_environments(self):
        web_environments = self.get_data_by_sheet_name('WebEnvironments')

        if web_environments.empty:
            logging.error("WebTestLoader: WebEnvironments sheet is empty or does not exist.")
            return

        required_columns = ['Environment', 'Browser', 'IsRemote', 'RemoteURL', 'ChromePath', 'ChromeDriverPath', 'EdgePath', 'EdgeDriverPath', 'BrowserOptions']
        missing_columns = set(required_columns) - set(web_environments.columns)
        if missing_columns:
            logging.error(f"WebTestLoader: Missing required columns in WebEnvironments sheet: {', '.join(missing_columns)}")
            return

        # Check if active_environment exists in WebEnvironments
        active_environment = self.test_config.get('active_environment')
        if active_environment and active_environment not in web_environments['Environment'].values:
            logging.error(f"WebTestLoader: Active environment '{active_environment}' specified in config file does not exist in WebEnvironments sheet.")

        for index, row in web_environments.iterrows():
            if self.test_config.get('active_environment') != row['Environment']:
                continue
            if pd.isna(row['Environment']) or row['Environment'] == '':
                logging.error(f"WebTestLoader: Empty Environment name in row {index + 2}")

            if row['Browser'].lower() not in ['chrome', 'edge']:
                logging.error(f"WebTestLoader: Invalid Browser '{row['Browser']}' in row {index + 2}. Must be 'chrome' or 'edge'.")

            if not isinstance(row['IsRemote'], bool):
                logging.error(f"WebTestLoader: IsRemote must be a boolean value in row {index + 2}")

            if row['IsRemote']:
                if pd.isna(row['RemoteURL']) or row['RemoteURL'] == '':
                    logging.error(f"WebTestLoader: RemoteURL is required when IsRemote is True in row {index + 2}")
            else:
                if row['Browser'].lower() == 'chrome':
                    for path_column in ['ChromePath', 'ChromeDriverPath']:
                        if pd.isna(row[path_column]) or row[path_column] == '':
                            logging.error(f"WebTestLoader: {path_column} is required when IsRemote is False and Browser is Chrome in row {index + 2}")
                        elif not os.path.exists(row[path_column]):
                            logging.warning(f"WebTestLoader: {path_column} '{row[path_column]}' does not exist in row {index + 2}")
                elif row['Browser'].lower() == 'edge':
                    for path_column in ['EdgePath', 'EdgeDriverPath']:
                        if pd.isna(row[path_column]) or row[path_column] == '':
                            logging.error(f"WebTestLoader: {path_column} is required when IsRemote is False and Browser is Edge in row {index + 2}")
                        elif not os.path.exists(row[path_column]):
                            logging.warning(f"WebTestLoader: {path_column} '{row[path_column]}' does not exist in row {index + 2}")

            try:
                if not pd.isna(row['BrowserOptions']) and row['BrowserOptions'] != '':
                    json.loads(row['BrowserOptions'])
            except json.JSONDecodeError:
                logging.error(f"WebTestLoader: Invalid JSON in BrowserOptions in row {index + 2}")

        logging.info("WebTestLoader: WebEnvironments data validation completed.")

    def _validate_custom_actions(self):
        custom_actions = self.get_data_by_sheet_name('CustomActions')
        if custom_actions.empty:
            logging.warning("WebTestLoader: CustomActions sheet is empty.")
            return

        required_columns = ['Action Name', 'Python Code']
        missing_columns = set(required_columns) - set(custom_actions.columns)
        if missing_columns:
            logging.error(f"WebTestLoader: Missing required columns in CustomActions sheet: {', '.join(missing_columns)}")
            return

        for index, row in custom_actions.iterrows():
            if pd.isna(row['Action Name']) or row['Action Name'] == '':
                logging.error(f"WebTestLoader: Empty Action Name in CustomActions row {index + 2}")
            if pd.isna(row['Python Code']) or row['Python Code'] == '':
                logging.error(f"WebTestLoader: Empty Python Code for web_element_actions '{row['Action Name']}' in CustomActions row {index + 2}")

    def get_data_by_sheet_name(self, sheet_name: str) -&gt; pd.DataFrame:
        return self.data.get(sheet_name, pd.DataFrame())

    def filter_cases(self, tcid_list: List[str] = None, tags: List[str] = None) -&gt; pd.DataFrame:
        test_cases = self.get_test_cases()

        if tcid_list:
            test_cases = test_cases[test_cases['Case ID'].isin(tcid_list)]

        if tags:
            test_cases = test_cases[test_cases['Tags'].apply(lambda x: any(tag in str(x).split(',') for tag in tags))]

        test_cases = test_cases[test_cases['Run'] == 'Y']

        return test_cases

    def get_test_cases(self) -&gt; pd.DataFrame:
        return self.get_data_by_sheet_name('TestCases')

    def get_test_steps(self, case_id: str) -&gt; pd.DataFrame:
        test_steps = self.get_data_by_sheet_name('TestSteps')
        result = test_steps[(test_steps['Case ID'] == case_id) &amp; (test_steps['Run'] == 'Y')]
        if result.empty:
            logging.warning(f"WebTestLoader: No test steps found for case ID: {case_id}")
        return result

    def get_test_data(self, case_id: str) -&gt; List[Dict]:
        test_data = self.get_data_by_sheet_name('TestData')
        case_data = test_data[test_data['Case ID'] == case_id]

        test_steps = self.get_test_steps(case_id)
        non_api_steps = test_steps[test_steps['Module Name'] != 'API']

        if case_data.empty and not non_api_steps.empty:
            logging.warning(f"WebTestLoader: No test data found for case ID: {case_id}")

        grouped_data = case_data.groupby('Data Set')

        data_sets = []
        for _, group in grouped_data:
            data_set = {}
            for _, row in group.iterrows():
                value = self._parse_value(row['Value'], row['Data Type'])
                data_set[row['Parameter Name']] = value
            data_sets.append(data_set)

        return data_sets

    def _parse_value(self, value: str, data_type: str):
        if data_type.lower() == 'json':
            try:
                return json.loads(value)
            except json.JSONDecodeError:
                logging.error(f"Invalid JSON string: {value}")
                return value
        elif data_type.lower() == 'integer':
            try:
                return int(value)
            except ValueError:
                logging.error(f"Invalid integer value: {value}")
                return value
        elif data_type.lower() == 'float':
            try:
                return float(value)
            except ValueError:
                logging.error(f"Invalid float value: {value}")
                return value
        elif data_type.lower() == 'boolean':
            return value.lower() in ('true', 'yes', '1', 'on')
        else:
            return value

    def get_page_objects(self) -&gt; pd.DataFrame:
        page_objects = self.get_data_by_sheet_name('PageModules')
        return page_objects[page_objects['Run'] == 'Y']

    def get_locators(self) -&gt; pd.DataFrame:
        return self.get_data_by_sheet_name('Locators')

    def get_web_environments(self) -&gt; pd.DataFrame:
        return self.get_data_by_sheet_name('WebEnvironments')

    def get_custom_actions(self) -&gt; Dict[str, str]:
        custom_actions_df = self.get_data_by_sheet_name('CustomActions')
        return dict(zip(custom_actions_df['Action Name'], custom_actions_df['Python Code']))</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_webdriver_factory_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\webdriver_factory.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import logging
from selenium import webdriver
from selenium.webdriver.chrome.service import Service as ChromeService
from selenium.webdriver.edge.service import Service as EdgeService
from selenium.webdriver.chrome.options import Options as ChromeOptions
from selenium.webdriver.edge.options import Options as EdgeOptions


class WebDriverFactory:
    @staticmethod
    def create_driver(driver_config):
        browser = driver_config['browser']
        is_remote = driver_config.get('is_remote', False)
        remote_url = driver_config.get('remote_url')
        browser_options = driver_config.get('browser_options', {})

        logging.info(f"WebDriverFactory: Configuring for browser: {browser}")
        logging.info(f"WebDriverFactory: Remote execution: {'Yes' if is_remote else 'No'}")
        browser_path = None
        if browser.lower() == 'chrome':
            options = ChromeOptions()
            if not is_remote:
                service = ChromeService(executable_path=driver_config.get('chrome_driver_path'))
                browser_path = driver_config.get('chrome_path')
                logging.info(f"WebDriverFactory: Using ChromeDriver path: {driver_config.get('chrome_driver_path')}")
        elif browser.lower() == 'edge':
            options = EdgeOptions()
            if not is_remote:
                service = EdgeService(executable_path=driver_config.get('edge_driver_path'))
                browser_path = driver_config.get('edge_path')
                logging.info(f"WebDriverFactory: Using EdgeDriver path: {driver_config.get('edge_driver_path')}")
        else:
            logging.error(f"WebDriverFactory: Unsupported browser: {browser}")
            raise ValueError(f"WebDriverFactory: Unsupported browser: {browser}")

        # 设置浏览器路径
        if browser_path and not is_remote:
            options.binary_location = browser_path
            logging.info(f"WebDriverFactory: Set browser binary location: {browser_path}")

        # 设置浏览器选项
        logging.info("WebDriverFactory: Configuring browser options:")
        for option, value in browser_options.items():
            if isinstance(value, bool) and value:
                options.add_argument(f'--{option}')
                logging.info(f"WebDriverFactory: Added browser option: --{option}")
            elif isinstance(value, str):
                options.add_argument(f'--{option}={value}')
                logging.info(f"WebDriverFactory: Added browser option: --{option}={value}")

        if is_remote:
            if not remote_url:
                logging.error(f"WebDriverFactory: Remote URL is required for remote execution")
                raise ValueError(f"WebDriverFactory: Remote URL is required for remote execution")
            logging.info(f"WebDriverFactory: Creating remote WebDriver with URL: {remote_url}")
            driver = webdriver.Remote(command_executor=remote_url, options=options)
        else:
            if browser.lower() == 'chrome':
                logging.info(f"WebDriverFactory: Creating local Chrome WebDriver")
                driver = webdriver.Chrome(service=service, options=options)
            elif browser.lower() == 'edge':
                logging.info(f"WebDriverFactory: Creating local Edge WebDriver")
                driver = webdriver.Edge(service=service, options=options)

        logging.info(f"WebDriverFactory: WebDriver created successfully")
        return driver

    @staticmethod
    def quit_driver(driver):
        if driver:
            logging.info(f"WebDriverFactory: Quitting WebDriver")
            driver.close()
            logging.info(f"WebDriverFactory: WebDriver quit successfully")
        else:
            logging.warning(f"WebDriverFactory: Attempted to quit a non-existent WebDriver")
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_main_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\main.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import os
import argparse

from robot.libraries.BuiltIn import BuiltIn
from robot.reporting import ResultWriter
from libraries.common.utility_helpers import PROJECT_ROOT
from libraries.robot.robot_dashboard_generator import DashboardGenerator
from libraries.web.web_robot_generator import WebUIRobotCasesGenerator
from libraries.e2e.e2e_robot_generator import E2ERobotCasesGenerator
from libraries.api.api_robot_generator import APIRobotCasesGenerator
from libraries.performance.web_pt_robot_generator import WebPerformanceRobotCasesGenerator


class ExitOnFailureListener:
    ROBOT_LISTENER_API_VERSION = 3

    def __init__(self):
        self.exit_on_failure = False

    def end_test(self, data, result):
        if 'sanity check' in [tag.lower() for tag in result.tags] and result.status == 'FAIL':
            self.exit_on_failure = True
            BuiltIn().set_global_variable('${skip_on_sanity_check_failure}', True)


def run_test_suite(suite):
    listener = ExitOnFailureListener()
    output_dir = os.path.join(PROJECT_ROOT, 'report')
    output_xml = os.path.join(output_dir, 'output.xml')
    report_file = os.path.join(output_dir, 'report.html')
    log_file = os.path.join(output_dir, 'log.html')

    suite.run(output=output_xml, listener=listener)

    ResultWriter(output_xml).write_results(report=report_file, log=log_file)

    dashboard_generator = DashboardGenerator()
    dashboard_generator.generate_dashboard(output_xml)


def create_api_suite():
    rcg = APIRobotCasesGenerator()
    return rcg.create_test_suite()


def create_web_suite():
    rcg = WebUIRobotCasesGenerator()
    return rcg.create_test_suite()


def create_e2e_suite():
    rcg = E2ERobotCasesGenerator()
    return rcg.create_test_suite()


def create_performance_suite():
    rcg = WebPerformanceRobotCasesGenerator()
    return rcg.create_test_suite()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Run API, Web UI, or E2E tests.')
    parser.add_argument('--api', action='store_true', help='Run API tests')
    parser.add_argument('--web', action='store_true', help='Run Web UI tests')
    parser.add_argument('--e2e', action='store_true', help='Run E2E tests')
    parser.add_argument('--performance', action='store_true', help='Run performance tests')
    args = parser.parse_args()

    if args.api:
        suite_to_run = create_api_suite()
    elif args.web:
        suite_to_run = create_web_suite()
    elif args.e2e:
        suite_to_run = create_e2e_suite()
    elif args.performance:
        suite_to_run = create_performance_suite()
    else:
        suite_to_run = create_e2e_suite()

    run_test_suite(suite_to_run)
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_templates_rf_report_template_html">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\templates\rf_report_template.html</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet"&gt;
    &lt;link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" rel="stylesheet"&gt;
    &lt;link rel="stylesheet" href="https://cdn.datatables.net/1.11.5/css/dataTables.bootstrap5.min.css"&gt;
    &lt;title&gt;Metrics Report&lt;/title&gt;
    &lt;style&gt;
        .sidebar {
            width: 140px;
            background: #343a40;
            padding: 1rem 0;
            position: fixed;
            height: 100%;
            overflow-y: auto;
            transition: transform 0.3s ease-in-out;
            z-index: 1000;
        }

        @media (max-width: 767.98px) {
            .sidebar {
                transform: translateX(-100%);
            }

            .sidebar.show {
                transform: translateX(0);
            }

            .content {
                margin-left: 0 !important;
            }
        }

        .sidebar .nav-link {
            color: #ffffff;
            text-align: center;
            padding: 1rem 0.5rem;
            transition: all 0.3s ease;
        }

        .sidebar .nav-link i {
            font-size: 2rem;
            display: block;
            margin-bottom: 0.5rem;
        }

        .sidebar .nav-link span {
            font-size: 0.8rem;
            display: block;
        }

        .sidebar .nav-link:hover,
        .sidebar .nav-link.active {
            background-color: #495057;
            border-left: 4px solid #007bff;
        }

        .content {
            margin-left: 160px;
            padding: 1rem;
        }

        .table {
            font-size: 0.875rem;
            border-radius: 10px;
            overflow: hidden;
            border-collapse: separate;
        }

        .table-hover tbody tr:hover {
            background-color: #f1f1f1;
        }

        .table thead th {
            background-color: #343a40;
            color: #ffffff;
            border-bottom: 1px solid #495057;
            border-top: 1px solid #495057;
        }

        .table tbody td {
            border-top: 1px solid #dee2e6;
        }

        .table thead th:first-child {
            border-top-left-radius: 10px;
            border-left: 1px solid #dee2e6;
        }

        .table thead th:last-child {
            border-top-right-radius: 10px;
            border-right: 1px solid #dee2e6;
        }

        .table tbody tr:last-child td:first-child {
            border-bottom-left-radius: 10px;
            border-left: 1px solid #dee2e6;
        }

        .table tbody tr:last-child td:last-child {
            border-bottom-right-radius: 10px;
            border-right: 1px solid #dee2e6;
        }

        .pie-chart {
            width: 100%;
            height: 400px;
            margin-bottom: 2rem;
            background-color: #e9ecef;
            border-radius: 10px;
            padding: 15px;
        }

        .loader {
            border: 0.5rem solid #f3f3f3;
            border-radius: 50%;
            border-top: 0.5rem solid #3498db;
            width: 5rem;
            height: 5rem;
            animation: spin 1s linear infinite;
            margin: auto;
            display: block;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .clickable-link {
            color: #007bff !important;
            cursor: pointer;
        }

        .clickable-link:hover {
            color: #343a40 !important;
            text-decoration: none;
        }

        #menu-toggle {
            position: fixed;
            top: 33px;
            left: 5px;
            z-index: 1001;
            display: none;
            background-color: transparent;
            color: #343a40;
            border: none;
        }

        @media (max-width: 767.98px) {
            #menu-toggle {
                display: block;
            }
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="loader" id="loadingDiv"&gt;&lt;/div&gt;

&lt;button id="menu-toggle" class="btn btn-primary"&gt;
    &lt;i class="fas fa-bars"&gt;&lt;/i&gt;
&lt;/button&gt;

&lt;nav class="sidebar" id="sidebar"&gt;
    &lt;div class="nav flex-column"&gt;
        &lt;a class="nav-link active" href="#" id="defaultOpen" onclick="openPage('dashboard', this)"&gt;
            &lt;i class="fa fa-dashboard"&gt;&lt;/i&gt;
            &lt;span&gt;Dashboard&lt;/span&gt;
        &lt;/a&gt;
        &lt;a class="nav-link" href="#" onclick="openPage('suiteMetrics', this); executeDataTable('#sm', 10, 6);"&gt;
            &lt;i class="fa fa-th-large"&gt;&lt;/i&gt;
            &lt;span&gt;Suite Metrics&lt;/span&gt;
        &lt;/a&gt;
        &lt;a class="nav-link" href="#" onclick="openPage('testMetrics', this); executeDataTable('#tm', 10, 3);"&gt;
            &lt;i class="fa fa-list-alt"&gt;&lt;/i&gt;
            &lt;span&gt;Test Metrics&lt;/span&gt;
        &lt;/a&gt;
        &lt;a class="nav-link" href="#" onclick="openPage('log', this);"&gt;
            &lt;i class="fa fa-file-text"&gt;&lt;/i&gt;
            &lt;span&gt;Robot Logs&lt;/span&gt;
        &lt;/a&gt;
    &lt;/div&gt;
&lt;/nav&gt;

&lt;div class="content" id="main"&gt;
    &lt;div class="tabcontent" id="suiteMetrics"&gt;
        &lt;h4&gt;&lt;b&gt;&lt;i class="fa fa-table"&gt;&lt;/i&gt; Suite Metrics&lt;/b&gt;&lt;/h4&gt;
        &lt;hr&gt;
        &lt;h6 class="text-end"&gt;**Click Suite name to view logs&lt;/h6&gt;
        &lt;table class="table table-hover table-bordered" id="sm"&gt;
            &lt;thead&gt;
            &lt;tr&gt;
                &lt;th&gt;Suite Name&lt;/th&gt;
                &lt;th&gt;Status&lt;/th&gt;
                &lt;th&gt;Total TC&lt;/th&gt;
                &lt;th&gt;Pass TC&lt;/th&gt;
                &lt;th&gt;Fail TC&lt;/th&gt;
                &lt;th&gt;Skip TC&lt;/th&gt;
                &lt;th&gt;Start Time&lt;/th&gt;
                &lt;th&gt;End Time&lt;/th&gt;
                &lt;th&gt;Elapsed Time (s)&lt;/th&gt;
            &lt;/tr&gt;
            &lt;/thead&gt;
            &lt;tbody&gt;
            {% for suite in suites %}
            &lt;tr&gt;
                &lt;td class="clickable-link" onclick="openInNewTab('log.html#{{ suite['Id'] }}','#{{ suite['Id'] }}')"&gt;
                    {{ suite['Name'] }}
                &lt;/td&gt;
                &lt;td class="{% if suite['Status'] == 'PASS' %}text-success{% elif suite['Status'] == 'FAIL' %}text-danger{% else %}text-warning{% endif %}"&gt;{{ suite['Status'] }}
                &lt;/td&gt;
                &lt;td&gt;{{ suite['Total'] }}&lt;/td&gt;
                &lt;td class="text-success"&gt;{{ suite['Pass'] }}&lt;/td&gt;
                &lt;td class="text-danger"&gt;{{ suite['Fail'] }}&lt;/td&gt;
                &lt;td class="text-warning"&gt;{{ suite['Skip'] }}&lt;/td&gt;
                &lt;td&gt;{{ suite['startTime'] }}&lt;/td&gt;
                &lt;td&gt;{{ suite['endTime'] }}&lt;/td&gt;
                &lt;td&gt;{{ (suite['Time']/1000)|round(2) }}&lt;/td&gt;
            &lt;/tr&gt;
            {% endfor %}
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/div&gt;

    &lt;div class="tabcontent" id="testMetrics"&gt;
        &lt;h4&gt;&lt;b&gt;&lt;i class="fa fa-table"&gt;&lt;/i&gt; Test Metrics&lt;/b&gt;&lt;/h4&gt;
        &lt;hr&gt;
        &lt;h6 class="text-end"&gt;**Click Test Case name to view logs&lt;/h6&gt;
        &lt;table class="table table-hover table-bordered" id="tm"&gt;
            &lt;thead&gt;
            &lt;tr&gt;
                &lt;th&gt;Suite Name&lt;/th&gt;
                &lt;th&gt;Test Case&lt;/th&gt;
                &lt;th&gt;Status&lt;/th&gt;
                &lt;th&gt;Start Time&lt;/th&gt;
                &lt;th&gt;End Time&lt;/th&gt;
                &lt;th&gt;Elapsed Time (s)&lt;/th&gt;
                &lt;th&gt;Message&lt;/th&gt;
            &lt;/tr&gt;
            &lt;/thead&gt;
            &lt;tbody&gt;
            {% for test in tests %}
            &lt;tr&gt;
                &lt;td&gt;{{ test['Suite Name'] }}&lt;/td&gt;
                &lt;td class="clickable-link" onclick="openInNewTab('log.html#{{ test['Test Id'] }}','#{{ test['Test Id'] }}')"&gt;
                    {{ test['Test Name'] }}
                &lt;/td&gt;
                &lt;td class="{% if test['Status'] == 'PASS' %}text-success{% elif test['Status'] == 'FAIL' %}text-danger{% else %}text-warning{% endif %}"&gt;{{ test['Status'] }}&lt;/td&gt;
                &lt;td&gt;{{ test['startTime'] }}&lt;/td&gt;
                &lt;td&gt;{{ test['endTime'] }}&lt;/td&gt;
                &lt;td&gt;{{ (test['Time']/1000)|round(2) }}&lt;/td&gt;
                &lt;td&gt;{{ test['Message'] }}&lt;/td&gt;
            &lt;/tr&gt;
            {% endfor %}
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/div&gt;

    &lt;div class="tabcontent" id="log"&gt;
        &lt;p class="text-end"&gt;
            ** &lt;b&gt;Report.html&lt;/b&gt; and &lt;b&gt;Log.html&lt;/b&gt; need to be in the current folder to display here
        &lt;/p&gt;
        &lt;div class="ratio ratio-16x9"&gt;
            &lt;iframe src="log.html"&gt;&lt;/iframe&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class="tabcontent" id="dashboard"&gt;
    &lt;h4&gt;&lt;b&gt;&lt;i class="fa fa-dashboard"&gt;&lt;/i&gt; Dashboard&lt;/b&gt;&lt;/h4&gt;
    &lt;hr&gt;
    &lt;div class="row mb-4"&gt;
        &lt;div class="col-sm-3 col-md-3 mb-3"&gt;
            &lt;div class="card bg-dark text-white text-center"&gt;
                &lt;div class="card-body"&gt;
                    &lt;h5 class="card-title"&gt;Suite&lt;/h5&gt;
                    &lt;p class="card-text"&gt;Statistics&lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="col-sm-3 col-md-3 mb-3"&gt;
            &lt;div class="card bg-primary text-white text-center"&gt;
                &lt;div class="card-body"&gt;
                    &lt;h5 class="card-title"&gt;{{suite_stats['Total']}}&lt;/h5&gt;
                    &lt;p class="card-text"&gt;Total&lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="col-sm-2 col-md-2 mb-2"&gt;
            &lt;div class="card bg-success text-white text-center"&gt;
                &lt;div class="card-body"&gt;
                    &lt;h5 class="card-title"&gt;{{suite_stats['Pass']}}&lt;/h5&gt;
                    &lt;p class="card-text"&gt;Passed&lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="col-sm-2 col-md-2 mb-2"&gt;
            &lt;div class="card bg-danger text-white text-center"&gt;
                &lt;div class="card-body"&gt;
                    &lt;h5 class="card-title"&gt;{{suite_stats['Fail']}}&lt;/h5&gt;
                    &lt;p class="card-text"&gt;Failed&lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="col-sm-2 col-md-2 mb-2"&gt;
            &lt;div class="card bg-warning text-white text-center"&gt;
                &lt;div class="card-body"&gt;
                    &lt;h5 class="card-title"&gt;{{suite_stats['Skip']}}&lt;/h5&gt;
                    &lt;p class="card-text"&gt;Skipped&lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class="row mb-4"&gt;
        &lt;div class="col-sm-3 col-md-3 mb-3"&gt;
            &lt;div class="card bg-dark text-white text-center"&gt;
                &lt;div class="card-body"&gt;
                    &lt;h5 class="card-title"&gt;Test Case&lt;/h5&gt;
                    &lt;p class="card-text"&gt;Statistics&lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="col-sm-3 col-md-3 mb-3"&gt;
            &lt;div class="card bg-primary text-white text-center"&gt;
                &lt;div class="card-body"&gt;
                    &lt;h5 class="card-title"&gt;{{test_stats['Total']}}&lt;/h5&gt;
                    &lt;p class="card-text"&gt;Total&lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="col-sm-2 col-md-2 mb-2"&gt;
            &lt;div class="card bg-success text-white text-center"&gt;
                &lt;div class="card-body"&gt;
                    &lt;h5 class="card-title"&gt;{{test_stats['Pass']}}&lt;/h5&gt;
                    &lt;p class="card-text"&gt;Passed&lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="col-sm-2 col-md-2 mb-2"&gt;
            &lt;div class="card bg-danger text-white text-center"&gt;
                &lt;div class="card-body"&gt;
                    &lt;h5 class="card-title"&gt;{{test_stats['Fail']}}&lt;/h5&gt;
                    &lt;p class="card-text"&gt;Failed&lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="col-sm-2 col-md-2 mb-2"&gt;
            &lt;div class="card bg-warning text-white text-center"&gt;
                &lt;div class="card-body"&gt;
                    &lt;h5 class="card-title"&gt;{{test_stats['Skip']}}&lt;/h5&gt;
                    &lt;p class="card-text"&gt;Skipped&lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class="row"&gt;
        &lt;div class="col-sm-6 col-md-6 mb-4"&gt;
            &lt;div class="pie-chart"&gt;
                &lt;canvas id="suiteChart"&gt;&lt;/canvas&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="col-sm-6 col-md-6 mb-4"&gt;
            &lt;div class="pie-chart"&gt;
                &lt;canvas id="testChart"&gt;&lt;/canvas&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;script src="https://code.jquery.com/jquery-3.6.0.min.js"&gt;&lt;/script&gt;
&lt;script src="https://cdn.datatables.net/1.11.5/js/jquery.dataTables.min.js"&gt;&lt;/script&gt;
&lt;script src="https://cdn.datatables.net/1.11.5/js/dataTables.bootstrap5.min.js"&gt;&lt;/script&gt;
&lt;script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"&gt;&lt;/script&gt;
&lt;script src="https://cdn.jsdelivr.net/npm/chart.js"&gt;&lt;/script&gt;
&lt;script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"&gt;&lt;/script&gt;
&lt;script&gt;
        document.addEventListener("DOMContentLoaded", function() {
            document.getElementById("loadingDiv").style.display = "none";
            document.getElementById("defaultOpen").click();

            createPieChart('suiteChart', 'Suite Results', ['Pass', 'Fail', 'Skip'],
                           [{{ suite_stats['Pass'] }}, {{ suite_stats['Fail'] }},{{ suite_stats['Skip'] }}],
                           {{ suite_stats['Total'] }});

        createPieChart('testChart', 'Test Case Results', ['Pass', 'Fail', 'Skip'],
                       [{{ test_stats['Pass'] }}, {{ test_stats['Fail'] }}, {{ test_stats['Skip'] }}],
                       {{ test_stats['Total'] }});

        // Toggle sidebar on menu button click
        document.getElementById('menu-toggle').addEventListener('click', function() {
            document.getElementById('sidebar').classList.toggle('show');
        });
    });

        function createPieChart(canvasId, title, labels, data, total) {
            var ctx = document.getElementById(canvasId).getContext('2d');
            Chart.register(ChartDataLabels);
            var chart = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: labels,
                    datasets: [{
                        label: title,
                        data: data,
                        backgroundColor: ['#28a745', '#dc3545', '#ffc107'],
                        hoverOffset: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                        },
                        title: {
                            display: true,
                            text: title
                        },
                        tooltip: {
                            callbacks: {
                                label: function(tooltipItem) {
                                    var value = tooltipItem.raw;
                                    var percentage = ((value / total) * 100).toFixed(2);
                                    return tooltipItem.label + ': ' + value + ' (' + percentage + '%)';
                                }
                            }
                        },
                        datalabels: {
                            color: '#fff',
                            font: {
                                weight: 'bold'
                            },
                            formatter: function(value, context) {
                                var percentage = ((value / total) * 100).toFixed(2);
                                return percentage + '%';
                            }
                        }
                    }
                }
            });
        }

    function openPage(pageName, elmnt) {
        var i, tabcontent, tablinks;
        tabcontent = document.getElementsByClassName("tabcontent");
        for (i = 0; i &lt; tabcontent.length; i++) {
            tabcontent[i].style.display = "none";
        }
        tablinks = document.getElementsByClassName("nav-link");
        for (i = 0; i &lt; tablinks.length; i++) {
            tablinks[i].className = tablinks[i].className.replace(" active", "");
        }
        document.getElementById(pageName).style.display = "block";
        elmnt.className += " active";

        // Hide sidebar on page change for mobile devices
        if (window.innerWidth &lt;= 767.98) {
            document.getElementById('sidebar').classList.remove('show');
        }
    }

    function executeDataTable(tableID, minRows, sortIndex) {
        if ($.fn.DataTable.isDataTable(tableID)) {
            $(tableID).DataTable().destroy();
        }
        $(tableID).DataTable({
            "pageLength": minRows,
            "ordering": true,
            "searching": true,
            "paging": true,
            "info": true,
            "lengthChange": true,
            "order": [[sortIndex, "asc"]],
            "language": {
                "paginate": {
                    "previous": "&lt;",
                    "next": "&gt;"
                }
            }
        });
    }

    $(document).ready(function () {
        $('[data-bs-toggle="tooltip"]').tooltip();
        executeDataTable('#sm', 10, 6);
        executeDataTable('#tm', 10, 3);
        document.getElementById("defaultOpen").click();
    });
    function openInNewTab(url) {
        window.open(url, '_blank').focus();
    }
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_testing_server_positions_json">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\testing_server\positions.json</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>{
    "balances": {
        "USD": 13500.0,
        "EUR": 8000.0,
        "HKD": 50000.0,
        "CNY": 58700.0
    },
    "transactions": {
        "USD": {
            "2024-05-29": {
                "inbound": {
                    "count": 2,
                    "total_amount": 4000.0
                },
                "outbound": {
                    "count": 0,
                    "total_amount": 0.0
                }
            }
        },
        "EUR": {
            "2024-05-28": {
                "inbound": {
                    "count": 1,
                    "total_amount": 200.0
                },
                "outbound": {
                    "count": 2,
                    "total_amount": 150.0
                }
            }
        },
        "HKD": {
            "2024-05-28": {
                "inbound": {
                    "count": 0,
                    "total_amount": 0.0
                },
                "outbound": {
                    "count": 1,
                    "total_amount": 1000.0
                }
            }
        },
        "CNY": {
            "2024-12-25": {
                "inbound": {
                    "count": 1,
                    "total_amount": 100.0
                },
                "outbound": {
                    "count": 1,
                    "total_amount": 100.0
                }
            }
        }
    }
}</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_testing_server_server_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\testing_server\server.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import json
from flask import Flask, request, jsonify, Response
import xml.etree.ElementTree as ET
from datetime import datetime

app = Flask(__name__)

def round_to_two_decimals(value):
    return round(float(value), 2)

def load_positions():
    try:
        with open('positions.json', 'r') as file:
            data = json.load(file)
    except FileNotFoundError:
        data = {
            "balances": {},
            "transactions": {}
        }

    if 'balances' not in data:
        data['balances'] = {}
    if 'transactions' not in data:
        data['transactions'] = {}

    return data

def save_positions(data):
    with open('positions.json', 'w') as file:
        json.dump(data, file, indent=4)

def clear_old_positions():
    data = load_positions()
    today = datetime.today().strftime('%Y-%m-%d')

    for currency, transactions in data['transactions'].items():
        if today in transactions:
            data['transactions'][currency] = {today: transactions[today]}

    save_positions(data)

def parse_iso20022_pacs008(xml_data):
    try:
        root = ET.fromstring(xml_data)
        transaction_id = root.find('.//{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}InstrId').text
        amount = round_to_two_decimals(float(root.find('.//{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}IntrBkSttlmAmt').text))
        currency = root.find('.//{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}IntrBkSttlmAmt').attrib['Ccy']

        debtor = {
            "name": root.find('.//{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}Dbtr/{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}Nm').text,
            "phones": [phone.text for phone in root.findall('.//{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}Dbtr/{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}PstlAdr/{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}Phne')],
            "email": root.find('.//{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}Dbtr/{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}CtctDtls/{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}EmailAdr').text,
            "address": root.find('.//{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}Dbtr/{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}PstlAdr/{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}StrtNm').text
        }

        creditor = {
            "name": root.find('.//{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}Cdtr/{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}Nm').text,
            "phones": [phone.text for phone in root.findall('.//{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}Cdtr/{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}PstlAdr/{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}Phne')],
            "email": root.find('.//{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}Cdtr/{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}CtctDtls/{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}EmailAdr').text,
            "address": root.find('.//{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}Cdtr/{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}PstlAdr/{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}StrtNm').text
        }
        return {
            "transaction_id": transaction_id,
            "amount": amount,
            "currency": currency,
            "debtor": debtor,
            "creditor": creditor
        }
    except Exception as e:
        return {"error": str(e)}

def dict_to_xml(tag, d):
    elem = ET.Element(tag)
    for key, val in d.items():
        child = ET.Element(key)
        if isinstance(val, dict):
            child.extend(dict_to_xml(key, val))
        else:
            child.text = str(val)
        elem.append(child)
    return elem

@app.route('/api/outbound_payment.xml', methods=['POST'])
def outbound_payment_xml():
    xml_data = request.data
    parsed_data = parse_iso20022_pacs008(xml_data)
    if "error" in parsed_data:
        return jsonify(parsed_data), 400

    data = load_positions()
    currency = parsed_data['currency']
    amount = parsed_data['amount']

    if currency in data['balances']:
        data['balances'][currency] = round_to_two_decimals(data['balances'][currency] - amount)
    else:
        return jsonify({"error": f"Currency {currency} not found"}), 400

    today = datetime.today().strftime('%Y-%m-%d')
    if currency not in data['transactions']:
        data['transactions'][currency] = {}

    if today not in data['transactions'][currency]:
        data['transactions'][currency][today] = {"inbound": {"count": 0, "total_amount": 0.0},
                                                 "outbound": {"count": 0, "total_amount": 0.0}}

    data['transactions'][currency][today]["outbound"]["count"] += 1
    data['transactions'][currency][today]["outbound"]["total_amount"] = round_to_two_decimals(
        data['transactions'][currency][today]["outbound"]["total_amount"] + amount
    )

    save_positions(data)

    response = {
        **parsed_data,
        "status": "Outbound Processed",
        "new_position": round_to_two_decimals(data['balances'][currency]),
        "cdata_content": f"&lt;![CDATA[This is a CDATA section for currency {currency}]]&gt;"
    }

    response_xml = dict_to_xml('result', response)
    xml_str = ET.tostring(response_xml, encoding='unicode', method='xml')
    xml_str = xml_str.replace('&amp;lt;![CDATA[', '&lt;![CDATA[').replace(']]&amp;gt;', ']]&gt;')
    xml_response = f'&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n{xml_str}'
    return Response(xml_response, content_type='application/xml')

@app.route('/api/inbound_payment.xml', methods=['POST'])
def inbound_payment_xml():
    xml_data = request.data
    parsed_data = parse_iso20022_pacs008(xml_data)
    if "error" in parsed_data:
        return jsonify(parsed_data), 400

    data = load_positions()
    currency = parsed_data['currency']
    amount = parsed_data['amount']

    if currency in data['balances']:
        data['balances'][currency] = round_to_two_decimals(data['balances'][currency] + amount)
    else:
        data['balances'][currency] = round_to_two_decimals(amount)

    today = datetime.today().strftime('%Y-%m-%d')
    if currency not in data['transactions']:
        data['transactions'][currency] = {}

    if today not in data['transactions'][currency]:
        data['transactions'][currency][today] = {"inbound": {"count": 0, "total_amount": 0.0},
                                                 "outbound": {"count": 0, "total_amount": 0.0}}

    data['transactions'][currency][today]["inbound"]["count"] += 1
    data['transactions'][currency][today]["inbound"]["total_amount"] = round_to_two_decimals(
        data['transactions'][currency][today]["inbound"]["total_amount"] + amount
    )

    save_positions(data)

    response = {
        **parsed_data,
        "status": "Inbound Processed",
        "new_position": round_to_two_decimals(data['balances'][currency]),
        "cdata_content": f"&lt;![CDATA[This is a CDATA section for currency {currency}]]&gt;"
    }

    response_xml = dict_to_xml('result', response)
    xml_str = ET.tostring(response_xml, encoding='unicode', method='xml')
    xml_str = xml_str.replace('&amp;lt;![CDATA[', '&lt;![CDATA[').replace(']]&amp;gt;', ']]&gt;')
    xml_response = f'&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n{xml_str}'
    return Response(xml_response, content_type='application/xml')

@app.route('/api/outbound_payment.json', methods=['POST'])
def outbound_payment_json():
    request_data = request.json

    try:
        transaction_id = request_data['transaction_id']
        amount = round_to_two_decimals(request_data['amount'])
        currency = request_data['currency']
        debtor = request_data['debtor']
        creditor = request_data['creditor']
    except KeyError as e:
        return jsonify({"error": f"Missing key: {str(e)}"}), 400

    data = load_positions()

    if currency in data['balances']:
        data['balances'][currency] = round_to_two_decimals(data['balances'][currency] - amount)
    else:
        return jsonify({"error": f"Currency {currency} not found"}), 400

    today = datetime.today().strftime('%Y-%m-%d')
    if currency not in data['transactions']:
        data['transactions'][currency] = {}

    if today not in data['transactions'][currency]:
        data['transactions'][currency][today] = {"inbound": {"count": 0, "total_amount": 0.0},
                                                 "outbound": {"count": 0, "total_amount": 0.0}}

    data['transactions'][currency][today]["outbound"]["count"] += 1
    data['transactions'][currency][today]["outbound"]["total_amount"] = round_to_two_decimals(
        data['transactions'][currency][today]["outbound"]["total_amount"] + amount
    )

    save_positions(data)

    response = {
        "transaction_id": transaction_id,
        "amount": amount,
        "currency": currency,
        "debtor": debtor,
        "creditor": creditor,
        "status": "Outbound Processed",
        "new_position": round_to_two_decimals(data['balances'][currency])
    }
    return jsonify(response), 200

@app.route('/api/inbound_payment.json', methods=['POST'])
def inbound_payment_json():
    request_data = request.json

    try:
        transaction_id = request_data['transaction_id']
        amount = round_to_two_decimals(request_data['amount'])
        currency = request_data['currency']
        debtor = request_data['debtor']
        creditor = request_data['creditor']
    except KeyError as e:
        return jsonify({"error": f"Missing key: {str(e)}"}), 400

    data = load_positions()

    if currency in data['balances']:
        data['balances'][currency] = round_to_two_decimals(data['balances'][currency] + amount)
    else:
        data['balances'][currency] = round_to_two_decimals(amount)

    today = datetime.today().strftime('%Y-%m-%d')
    if currency not in data['transactions']:
        data['transactions'][currency] = {}

    if today not in data['transactions'][currency]:
        data['transactions'][currency][today] = {"inbound": {"count": 0, "total_amount": 0.0},
                                                 "outbound": {"count": 0, "total_amount": 0.0}}

    data['transactions'][currency][today]["inbound"]["count"] += 1
    data['transactions'][currency][today]["inbound"]["total_amount"] = round_to_two_decimals(
        data['transactions'][currency][today]["inbound"]["total_amount"] + amount
    )

    save_positions(data)

    response = {
        "transaction_id": transaction_id,
        "amount": amount,
        "currency": currency,
        "debtor": debtor,
        "creditor": creditor,
        "status": "Inbound Processed",
        "new_position": round_to_two_decimals(data['balances'][currency])
    }
    return jsonify(response), 200

@app.route('/api/positions', methods=['POST'])
def get_positions():
    clear_old_positions()
    request_data = request.json
    data = load_positions()
    today = datetime.today().strftime('%Y-%m-%d')

    if not isinstance(request_data, list):
        return jsonify({"error": "Request body must be a list of currencies"}), 400

    results = []
    for currency in request_data:
        if currency in data['balances']:
            transactions = data['transactions'].get(currency, {}).get(today,
                                                                      {"inbound": {"count": 0, "total_amount": 0.0},
                                                                       "outbound": {"count": 0, "total_amount": 0.0}})
            results.append({
                "currency": currency,
                "balance": round_to_two_decimals(data['balances'][currency]),
                "value_date": today,
                "inbound": {
                    "count": transactions["inbound"]["count"],
                    "total_amount": round_to_two_decimals(transactions["inbound"]["total_amount"])
                },
                "outbound": {
                    "count": transactions["outbound"]["count"],
                    "total_amount": round_to_two_decimals(transactions["outbound"]["total_amount"])
                }
            })
        else:
            results.append({
                "currency": currency,
                "balance": 0.00,
                "value_date": today,
                "inbound": {"count": 0, "total_amount": 0.00},
                "outbound": {"count": 0, "total_amount": 0.00}
            })

    return jsonify(results), 200

@app.route('/api/positions2', methods=['GET'])
def get_all_positions():
    clear_old_positions()
    data = load_positions()
    today = datetime.today().strftime('%Y-%m-%d')

    results = []
    for currency in data['balances']:
        transactions = data['transactions'].get(currency, {}).get(today,
                                                                  {"inbound": {"count": 0, "total_amount": 0.0},
                                                                   "outbound": {"count": 0, "total_amount": 0.0}})
        results.append({
            "currency": currency,
            "balance": round_to_two_decimals(data['balances'][currency]),
            "value_date": today,
            "inbound": {
                "count": transactions["inbound"]["count"],
                "total_amount": round_to_two_decimals(transactions["inbound"]["total_amount"])
            },
            "outbound": {
                "count": transactions["outbound"]["count"],
                "total_amount": round_to_two_decimals(transactions["outbound"]["total_amount"])
            }
        })

    return jsonify(results), 200

if __name__ == '__main__':
    app.run(debug=True, port=5000)
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_yaml_config_cli_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\yaml_config_cli.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import argparse
from ruamel.yaml import YAML
import os
from typing import Any, Dict
from libraries.common.utility_helpers import PROJECT_ROOT


class YamlConfigManager:
    """A class for managing YAML configuration files.
    python yaml_config_cli.py configs/api_test_config.yaml --update active_environment PROD --update test_cases_path "test_cases/new_test_cases.xlsx" --update clear_saved_fields_after_test False
    python yaml_config_cli.py configs/api_test_config.yaml --add-to-list tc_id_list TC001 --add-to-list tags api
    python yaml_config_cli.py configs/api_test_config.yaml --remove-from-list tags deprecated
    python yaml_config_cli.py configs/api_test_config.yaml --update active_environment PROD --add-to-list tc_id_list TC001 --remove-from-list tags deprecated
    """
    def __init__(self, file_path: str):
        self.file_path = os.path.join(PROJECT_ROOT, file_path)
        self.yaml = YAML()
        self.yaml.preserve_quotes = True
        self.yaml.indent(mapping=2, sequence=4, offset=2)
        self.config = self.load_yaml()

    def load_yaml(self) -&gt; Dict[str, Any]:
        """Load YAML configuration from the file."""
        if os.path.exists(self.file_path):
            with open(self.file_path, 'r') as file:
                return self.yaml.load(file) or {}
        return {}

    def save_yaml(self):
        """Save YAML configuration to the file."""
        with open(self.file_path, 'w') as file:
            self.yaml.dump(self.config, file)

    def update_config(self, key: str, value: Any):
        """Update the configuration for a given key with the provided value."""
        keys = key.split('.')
        current = self.config
        for k in keys[:-1]:
            if k not in current:
                current[k] = {}
            current = current[k]
        current[keys[-1]] = value
        self.save_yaml()

    def get_config(self, key: str) -&gt; Any:
        """Retrieve the configuration value for a given key."""
        keys = key.split('.')
        current = self.config
        for k in keys:
            if k not in current:
                return None
            current = current[k]
        return current

    def add_to_list(self, key: str, value: Any):
        """Add a value to the list at the given key."""
        current_list = self.get_config(key)
        if current_list is None:
            self.update_config(key, [value])
        elif isinstance(current_list, list):
            if value not in current_list:
                current_list.append(value)
                self.save_yaml()
        else:
            raise ValueError(f"The key '{key}' does not point to a list.")

    def remove_from_list(self, key: str, value: Any):
        """Remove a value from the list at the given key."""
        current_list = self.get_config(key)
        if isinstance(current_list, list):
            if value in current_list:
                current_list.remove(value)
                self.save_yaml()
        else:
            raise ValueError(f"The key '{key}' does not point to a list.")


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Manage YAML configuration file.')
    parser.add_argument('file_path', help='Path to the YAML configuration file')
    parser.add_argument('--update', nargs=2, action='append', metavar=('KEY', 'VALUE'),
                        help='Update a configuration value. Can be used multiple times.')
    parser.add_argument('--add-to-list', nargs=2, action='append', metavar=('KEY', 'VALUE'),
                        help='Add a value to a list. Can be used multiple times.')
    parser.add_argument('--remove-from-list', nargs=2, action='append', metavar=('KEY', 'VALUE'),
                        help='Remove a value from a list. Can be used multiple times.')

    args = parser.parse_args()

    yaml_manager = YamlConfigManager(args.file_path)

    if args.update:
        for key, value in args.update:
            # Try to convert the value to the appropriate type
            try:
                value = eval(value)
            except:
                pass  # If conversion fails, keep it as a string
            yaml_manager.update_config(key, value)
            print(f"Updated {key} to {value}")

    if args.add_to_list:
        for key, value in args.add_to_list:
            yaml_manager.add_to_list(key, value)
            print(f"Added {value} to list {key}")

    if args.remove_from_list:
        for key, value in args.remove_from_list:
            yaml_manager.remove_from_list(key, value)
            print(f"Removed {value} from list {key}")

    # Print the updated configuration
    print("\nUpdated configuration:")
    with open(args.file_path, 'r') as file:
        print(file.read())
</pre>
</div>


    <script>
        function copyToClipboard(button) {
            const codeContainer = button.parentElement;
            const code = codeContainer.querySelector('pre').innerText;
            navigator.clipboard.writeText(code).then(() => {
                button.innerText = 'Copied!';
                setTimeout(() => { button.innerText = 'Copy'; }, 2000);
            });
        }
        function returnToDirectory() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
    </script>
</body>
</html>
