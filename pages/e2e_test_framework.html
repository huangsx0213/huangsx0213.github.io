<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>E2E Automatic Testing Framework</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f9;
            color: #333;
        }
        .code-container, .directory-container {
            background-color: #282c34;
            color: #abb2bf;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
            overflow-x: auto;
            position: relative;
        }
        .code-container pre, .directory-container pre {
            margin: 0;
        }
        .class-header, .directory-header {
            font-size: 1.5em;
            color: #61dafb;
            margin-bottom: 10px;
        }
        .copy-button, .return-button {
            position: absolute;
            right: 20px;
            top: 20px;
            background-color: #61dafb;
            color: #282c34;
            border: none;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 3px;
            margin-left: 5px;
        }
        .return-button {
            right: 100px;
        }
        .directory a {
            color: #98c379;
            text-decoration: none;
        }
        .directory a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <h1>E2E Automatic Testing Framework</h1>
    <div class="directory-container">
        <div class="directory-header">File Directory</div>
        <pre class="directory">./
│   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_main_py">main.py</a>
│   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_README_md">README.md</a>
│   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_requirements_txt">requirements.txt</a>
│   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_yaml_config_cli_py">yaml_config_cli.py</a>
│   ├── configs/
│   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_configs_api_test_config_yaml">api_test_config.yaml</a>
│   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_configs_db_config_yaml">db_config.yaml</a>
│   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_configs_e2e_test_config_yaml">e2e_test_config.yaml</a>
│   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_configs_logging_config_yaml">logging_config.yaml</a>
│   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_configs_saved_fields_yaml">saved_fields.yaml</a>
│   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_configs_web_pt_config_yaml">web_pt_config.yaml</a>
│   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_configs_web_test_config_yaml">web_test_config.yaml</a>
│   ├── libraries/
│   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries___init___py">__init__.py</a>
│   │   ├── api/
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api_api_test_keywords_py">api_test_keywords.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api_api_test_loader_py">api_test_loader.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api_body_generator_py">body_generator.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api_headers_generator_py">headers_generator.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api_request_sender_py">request_sender.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api_response_handler_py">response_handler.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api_saved_fields_manager_py">saved_fields_manager.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api_template_renderer_py">template_renderer.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api___init___py">__init__.py</a>
│   │   ├── common/
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_common_config_manager_py">config_manager.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_common_gen_temp_default_py">gen_temp_default.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_common_log_manager_py">log_manager.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_common_utility_helpers_py">utility_helpers.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_common_variable_generator_py">variable_generator.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_common_variable_transformer_py">variable_transformer.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_common___init___py">__init__.py</a>
│   │   ├── db/
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_db_db_py">db.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_db_db_operator_py">db_operator.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_db___init___py">__init__.py</a>
│   │   ├── performance/
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_performance_web_pt_py">web_pt.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_performance_web_pt_loader_py">web_pt_loader.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_performance_web_pt_reporter_py">web_pt_reporter.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_performance_web_pt_robot_keyword_py">web_pt_robot_keyword.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_performance___init___py">__init__.py</a>
│   │   ├── robot/
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_robot_custom_action_executor_py">custom_action_executor.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_robot_robot_test_executor_py">robot_test_executor.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_robot___init___py">__init__.py</a>
│   │   │   ├── case/
│   │   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_robot_case_api_generator_py">api_generator.py</a>
│   │   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_robot_case_base_generator_py">base_generator.py</a>
│   │   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_robot_case_e2e_generator_py">e2e_generator.py</a>
│   │   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_robot_case_unified_generator_py">unified_generator.py</a>
│   │   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_robot_case_web_generator_py">web_generator.py</a>
│   │   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_robot_case_web_pt_robot_generator_py">web_pt_robot_generator.py</a>
│   │   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_robot_case___init___py">__init__.py</a>
│   │   ├── web/
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_webdriver_factory_py">webdriver_factory.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_actions_py">web_actions.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_test_loader_py">web_test_loader.py</a>
│   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web___init___py">__init__.py</a>
│   │   │   ├── web_action/
│   │   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_alert_actions_py">alert_actions.py</a>
│   │   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_base_py">base.py</a>
│   │   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_cookie_actions_py">cookie_actions.py</a>
│   │   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_decorators_py">decorators.py</a>
│   │   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_element_actions_py">element_actions.py</a>
│   │   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_javascript_actions_py">javascript_actions.py</a>
│   │   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_js_py">js.py</a>
│   │   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_navigation_actions_py">navigation_actions.py</a>
│   │   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_table_actions_py">table_actions.py</a>
│   │   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_table_verifier_py">table_verifier.py</a>
│   │   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_utils_actions_py">utils_actions.py</a>
│   │   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_verification_actions_py">verification_actions.py</a>
│   │   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_wait_actions_py">wait_actions.py</a>
│   │   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_window_actions_py">window_actions.py</a>
│   │   │   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action___init___py">__init__.py</a>
│   ├── templates/
│   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_templates_rf_report_template_html">rf_report_template.html</a>
│   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_templates_test_summary_template_html">test_summary_template.html</a>
│   ├── testing_server/
│   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_testing_server_positions_json">positions.json</a>
│   │   ├── <a href="#C:_Users_vhuang1_PycharmProjects_api_test_framework_testing_server_server_py">server.py</a>
</pre>
    </div>
    <div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_README_md">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\README.md</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre># Automated Testing Framework User Manual

## Table of Contents
1. Framework Features
2. Installation and Setup
3. Configuration
4. API Test Cases Excel Structure
5. Web UI Test Cases Excel Structure
6. Writing Test Cases
7. Running Tests
8. Viewing Results
9. Best Practices
10. Troubleshooting
11. Advanced Features
12. Maintenance and Updates

## 1. Framework Features

This automated testing framework offers the following features:

1. Multi-type Testing Support: Supports API testing, Web UI testing, and End-to-End (E2E) testing.
2. Flexible Configuration: Uses YAML files for configuration, making it easy to modify and maintain.
3. Data-Driven: Manages test cases using Excel files, supporting parameterized testing.
4. Dynamic Value Support: Supports dynamically generated values in API tests, such as UUID, timestamps, etc.
5. Variable Management: Supports sharing and reusing variables between test cases.
6. Page Object Model: Uses page object pattern in Web UI testing, improving code reusability and maintainability.
7. Custom Operations: Supports defining and using custom Python operations in Web UI tests.
8. Detailed Logs and Reports: Generates detailed HTML reports and logs, including failure screenshots.
9. Flexible Test Case Selection: Supports filtering specific tests by tags or test case IDs.
10. Environment Management: Supports multi-environment configuration, making it easy to switch between different environments.
11. Error Handling and Retry Mechanism: Implements robust error handling and test retry logic.
12. CI-Friendly: Easy to integrate into CI/CD processes.
13. Extensibility: Modular framework design, easy to add new features and customize.
14. Sanity Check Feature: Supports automatic skipping of subsequent tests if a designated sanity check test fails.

## 2. Installation and Setup

### 2.1 Python and pip

Ensure you have Python 3.7 or higher installed. You can download it from [python.org](https://www.python.org/downloads/).

### 2.2 Required Python Packages

Install the required packages using pip:

```bash
pip install -r requirements.txt
```

The `requirements.txt` file should include (but is not limited to):

```
robot-framework
requests
pandas
openpyxl
pyyaml
jinja2
jsonpath-ng
lxml
selenium
pillow
numpy
```

### 2.3 WebDriver Setup

For Web UI testing, ensure you have the appropriate WebDriver installed and configured in your system PATH:
- ChromeDriver for Google Chrome
- EdgeDriver for Microsoft Edge

### 2.4 Project Structure

Ensure your project follows this structure:
```
project_root/
├── configs/
│   ├── api_test_config.yaml
│   ├── web_test_config.yaml
│   ├── e2e_test_config.yaml
│   └── logging_config.yaml
├── libraries/
│   ├── api/
│   ├── web/
│   ├── e2e/
│   ├── robot/
│   └── common/
├── test_cases/
│   ├── api_test_cases.xlsx
│   ├── web_test_cases.xlsx
│   └── e2e_test_cases.xlsx
├── templates/
│   └── rf_report_template.html
├── report/
├── main.py
├── yaml_config_cli.py
└── requirements.txt
```

## 3. Configuration

### 3.1 API Test Configuration (api_test_config.yaml)

```yaml
active_environment: DEV
test_cases_path: 'test_cases/api_test_cases.xlsx'
clear_saved_fields_after_test: true
tc_id_list: []
tags: []
```

- `active_environment`: Currently active test environment (e.g., DEV, SIT, UAT, PROD)
- `test_cases_path`: Path to the API test cases Excel file
- `clear_saved_fields_after_test`: Whether to clear saved fields after each test
- `tc_id_list`: List of specific test case IDs to execute
- `tags`: List of tags to filter test cases

### 3.2 Web UI Test Configuration (web_test_config.yaml)

```yaml
active_environment: SIT
test_case_path: 'test_cases/web_test_cases.xlsx'
tc_id_list: []
tags: []
```

- `active_environment`: Currently active test environment
- `test_case_path`: Path to the Web UI test cases Excel file
- `tc_id_list`: List of specific test case IDs to execute
- `tags`: List of tags to filter test cases

### 3.3 End to end Test Configuration (e2e_test_config.yaml)

```yaml
active_environment: SIT
test_case_path: 'test_cases/e2e_test_cases.xlsx'
tc_id_list: []
tags: []
```

- `active_environment`: Currently active test environment
- `test_case_path`: Path to the End-to-End test cases Excel file
- `tc_id_list`: List of specific test case IDs to execute
- `tags`: List of tags to filter test cases
- 
### 3.4 Using yaml_config_cli.py

You can use the `yaml_config_cli.py` script to modify configuration files from the command line. For example:

```bash
python yaml_config_cli.py configs/api_test_config.yaml --update active_environment PROD
python yaml_config_cli.py configs/api_test_config.yaml --add-to-list tc_id_list TC001
python yaml_config_cli.py configs/api_test_config.yaml --remove-from-list tags deprecated
```

## 4. API Test Cases Excel Structure

### 4.1 Sheets:
1. API: Main test case information
2. BodyTemplates: Request body templates
3. BodyDefaults: Default values for request bodies
4. Headers: Header templates
5. Endpoints: Environment-specific endpoint configurations

### 4.2 API Sheet Columns:
| Column Name | Description | Possible Values | Logic |
|-------------|-------------|-----------------|-------|
| TCID | Unique test case identifier | String, e.g., "TC001" | Must be unique |
| Name | Test case name | String | Descriptive name |
| Descriptions | Test case description | String | Detailed explanation of test purpose |
| Run | Whether to execute this case | "Y" or "N" | Y means execute, N means skip |
| Tags | Case tags | Comma-separated string | For categorizing and filtering cases |
| Endpoint | API endpoint name | String | Must match definitions in Endpoints sheet |
| Headers | Request header template name | String | Must match definitions in Headers sheet |
| Body Template | Request body template name | String | Must match definitions in BodyTemplates sheet |
| Body Default | Default request body name | String | Must match definitions in BodyDefaults sheet |
| Body Override | Custom request body fields | JSON format string | Overrides or adds to default request body |
| Exp Result | Expected results | JSONPath expressions | Used to validate response content |
| Save Fields | Save response fields | JSONPath expressions | Used to save specific fields from the response |
| Conditions | Special conditions | Specific format string | E.g., [Checkwith], [TestSetup], [TestTeardown] |
| Wait | Wait time after test execution | Number (seconds) | Pause execution for specified time |

#### Sanity Check:
To designate a test case as a sanity check:
1. In the 'Tags' column of the API sheet, include the tag 'sanity check' (case-insensitive).
2. If a test case with the 'sanity check' tag fails, all subsequent test cases will be automatically skipped.

Example:
```
TCID | Name           | ... | Tags
-----|----------------|-----|----------------
TC001| Sanity Check   | ... | critical, sanity check
TC002| Regular Test   | ... | regression
```

### 4.3 BodyTemplates Sheet:
| Column Name | Description | Possible Values | Logic |
|-------------|-------------|-----------------|-------|
| TemplateName | Template name | String | Unique identifier |
| Content | Template content | JSON or XML format string | Can include Jinja2 template syntax |
| Format | Template format | "json" or "xml" | Specifies the format of the template |

### 4.4 BodyDefaults Sheet:
| Column Name | Description | Possible Values | Logic |
|-------------|-------------|-----------------|-------|
| Name | Default value name | String | Unique identifier |
| Content | Default value content | JSON format string | Provides default request body content |

### 4.5 Headers Sheet:
| Column Name | Description | Possible Values | Logic |
|-------------|-------------|-----------------|-------|
| HeaderName | Header template name | String | Unique identifier |
| Content | Header content | YAML format string | Defines request headers |

### 4.6 Endpoints Sheet:
| Column Name | Description | Possible Values | Logic |
|-------------|-------------|-----------------|-------|
| Environment | Environment name | DEV, SIT, UAT, PROD, etc. | Corresponds to active_environment in config file |
| Endpoint | Endpoint name | String | Unique identifier |
| Method | HTTP method | GET, POST, PUT, DELETE, PATCH | Specifies request method |
| Path | Request path | URL path string | Can include path parameters |

## 5. Web UI Test Cases Excel Structure

### 5.1 Sheets:
1. TestCases: Main test case information
2. TestSteps: Steps for each test case
3. TestData: Test data for parameterization
4. Locators: Element locators
5. PageModules: Page object definitions
6. WebEnvironments: Environment-specific configurations
7. CustomActions: Custom Python actions

### 5.2 TestCases Sheet:
| Column Name | Description | Possible Values | Logic |
|-------------|-------------|-----------------|-------|
| Case ID | Unique test case identifier | String, e.g., "UITC001" | Must be unique |
| Name | Test case name | String | Descriptive name |
| Descriptions | Test case description | String | Detailed explanation of test purpose |
| Run | Whether to execute this case | "Y" or "N" | Y means execute, N means skip |
| Tags | Case tags | Comma-separated string | For categorizing and filtering cases |

#### Sanity Check:
To designate a test case as a sanity check:
1. In the 'Tags' column of the TestCases sheet, include the tag 'sanity check' (case-insensitive).
2. If a test case with the 'sanity check' tag fails, all subsequent test cases will be automatically skipped.

Example:
```
Case ID | Name           | ... | Tags
--------|----------------|-----|----------------
UITC001 | Sanity Check   | ... | critical, sanity check
UITC002 | Regular Test   | ... | regression
```

### 5.3 TestSteps Sheet:
| Column Name | Description | Possible Values | Logic |
|-------------|-------------|-----------------|-------|
| Case ID | Corresponding test case ID | String | Must match Case ID in TestCases |
| Step ID | Unique identifier for each step | Integer | Defines execution order of steps |
| Page Name | Page object name | String | Must match definitions in PageModules |
| Module Name | Module name | String | Specific module within the page object |
| Run | Whether to execute this step | "Y" or "N" | Y means execute, N means skip |

### 5.4 TestData Sheet:
| Column Name | Description | Possible Values | Logic |
|-------------|-------------|-----------------|-------|
| Case ID | Corresponding test case ID | String | Must match Case ID in TestCases |
| Data Set | Data set identifier | String | Used to distinguish multiple sets of test data |
| Parameter Name | Parameter name | String | Corresponds to parameters in TestSteps |
| Value | Parameter value | Any type | Actual test data |
| Data Type | Data type | string, integer, json, etc. | Specifies the data type of the parameter |

### 5.5 Locators Sheet:
| Column Name | Description | Possible Values | Logic |
|-------------|-------------|-----------------|-------|
| Page | Page name | String | Corresponds to pages in PageModules |
| Element Name | Element name | String | Unique identifier |
| Locator Type | Location method | id, name, xpath, css, etc. | Selenium-supported location methods |
| Locator Value | Location value | String | Specific location expression |

### 5.6 PageModules Sheet:
| Column Name | Description | Possible Values | Logic |
|-------------|-------------|-----------------|-------|
| Page Name | Page name | String | Unique identifier |
| Module Name | Module name | String | Functional module within the page |
| Element Name | Element name | String | Corresponds to Element Name in Locators |
| Actions | Action name | String | E.g., click, input, verify, etc. |
| Parameter Name | Parameters | Comma-separated string | Parameters needed for the action |
| Highlight | Whether to highlight the element | "Y" or "N" | Y means highlight, N means don't highlight |
| Screenshot | Whether to take a screenshot | "Y" or "N" | Y means take screenshot, N means don't |
| Wait | Wait time after action (in seconds) | Number | Pause execution for specified time |
| Run | Whether to execute this action | "Y" or "N" | Y means execute, N means skip |

### 5.7 WebEnvironments Sheet:
| Column Name | Description | Possible Values | Logic |
|-------------|-------------|-----------------|-------|
| Environment | Environment name | DEV, SIT, UAT, PROD, etc. | Corresponds to active_environment in config file |
| URL | Environment URL | Complete URL string | Base URL of the test environment |
| Browser | Browser type | chrome, firefox, edge, etc. | Specifies the browser to use |

### 5.8 CustomActions Sheet:
| Column Name   | Description              | Possible Values | Logic |
|---------------|--------------------------|-----------------|-------|
| Action Name   | Custom action name       | String | Unique identifier |
| CustomAction1 | CustomAction python code | String | Custom python to be executed |

## 6. Writing Test Cases

### 6.1 API Test Cases

1. Fill in the API sheet with test case details.
2. Create body templates in the BodyTemplates sheet.
3. Define default body values in the BodyDefaults sheet.
4. Create header templates in the Headers sheet.
5. Define endpoints in the Endpoints sheet.

#### Body-related fields:
- Body Template: Use Jinja2 syntax for dynamic values.
- Body Default: Provide default values in JSON format.
- Body Override: Override default values or add new fields in JSON format.
  - Supports dynamic values using `${variable_name}` syntax.
  - These variables are replaced with actual values from the Robot Framework variable scope.
- Use `{{variable_name}}` in templates for dynamic values.
- Supported dynamic values: uetr, uuid4, value_date, msg_id, timestamp, formated_timestamp, bic

#### Expected Results:
- Exp Result: Define expected results for assertions.
  - Supports dynamic values using `${variable_name}` syntax.
  - These variables are replaced with actual values from the Robot Framework variable scope.
- Use JSONPath for precise assertions on the response.

#### Headers:
- Define headers in YAML format in the Headers sheet.
- Use `{{variable_name}}` for dynamic values.
- Use `${variable_name}` for Robot Framework variables.

#### Example of using dynamic values:
```
Body Override: {"user_id": "${USER_ID}", "timestamp": "{{timestamp}}"}
Exp Result: $.response.status=${EXPECTED_STATUS}
```

### 6.2 Web UI Test Cases

1. Fill in the TestCases sheet with test case details.
2. Define test steps in the TestSteps sheet.
3. Provide test data in the TestData sheet.
4. Define element locators in the Locators sheet.
5. Create page objects and modules in the PageModules sheet.
6. Configure environments in the WebEnvironments sheet.
7. Define custom actions in the CustomActions sheet if needed.

## 7. Running Tests

### 7.1 API Tests
```bash
python main.py --api
```

### 7.2 Web UI Tests
```bash
python main.py --web
```

### 7.3 E2E Tests
```bash
python main.py --e2e
```

### 7.4 Running Specific Test Cases or Tags

You can specify test case IDs or tags in the respective configuration files (api_test_config.yaml, web_test_config.yaml, e2e_test_config.yaml) to run specific tests.

## 8. Viewing Results

- Test results are generated in the `report` folder.
- Open `report.html` for a detailed test report.
- Check `log.html` for step-by-step execution logs.
- Screenshots for Web UI tests are embedded in the logs.
- A custom dashboard (dashboard.html) is generated with test statistics and charts.

## 9. Best Practices

1. Use meaningful test case IDs and names.
2. Leverage tags for easy filtering and organization.
3. Maintain clear and concise test step descriptions.
4. Regularly update and maintain test data.
5. Keep locators and page objects up-to-date with the application.
6. Use parameterization to create data-driven tests.
7. Implement proper error handling and logging in test scripts.
8. Regularly review and optimize test suites for efficiency.
9. Use the 'sanity check' tag for critical tests that, if failed, should prevent further testing.
10. Order your test cases so that sanity checks run first, followed by other tests.

## 10. Troubleshooting

- Check log files for detailed error messages.
- Verify configuration files for correct settings.
- Ensure all required dependencies are installed.
- Validate Excel file structure and content.
- Check for proper WebDriver setup for Web UI tests.
- If you encounter "ModuleNotFoundError", ensure you've installed all required packages (see Section 2.2).

## 11. Advanced Features

### 11.1 Dynamic Values in API Tests

The framework supports the use of dynamic values in two key areas of API tests:

1. Body Override
2. Expected Results (Exp Result)

#### Usage:
- Use the syntax `${variable_name}` in these fields to reference Robot Framework variables.
- These variables will be dynamically replaced with their actual values during test execution.
- This feature allows for more flexible and reusable test cases, especially when combined with Robot Framework's variable management capabilities.

#### Example:
```yaml
Body Override: {"token": "${AUTH_TOKEN}", "user_id": "${CURRENT_USER_ID}"}
Exp Result: $.status_code=200
$.response.user.name=${EXPECTED_USER_NAME}
```

### 11.2 Custom Python Actions in Web UI Tests

You can define custom Python actions in the CustomActions sheet of the Web UI test cases Excel file. These actions can be called from your test steps to perform complex operations or validations.

### 11.3 Sanity Check Implementation

The framework now supports a 'sanity check' feature:

- Tests tagged with 'sanity check' (case-insensitive) are treated as critical tests.
- If a sanity check test fails, all subsequent tests in the suite will be automatically skipped.
- This feature helps to quickly identify fundamental issues and saves time by not running further tests when basic functionality fails.

To use this feature:
1. Add the tag 'sanity check' to critical test cases in your Excel file.
2. Run your test suite as usual.
3. If a sanity check fails, you'll see skip messages for subsequent tests in the logs.

Example log output when a sanity check fails:
```
FAIL: Sanity Check Test
SKIP: Subsequent Test 1 - Skip current test TC002 due to Sanity Check failure
SKIP: Subsequent Test 2 - Skip current test TC003 due to Sanity Check failure
```

This feature is automatically enabled and requires no additional configuration beyond tagging your tests appropriately.

## 12. Maintenance and Updates

- Regularly update your Python packages to ensure compatibility and security:
  ```bash
  pip install --upgrade -r requirements.txt
  ```
- Keep your WebDrivers up-to-date with your browser versions.
- Periodically review and update your test cases to align with application changes.
- Consider version controlling your test cases and configurations for better tracking and collaboration.
- Implement a process for reviewing and updating test data to ensure it remains relevant and effective.
- Regularly backup your test artifacts, including Excel files, configurations, and custom scripts.
- Set up automated jobs to run your test suites on a scheduled basis, ensuring continuous validation of your application.

This comprehensive guide provides a complete overview of the automated testing framework, including setup, configuration, test case creation, execution, and maintenance. It covers both API and Web UI testing scenarios, as well as advanced features like dynamic value handling in API tests. By following this guide, users should be able to effectively leverage the framework for their testing needs.
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_configs_api_test_config_yaml">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\configs\api_test_config.yaml</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre># The active environment to be used for the tests.
# This should match one of the environment keys defined below in 'environments'.
active_environment: DEV
# Path to the excel file containing the test cases.
test_cases_path: 'test_cases/api_test_cases.xlsx'
clear_saved_fields_after_test: false
# List of Test Case IDs to run.
# Specify one or more Test Case IDs here.
# If this list is empty, all test cases will be run.
tc_id_list:


# List of tags to filter test cases.
# Only test cases which contain any of these tags will be run.
# If this list is empty, all test cases will be run.
tags:</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_configs_db_config_yaml">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\configs\db_config.yaml</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>database:
  DEV:
    db_name1:
      type: postgresql  # or oracle
      schema: public
      user: vhuang1
      password: Apj.com1
      host: 10.191.111.77
      port: 5432
      database: postgres
    db_name2:
      type: postgresql
      schema: public
      user: vhuang1
      password: Apj.com1
      host: 10.191.111.77
      port: 5432
      database: postgres
  UAT:
    db_name1:
      type: oracle
      user: uat_user
      password: uat_password
      host: uat_host
      port: 1521
      service_name: uat_service_name
      min_connections: 1
      max_connections: 10
    db_name2:
      type: oracle
      user: uat_user
      password: uat_password
      host: uat_host
      port: 1521
      service_name: uat_service_name
      min_connections: 1
      max_connections: 10
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_configs_e2e_test_config_yaml">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\configs\e2e_test_config.yaml</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>active_environment: DEV
test_cases_path : test_cases/e2e_test_cases.xlsx
# List of Test Case IDs to run.
# Specify one or more Test Case IDs here.
# If this list is empty, all test cases will be run.
tc_id_list:
# List of tags to filter test cases.
# Only test cases which contain any of these tags will be run.
# If this list is empty, all test cases will be run.
tags:
  - tag1
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_configs_logging_config_yaml">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\configs\logging_config.yaml</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>version: 1
disable_existing_loggers: False

formatters:
  standard:
    format: "%(asctime)s - %(name)s - %(levelname)s - %(message)s"

handlers:
  console:
    class: logging.StreamHandler
    formatter: standard
    level: DEBUG
    stream: ext://sys.stdout
  file:
    class: logging.FileHandler
    formatter: standard
    level: DEBUG
    mode: "w"


root:
  level: INFO
  handlers: [console,file]</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_configs_saved_fields_yaml">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\configs\saved_fields.yaml</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>MyToken: vt9EoVlxRKGWWMwx6iJoaGQQLlvAE4zXwuOTfeXKHZFaqO9US2iudZ5B5-BtFFS_3t3mrFKLj2oPo5aEw2rQ0wudQo9b6JRbB4LV0LbzQMrbWFA-EXfhMg==</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_configs_web_pt_config_yaml">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\configs\web_pt_config.yaml</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>active_environment: SIT
test_cases_path : test_cases/web_pt_cases.xlsx
# List of Test Case IDs to run.
# Specify one or more Test Case IDs here.
# If this list is empty, all test cases will be run.
tc_id_list:

# List of tags to filter test cases.
# Only test cases which contain any of these tags will be run.
# If this list is empty, all test cases will be run.
tags:

</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_configs_web_test_config_yaml">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\configs\web_test_config.yaml</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>active_environment: SIT
test_cases_path : test_cases/web_test_cases.xlsx
# List of Test Case IDs to run.
# Specify one or more Test Case IDs here.
# If this list is empty, all test cases will be run.
tc_id_list:

# List of tags to filter test cases.
# Only test cases which contain any of these tags will be run.
# If this list is empty, all test cases will be run.
tags:

</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries___init___py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\__init__.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre></pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api___init___py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\api\__init__.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre></pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api_api_test_keywords_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\api\api_test_keywords.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import logging
import os
import re
from time import sleep
from typing import Dict, List
import pandas as pd
from libraries.common.config_manager import ConfigManager
from libraries.db.db_operator import DBOperator
from libraries.common.utility_helpers import PROJECT_ROOT
from libraries.api.request_sender import RequestSender
from libraries.api.body_generator import BodyGenerator
from libraries.api.headers_generator import HeadersGenerator
from libraries.api.saved_fields_manager import SavedFieldsManager
from libraries.api.response_handler import ResponseValidator, ResponseFieldSaver
from libraries.api.api_test_loader import APITestLoader
from robot.libraries.BuiltIn import BuiltIn
from robot.api.deco import keyword, library

builtin_lib = BuiltIn()


@library
class APITestKeywords:
    ROBOT_LIBRARY_SCOPE = 'TEST SUITE'

    def __init__(self, test_config_path: str = None, test_cases_path: str = None) -&gt; None:
        self.project_root: str = PROJECT_ROOT
        self._load_configuration(test_config_path, test_cases_path)
        self._initialize_components()

    def _load_configuration(self, test_config_path, test_cases_path):

        self.test_config_path = test_config_path or os.path.join(self.project_root, 'configs', 'api_test_config.yaml')

        self.test_config: Dict = ConfigManager.load_yaml(self.test_config_path)
        self.db_configs: Dict = ConfigManager.load_yaml(os.path.join(self.project_root, 'configs', 'db_config.yaml'))

        default_test_cases_path: str = os.path.join('test_cases', 'api_test_cases.xlsx')
        self.test_cases_path: str = test_cases_path or os.path.join(self.project_root, self.test_config.get('test_cases_path', default_test_cases_path))

        self.active_environment = self.test_config['active_environment']
        builtin_lib.set_global_variable('${active_environment}', self.active_environment)
        self.active_db_configs = self.db_configs.get('database', {}).get(self.active_environment, {})
        if not self.active_db_configs:
            raise ValueError(f"No database configuration for environment: {self.active_environment}")

    def _load_endpoints(self):
        endpoints = self.api_test_loader.get_endpoints()
        self.endpoints = {}
        for _, row in endpoints[endpoints['Environment'] == self.active_environment].iterrows():
            self.endpoints[row['Endpoint']] = {
                'method': row['Method'],
                'path': row['Path']
            }

    def _initialize_components(self):
        self.saved_fields_manager: SavedFieldsManager = SavedFieldsManager()
        self.api_test_loader = APITestLoader(self.test_cases_path)
        self._load_endpoints()
        self.body_generator: BodyGenerator = BodyGenerator(self.api_test_loader)
        self.headers_generator: HeadersGenerator = HeadersGenerator(self.api_test_loader)
        self.api_response_validator: ResponseValidator = ResponseValidator(self.active_db_configs)
        self.response_field_saver: ResponseFieldSaver = ResponseFieldSaver()
        self.db_validator = DBOperator()

    @keyword
    def api_sanity_check(self) -&gt; None:
        skip_on_sanity_check_failure = BuiltIn().get_variable_value('${skip_on_sanity_check_failure}', default=False)
        if skip_on_sanity_check_failure:
            BuiltIn().skip("Skipping current test as sanity check failed.")
        else:
            logging.info(f"{self.__class__.__name__}: Sanity check succeeded, continuing with the test.")

    @keyword
    def suite_teardown(self):
        self.clear_save_fields()

    def clear_save_fields(self):
        if self.test_config.get('clear_saved_fields_after_test', False):
            self.saved_fields_manager.clear_saved_fields()
            logging.info(f"{self.__class__.__name__}: Cleared saved fields")

    @keyword
    def execute_conditions_cases(self, conditions_case_ids: List[str] = None):
        results = {}
        for tcid in conditions_case_ids:
            logging.info(f"{self.__class__.__name__}: Executing test case: {tcid}")
            result = self.execute_api_test_case(tcid)
            results[tcid] = result
        return results

    @keyword
    def execute_api_test_case(self, test_case_id: str, is_dynamic_check: bool = False):
        try:
            test_cases = APITestLoader(self.test_cases_path).get_api_test_cases()
            test_case = next((tc for _, tc in test_cases.iterrows() if tc['TCID'] == test_case_id), None)

            if test_case is None:
                raise ValueError(f"{self.__class__.__name__}: Test case with ID {test_case_id} not found.")

            check_with_tcids = self._extract_check_with_tcids(test_case)

            if check_with_tcids:
                pre_check_responses = self._execute_check_with_cases(check_with_tcids)
                response, execution_time = self._execute_single_test_case(test_case)
                logging.info("============================================")
                post_check_responses = self._execute_check_with_cases(check_with_tcids)
                self.api_response_validator.validate(test_case, response, pre_check_responses, post_check_responses)
            else:
                response, execution_time = self._execute_single_test_case(test_case)
                self.api_response_validator.validate(test_case, response)

            logging.info(f"{self.__class__.__name__}: Finished execution of test case {test_case_id}")
            logging.info("============================================")

            return True if not is_dynamic_check else (response, execution_time)
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Failed to execute test case {test_case_id}: {str(e)}")
            raise e

    def _execute_single_test_case(self, test_case):
        response, execution_time = self.send_request(test_case)
        logging.info(f"{self.__class__.__name__}: Time taken to execute test case {test_case['TCID']}: {execution_time:.2f} seconds")
        self.response_field_saver.save_fields_to_robot_variables(response, test_case)
        wait = float(test_case['Wait']) if test_case['Wait'] != '' else 0
        if wait &gt; 0:
            sleep(wait)
            logging.info(f"{self.__class__.__name__}: Waiting for results of {test_case['TCID']} in {wait} seconds.")

        return response, execution_time

    def _extract_check_with_tcids(self, test_case):
        conditions = test_case['Conditions']
        if pd.isna(conditions):
            return []

        check_with_match = re.search(r'\[CheckWith\](.*)', conditions)
        if check_with_match:
            return [tcid.strip() for tcid in check_with_match.group(1).split(',')]
        return []

    def _execute_check_with_cases(self, check_with_tcids):
        responses = {}
        for tcid in check_with_tcids:
            logging.info(f"{self.__class__.__name__}: Executing test case {tcid} for dynamic check")
            response, _ = self.execute_api_test_case(tcid, is_dynamic_check=True)
            responses[tcid] = response
        return responses

    def send_request(self, test_case):
        ex_endpoint = test_case['Endpoint']
        current_endpoint = self.endpoints.get(ex_endpoint, None)
        if current_endpoint is None:
            raise Exception(f"{self.__class__.__name__}: Endpoint {ex_endpoint} not found in config file")
        method: str = current_endpoint['method']
        url: str = current_endpoint['path']

        saved_fields = self.saved_fields_manager.load_saved_fields()
        headers = self.headers_generator.prepare_headers(test_case, saved_fields)
        self.saved_fields_manager.apply_saved_fields(test_case, saved_fields)
        self.saved_fields_manager.apply_suite_variables(test_case)
        body, format_type = self.body_generator.generate_request_body(test_case, method)

        logging.info(f"{self.__class__.__name__}: Sending request to {url} with method: {method} for test step {test_case['TCID']}.")
        response, execution_time = RequestSender.send_request(url, method, headers, body, format_type)

        return response, execution_time
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api_api_test_loader_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\api\api_test_loader.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import json
import logging
import pandas as pd
import yaml
from typing import List, Dict

class APITestLoader:
    _instances = {}

    def __new__(cls, excel_path: str):
        if excel_path not in cls._instances:
            instance = super().__new__(cls)
            instance.__init__(excel_path)
            cls._instances[excel_path] = instance
        return cls._instances[excel_path]

    def __init__(self, excel_path: str):
        if hasattr(self, 'initialized'):
            return
        self.excel_path = excel_path
        self.data: Dict[str, pd.DataFrame] = {}
        self._load_all_excel_data()
        self.validate_excel_structure()
        self.initialized = True

    def _load_all_excel_data(self):
        try:
            excel_file = pd.ExcelFile(self.excel_path)
            for sheet_name in excel_file.sheet_names:
                self.data[sheet_name] = excel_file.parse(sheet_name).fillna('')
            excel_file.close()
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error loading Excel file: {e}")
            raise ValueError(f"Error loading Excel file: {e}")

    def validate_excel_structure(self):
        required_sheets = ['API', 'BodyTemplates', 'BodyDefaults', 'Headers', 'Endpoints']
        missing_sheets = set(required_sheets) - set(self.data.keys())
        if missing_sheets:
            logging.error(f"{self.__class__.__name__}: Missing required sheets: {', '.join(missing_sheets)}")
            raise ValueError(f"Missing required sheets: {', '.join(missing_sheets)}")

        for sheet_name, df in self.data.items():
            self.validate_sheet_data(sheet_name, df)

    def get_data(self, sheet_name: str) -&gt; pd.DataFrame:
        if sheet_name not in self.data:
            raise ValueError(f"Sheet '{sheet_name}' not found in the Excel file")
        return self.data[sheet_name]

    def get_api_test_cases(self) -&gt; pd.DataFrame:
        return self.get_data('API')

    def get_body_templates(self) -&gt; pd.DataFrame:
        return self.get_data('BodyTemplates')

    def get_body_defaults(self) -&gt; pd.DataFrame:
        return self.get_data('BodyDefaults')

    def get_headers(self) -&gt; pd.DataFrame:
        return self.get_data('Headers')

    def get_endpoints(self) -&gt; pd.DataFrame:
        return self.get_data('Endpoints')

    def filter_cases(self, tcid_list: List[str] = None, tags: List[str] = None) -&gt; pd.DataFrame:
        test_cases = self.get_api_test_cases()

        if tcid_list:
            test_cases = test_cases[test_cases['TCID'].isin(tcid_list)]

        if tags:
            test_cases = test_cases[test_cases['Tags'].apply(lambda x: any(tag in str(x).split(',') for tag in tags))]

        return test_cases[test_cases['Run'] == 'Y']

    def validate_sheet_data(self, sheet_name: str, df: pd.DataFrame):
        validation_methods = {
            'API': self._validate_api_sheet,
            'BodyTemplates': self._validate_body_templates_sheet,
            'BodyDefaults': self._validate_body_defaults_sheet,
            'Headers': self._validate_headers_sheet,
            'Endpoints': self._validate_endpoints_sheet
        }
        if sheet_name in validation_methods:
            validation_methods[sheet_name](df)

    def _validate_api_sheet(self, df: pd.DataFrame):
        required_columns = ['TCID', 'Run', 'Suite', 'Endpoint', 'Body Template', 'Body Default', 'Body Override', 'Headers', 'Exp Result']
        self._check_required_columns(df, required_columns, 'API')

        if df['TCID'].duplicated().any():
            raise ValueError("Duplicate TCID found in API sheet")

        if not df['Run'].isin(['Y', 'N']).all():
            raise ValueError("Invalid values in 'Run' column. Only 'Y' or 'N' are allowed.")

        for _, row in df.iterrows():
            self._validate_api_row(row)

    def _validate_api_row(self, row: pd.Series):
        method = self.get_endpoints().loc[self.get_endpoints()['Endpoint'] == row['Endpoint'], 'Method'].iloc[0]

        # Validate references to other sheets
        self._validate_sheet_reference(row['Body Template'], 'BodyTemplates', 'TemplateName', row['TCID'])
        self._validate_sheet_reference(row['Body Default'], 'BodyDefaults', 'Name', row['TCID'])
        self._validate_sheet_reference(row['Headers'], 'Headers', 'HeaderName', row['TCID'])
        self._validate_sheet_reference(row['Endpoint'], 'Endpoints', 'Endpoint', row['TCID'])

        # Validate mandatory fields based on HTTP method
        if method in ['GET', 'DELETE']:
            mandatory_fields = ['TCID', 'Endpoint', 'Headers', 'Exp Status']
        else:
            mandatory_fields = ['TCID', 'Endpoint', 'Body Template', 'Body Default', 'Headers', 'Exp Status']

        for field in mandatory_fields:
            if pd.isna(row[field]) or row[field] == '':
                raise ValueError(f"Empty value found in mandatory column '{field}' for TCID '{row['TCID']}' in API sheet")

    def _validate_body_templates_sheet(self, df: pd.DataFrame):
        required_columns = ['TemplateName', 'Content', 'Format']
        self._check_required_columns(df, required_columns, 'BodyTemplates')

        if df['TemplateName'].duplicated().any():
            raise ValueError("Duplicate TemplateName found in BodyTemplates sheet")

        if not df['Format'].isin(['json', 'xml']).all():
            raise ValueError("Invalid values in 'Format' column. Only 'json' or 'xml' are allowed.")

    def _validate_body_defaults_sheet(self, df: pd.DataFrame):
        required_columns = ['Name', 'Content']
        self._check_required_columns(df, required_columns, 'BodyDefaults')

        if df['Name'].duplicated().any():
            raise ValueError("Duplicate Name found in BodyDefaults sheet")

        for _, row in df.iterrows():
            try:
                yaml.safe_load(row['Content'])
            except yaml.YAMLError as e:
                raise ValueError(f"Invalid YAML in BodyDefaults sheet for Name: {row['Name']}. Error: {e}")

    def _validate_headers_sheet(self, df: pd.DataFrame):
        required_columns = ['HeaderName', 'Content']
        self._check_required_columns(df, required_columns, 'Headers')

        if df['HeaderName'].duplicated().any():
            raise ValueError("Duplicate HeaderName found in Headers sheet")

        for _, row in df.iterrows():
            try:
                yaml.safe_load(row['Content'])
            except yaml.YAMLError:
                raise ValueError(f"Invalid YAML in Headers sheet for HeaderName: {row['HeaderName']}")

    def _validate_endpoints_sheet(self, df: pd.DataFrame):
        required_columns = ['Environment', 'Endpoint', 'Method', 'Path']
        self._check_required_columns(df, required_columns, 'Endpoints')

        if df.duplicated(subset=['Environment', 'Endpoint']).any():
            raise ValueError("Duplicate Environment-Endpoint combination found in Endpoints sheet")

        valid_methods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH']
        if not df['Method'].isin(valid_methods).all():
            raise ValueError(f"Invalid values in 'Method' column. Allowed values are: {', '.join(valid_methods)}")

    def _check_required_columns(self, df: pd.DataFrame, required_columns: List[str], sheet_name: str):
        missing_columns = set(required_columns) - set(df.columns)
        if missing_columns:
            raise ValueError(f"Missing required columns in {sheet_name} sheet: {', '.join(missing_columns)}")

    def _validate_sheet_reference(self, value: str, sheet_name: str, column_name: str, tcid: str):
        if value:
            referenced_sheet = self.get_data(sheet_name)
            if value not in referenced_sheet[column_name].values:
                raise ValueError(f"Referenced value '{value}' in '{sheet_name}' sheet not found for TCID '{tcid}'")</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api_body_generator_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\api\body_generator.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import json
import logging
import re

from typing import Any, Dict, Union

import yaml

from libraries.common.utility_helpers import UtilityHelpers
from libraries.api.template_renderer import TemplateRenderer
from libraries.common.variable_generator import VariableGenerator


class BodyGenerator:
    def __init__(self, api_test_loader):
        self.api_test_loader = api_test_loader
        self.format_json = UtilityHelpers.format_json
        self.format_xml = UtilityHelpers.format_xml

    def generate_request_body(self, test_case, method) -&gt; (Union[Dict, str], str):
        try:
            if method in ['GET', 'DELETE']:
                return {}, 'json'

            template_content, template_format = self.load_template(test_case['Body Template'])
            default_values = self.load_default_values(test_case['Body Default'])
            user_defined_fields = self.parse_user_defined_fields(test_case['Body Override'])
            logging.info(f"{self.__class__.__name__}:Body Override for test case {test_case['TCID']}: \n{user_defined_fields}")
            combined_data = self.merge_values(default_values, user_defined_fields, test_case)
            request_data = self.generate_dynamic_values(combined_data, test_case)
            logging.info(f"{self.__class__.__name__}:Request data for test case {test_case['TCID']}: \n{self.format_json(request_data)}")

            # Generating request body
            body = TemplateRenderer.render_template(template_content, request_data, template_format)
            if template_format == 'json':
                logging.info(f"{self.__class__.__name__}:Request body for test case {test_case['TCID']}: \n{self.format_json(body)}")
            else:
                logging.info(f"{self.__class__.__name__}:Request body for test case {test_case['TCID']}: \n{self.format_xml(body)}")
            return body, template_format
        except Exception as e:
            logging.error(f"{self.__class__.__name__}:Error in generate_request_body for test case {test_case['TCID']}: {str(e)}")
            raise

    def load_template(self, template_name):
        templates = self.api_test_loader.get_body_templates()
        try:
            template = templates[templates['TemplateName'] == template_name]
            if template.empty:
                raise ValueError(f"Template '{template_name}' not found.")
            content = template.iloc[0]['Content']
            format = template.iloc[0]['Format']
            return content, format
        except Exception as e:
            logging.error(f"Error loading template: {e}")
            raise

    def load_default_values(self, default_name):
        defaults = self.api_test_loader.get_body_defaults()
        try:
            default = defaults[defaults['Name'] == default_name]
            if default.empty:
                raise ValueError(f"Default values '{default_name}' not found.")
            return yaml.safe_load(default.iloc[0]['Content'])
        except yaml.YAMLError as e:
            logging.error(f"Error loading default values: {e}")
            raise

    def parse_user_defined_fields(self, field_string):
        if field_string is None or field_string.strip() == "":
            return {}
        try:
            field_string = field_string.replace(":", ": ")
            return yaml.safe_load(field_string)
        except yaml.YAMLError as e:
            logging.error(f"Error parsing user-defined fields: {e}")
            raise

    def merge_values(self, base_values: Dict[str, Any], custom_values: Dict[str, Any], test_case: Dict[str, Any]) -&gt; Dict[str, Any]:
        try:
            for key, value in custom_values.items():
                if key in base_values and isinstance(value, dict) and isinstance(base_values[key], dict):
                    base_values[key] = self.merge_values(base_values.get(key, {}), value, test_case)
                else:
                    base_values[key] = value
            return base_values
        except Exception as e:
            logging.error(f"{self.__class__.__name__}:Error merging default values and custom values in test case {test_case['TCID']} : {str(e)}")
            raise

    def generate_dynamic_values(self, data: Union[Dict[str, Any], list], test_case: Dict[str, Any]) -&gt; Union[
        Dict[str, Any], list]:
        try:
            if isinstance(data, dict):
                return {key: self.generate_dynamic_values(value, test_case) if isinstance(value, (dict, list))
                        else self.replace_placeholders(value, test_case) for key, value in data.items()}
            elif isinstance(data, list):
                return [self.generate_dynamic_values(item, test_case) if isinstance(item, (dict, list))
                        else self.replace_placeholders(item, test_case) for item in data]
            return data
        except Exception as e:
            logging.error(f"{self.__class__.__name__}:Error generating dynamic values in test case {test_case['TCID']} : {str(e)}")
            raise

    def replace_placeholders(self, value: Any, test_case) -&gt; Any:
        try:
            if isinstance(value, str) and re.match(r'\{\{\s*[^}]+?\s*\}\}', value):
                placeholder = re.findall(r'\{\{\s*([^}]+?)\s*\}\}', value)[0]
                return VariableGenerator.generate_dynamic_value(placeholder)
            return value
        except Exception as e:
            logging.error(f"{self.__class__.__name__}:Error replacing placeholders in test case {test_case['TCID']}: {str(e)}")
            raise
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api_headers_generator_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\api\headers_generator.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import logging
import re
import yaml
from typing import Dict, Any
import pandas as pd
from libraries.common.utility_helpers import UtilityHelpers
from libraries.common.variable_generator import VariableGenerator
from robot.libraries.BuiltIn import BuiltIn

builtin_lib = BuiltIn()


class HeadersGenerator:
    def __init__(self, api_test_loader) -&gt; None:
        self.format_json = UtilityHelpers.format_json
        self.api_test_loader = api_test_loader

    def prepare_headers(self, testcase, saved_fields):
        try:
            headers_name = testcase['Headers']
            headers = self.api_test_loader.get_headers()

            # Ensure headers_name exists and is valid
            if headers_name not in headers['HeaderName'].values:
                raise ValueError(f"Headers name '{headers_name}' not found in the headers dataframe.")

            # Convert to string explicitly before checking
            header_content = str(headers[headers['HeaderName'] == headers_name]['Content'].iloc[0])
            logging.info(f"{self.__class__.__name__}: Headers for test case '{testcase['TCID']}' loaded from file: \n{header_content}")

            # Check if header_content is empty
            if pd.isna(header_content):
                raise ValueError("Header content is empty.")

            # Parse the YAML-like content
            original_headers = yaml.safe_load(header_content)

            headers = {k: self.replace_placeholders(v, saved_fields, testcase) for k, v in original_headers.items()}
            logging.info(f"{self.__class__.__name__}: Headers for test case '{testcase['TCID']}' replaced placeholders: \n{self.format_json(headers)}")

            return headers

        except KeyError as e:
            logging.error(f"{self.__class__.__name__}: Headers file '{headers_name}' not found in test case '{testcase['TCID']}': {str(e)}")
            raise

        except yaml.YAMLError as e:
            logging.error(f"{self.__class__.__name__}: Invalid YAML format in headers file '{headers_name}' for test case '{testcase['TCID']}': {str(e)}")
            raise

        except pd.errors.EmptyDataError as e:
            logging.error(f"{self.__class__.__name__}: No data found in headers dataframe: {str(e)}")
            raise

        except TypeError as e:
            logging.error(f"{self.__class__.__name__}: TypeError when parsing YAML content for headers file '{headers_name}' for test case '{testcase['TCID']}': {str(e)}")
            raise

        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error processing headers file '{headers_name}' for test case '{testcase['TCID']}': {str(e)}")
            raise

    def replace_placeholders(self, value: Any, saved_fields: Dict[str, Any], testcase) -&gt; Any:
        headers_filename = testcase['Headers']
        try:
            if isinstance(value, str):
                # Replace {{...}}
                value = re.sub(r'\{\{\s*([^}]+?)\s*\}\}', lambda m: self._get_placeholder_value(m.group(1), saved_fields, testcase), value,
                               flags=re.DOTALL | re.MULTILINE)

                # Replace ${...}
                value = re.sub(r'\$\{([^}]+)\}', lambda m: str(builtin_lib.get_variable_value('${' + m.group(1) + '}')), value, flags=re.DOTALL | re.MULTILINE)

                # Logging for ${...} replacements
                for match in re.findall(r'\$\{([^}]+)\}', value):
                    replacement_value = builtin_lib.get_variable_value(f'${{{match}}}')
                    logging.info(f"{self.__class__.__name__}:Replaced ${{{match}}} with variable value '{replacement_value}' for test case '{testcase['TCID']}'")

            return value
        except Exception as e:
            logging.error(
                f"{self.__class__.__name__}:Unexpected error replacing placeholders in headers file '{headers_filename}' for test case '{testcase['TCID']}': {str(e)}"
            )
            raise

    def _get_placeholder_value(self, placeholder: str, saved_fields: Dict[str, Any], testcase: Dict[str, Any]) -&gt; str:
        if placeholder in saved_fields:
            value = str(saved_fields[placeholder])
            logging.info(f"{self.__class__.__name__}:Replaced {{{{{placeholder}}}}} with saved field '{value}' for test case '{testcase['TCID']}'")
        else:
            try:
                value = str(VariableGenerator.generate_dynamic_value(placeholder))
                logging.info(f"{self.__class__.__name__}:Replaced {{{{{placeholder}}}}} with dynamic value '{value}' for test case '{testcase['TCID']}'")
            except Exception as e:
                logging.warning(f"{self.__class__.__name__}:Failed to generate dynamic value for {{{{{placeholder}}}}} in test case '{testcase['TCID']}': {str(e)}")
                value = f"{{{{UNKNOWN_PLACEHOLDER_{placeholder}}}}}"
        return value
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api_request_sender_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\api\request_sender.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import requests
import urllib3
from typing import Dict, Union, Optional
import time
import logging


class RequestSender:
    @staticmethod
    def send_request(url: str, method: str, headers: Optional[Dict[str, str]] = None,
                     body: Optional[Union[Dict, str]] = None, format_type: str = 'json') -&gt; (requests.Response, float, Optional[str]):
        requests_method = RequestSender._get_request_method(method)
        start_time = time.time()
        urllib3.disable_warnings()
        try:
            if format_type == 'json':
                response = requests_method(url, headers=headers, json=body, verify=False)
            elif format_type == 'xml':
                if headers is not None:
                    headers['Content-Type'] = 'application/xml'
                response = requests_method(url, headers=headers, data=body, verify=False)
            else:
                logging.error(f"Unsupported format type: {format_type}")
                raise ValueError(f"RequestSender: Unsupported format type: {format_type}")
            response.raise_for_status()
        except requests.exceptions.SSLError as e:
            logging.error(f"SSL verification failed: {str(e)}")
            raise
        except requests.RequestException as e:
            logging.error(f"Sending request error: {str(e)}")
            raise
        except ValueError as e:
            logging.error(str(e))
            raise

        execution_time = time.time() - start_time
        return response, execution_time

    @staticmethod
    def _get_request_method(method: str):
        methods = {
            'GET': requests.get,
            'POST': requests.post,
            'PUT': requests.put,
            'DELETE': requests.delete,
            'PATCH': requests.patch
        }

        if method in methods:
            return methods[method]
        else:
            logging.warning(f"Unsupported HTTP method: {method}")
            return methods['GET']  # 返回默认方法 GET
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api_response_handler_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\api\response_handler.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import logging
import json
import re
from typing import Any, Union, Tuple, List, Dict
from jsonpath_ng import parse
import xmltodict
from requests import Response
from robot.libraries.BuiltIn import BuiltIn
from robot.api import logger
from libraries.db.db_operator import DBOperator
from libraries.common.log_manager import ColorLogger
from libraries.common.utility_helpers import UtilityHelpers
from libraries.common.variable_transformer import VariableTransformer

builtin_lib = BuiltIn()


class ResponseHandler:
    def get_content_and_format(self, response: Union[str, Response]) -&gt; Tuple[str, str]:
        try:
            content = self._get_raw_content(response)
            response_format = self._determine_format(content)
            if response_format == 'xml':
                content = UtilityHelpers.format_xml(content)
            return content, response_format
        except Exception as e:
            msg = f"{self.__class__.__name__}: Error processing response: {e}"
            logging.error(msg)
            raise ValueError(msg) from e

    def _get_raw_content(self, response: Union[str, Response]) -&gt; str:
        if isinstance(response, Response):
            return response.text.strip()
        elif isinstance(response, str):
            return response.strip()
        else:
            raise TypeError(f"{self.__class__.__name__}: Response must be a requests.Response object or a string.")

    def _determine_format(self, content: str) -&gt; str:
        if self._is_json(content):
            return 'json'
        elif self._is_xml(content):
            return 'xml'
        else:
            raise ValueError(f"{self.__class__.__name__}: Response content is neither valid JSON nor XML.")

    def _extract_value_from_response(self, response: Union[str, Response], json_path: str) -&gt; Any:
        content, response_format = self.get_content_and_format(response)
        return self._extract_value(content, json_path, response_format)

    def _extract_value(self, content: str, json_path: str, response_format: str) -&gt; Any:
        try:
            if response_format == 'xml':
                content = json.dumps(xmltodict.parse(content))

            jsonpath_expr = parse(f'$.{json_path}')
            matches = [match.value for match in jsonpath_expr.find(json.loads(content))]

            if not matches:
                raise ValueError(f"{self.__class__.__name__}: No match found for JSONPath: {json_path}")

            return matches[0]
        except Exception as e:
            msg = f"{self.__class__.__name__}: Error extracting value with JSONPath '{json_path}': {e}"
            logging.error(msg)
            raise ValueError(msg) from e

    def _is_json(self, content: str) -&gt; bool:
        try:
            json.loads(content)
            return True
        except json.JSONDecodeError:
            return False

    def _is_xml(self, content: str) -&gt; bool:
        try:
            xmltodict.parse(content)
            return True
        except Exception:
            return False


class ResponseValidator(ResponseHandler):
    def __init__(self, db_configs):
        super().__init__()
        self.db_configs = db_configs
        self.db_validator = DBOperator()
        self.is_main_test = False

    def validate(self, test_case: dict, response, pre_check_responses=None, post_check_responses=None) -&gt; None:
        logging.info(f"{self.__class__.__name__}: Validating response for test case: {test_case['TCID']}")
        self.is_main_test = test_case['Run'].strip() == 'Y'
        response_content, response_format = self.get_content_and_format(response)
        logging.info(f"{self.__class__.__name__}: Actual response:\n{response_content}")

        current_test_results = self._process_expected_results(test_case, response, pre_check_responses, post_check_responses)

        if current_test_results and any(result['Result'] == 'Fail' for result in current_test_results):
            raise AssertionError(f"{self.__class__.__name__}: Results validation failed for test case: {test_case['TCID']}")

        logging.info(f"{self.__class__.__name__}: All checks passed successfully.")

    def _process_expected_results(self, test_case, response, pre_check_responses, post_check_responses):
        """Processes expected results from the test case."""
        exp_results = test_case['Exp Result'].splitlines()
        current_test_results = []
        for exp_result in exp_results:
            current_test_results.extend(
                self._process_single_expected_result(exp_result, response, pre_check_responses, post_check_responses))
        return current_test_results

    def _process_single_expected_result(self, exp_result, response, pre_check_responses, post_check_responses):
        """Processes a single expected result line."""
        dynamic_checks = re.findall(r'(\w+)\.(?!precheck|postcheck)(\$[.\[\]\w]+)=([+-]\d*\.?\d+)', exp_result)
        pre_post_checks = re.findall(r'(\w+)\.(precheck|postcheck)\.(\$[.\[\]\w]+)=(.+)', exp_result)
        results = []
        if dynamic_checks:
            results.extend(self._handle_dynamic_checks(dynamic_checks, pre_check_responses, post_check_responses))
        elif pre_post_checks:
            results.extend(self._handle_pre_post_checks(pre_post_checks, pre_check_responses, post_check_responses))
        elif exp_result.strip().startswith('$'):
            result = self._handle_response_checks(exp_result.strip(), response)
            results.append(result)
        elif exp_result.strip().startswith('db_'):  # Use 'db_' as prefix
            result = self._handle_db_checks(exp_result.strip())
            results.append(result)
        return results

    def _handle_dynamic_checks(self, checks, pre_check_responses, post_check_responses) -&gt; List[Dict]:
        """Handles dynamic checks (e.g., TC01.$result.total=+1)."""
        results = []
        for tcid, json_path, expected_diff in checks:
            pre_value = self._extract_value_from_response(pre_check_responses[tcid], json_path)
            post_value = self._extract_value_from_response(post_check_responses[tcid], json_path)

            # Format actual_diff to include "+" sign for positive values
            actual_diff_value = round(float(post_value) - float(pre_value), 2)
            actual_diff_str = f"{actual_diff_value:+g}"

            # Format expected_diff to include "+" sign for positive values
            expected_diff_val = round(float(expected_diff), 2)
            expected_diff_str = f"{expected_diff_val:+g}"

            success = actual_diff_value == expected_diff_val
            log_msg = f"Dynamic check for {tcid}.{json_path}. Pre Value: {pre_value}, Post Value:{post_value}, Expected diff: {expected_diff_str}, Actual diff: {actual_diff_str}"
            self._log_result(success, log_msg)

            results.append({"Result": "Pass" if success else "Fail"})
        return results

    def _handle_pre_post_checks(self, checks, pre_check_responses, post_check_responses) -&gt; List[Dict]:
        """Handles pre/post checks (e.g., TC01.precheck.$result.status=success)."""
        results = []
        for tcid, check_type, json_path, expected_value in checks:
            responses = pre_check_responses if check_type == 'precheck' else post_check_responses
            actual_value = self._extract_value_from_response(responses[tcid], json_path)
            expected_value = expected_value.strip()
            success = str(actual_value) == str(expected_value)
            log_msg = f"{check_type.capitalize()} for {tcid}.{json_path} - Expected value: {expected_value}, Actual value: {actual_value}"

            results.append({"Result": "Pass" if success else "Fail"})
            self._log_result(success, log_msg)
        return results

    def _handle_response_checks(self, line: str, response_content: str) -&gt; Dict:
        """Handles direct response checks (e.g., $result.status=success)."""
        key, expected_value = map(str.strip, line.split('=', 1))
        actual_value = self._extract_value_from_response(response_content, key)
        # Attempt type conversion for comparison
        try:
            expected_value = type(actual_value)(expected_value)
        except (ValueError, TypeError):
            pass
        success = actual_value == expected_value
        log_msg = f"Asserting: {key}, Expected: {expected_value}, Actual: {actual_value}"
        result = {"Result": "Pass" if success else "Fail"}
        self._log_result(success, log_msg)
        return result

    def _handle_db_checks(self, exp_result):
        """Handles database validation checks."""
        try:
            if exp_result.startswith('db_'):
                db_name = exp_result.split('.')[0]
                is_valid, msg = self.db_validator.validate_database_value(db_name, exp_result)
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Failed to validate database: {str(e)}")
        result = {"Result": "Pass" if is_valid else "Fail"}
        self._log_result(is_valid, msg)
        return result

    def _get_db_config_by_prefix(self, prefix: str) -&gt; dict:
        db_config = self.db_configs.get(prefix.lower(), {})
        if not db_config:
            raise ValueError(f"No database configuration found for prefix: {prefix}")
        return db_config

    def _log_result(self, success: bool, message: str):
        """Logs the result of a check with appropriate color."""
        case_type = 'Sub Test'
        if self.is_main_test:
            case_type = 'Main Test'
        logging.debug(f"{self.__class__.__name__}: {message}")
        logger.info(
            ColorLogger.success(f"{case_type}=&gt; {self.__class__.__name__}: {message}") if success else ColorLogger.error(f"{case_type}=&gt; {self.__class__.__name__}: {message}"),
            html=True)


class ResponseFieldSaver(ResponseHandler):
    def __init__(self):
        super().__init__()
        self.variable_transformer = VariableTransformer()

    def save_fields_to_robot_variables(self, response: Union[str, Response], test_case: dict) -&gt; None:
        response_content, _ = self.get_content_and_format(response)
        save_fields = test_case.get('Save Fields', '').splitlines()
        # Regular expression to match patterns like: assign_value($.result.amount,my_amount) or assign_value($.result.amount)
        transform_pattern = re.compile(r'^\s*(\w+)\(([^,]+)(?:,\s*([^)]+))?\)\s*$')

        for field in save_fields:
            if not field.strip():
                continue  # Skip empty lines
            field = field.strip()
            # Check if field matches transform format
            match = transform_pattern.match(field)
            if match:
                method_name, input_field, output_field = match.groups()
                # If no second parameter, use JSON Path as Robot variable name
                if output_field is None:
                    output_field = input_field
                input_value = self._extract_value_from_response(response_content, input_field)
                self.variable_transformer.transform_and_save(method_name, input_value, output_field)
            else:
                # Handle standard field format
                try:
                    value = self._extract_value_from_response(response_content, field)
                    field_name = f'{test_case["TCID"]}.{field.strip()}'
                    logger.info(ColorLogger.info(f"=&gt; {self.__class__.__name__}: Setting global variable ${{{field_name}}} to {value}."), html=True)
                    BuiltIn().set_global_variable(f'${{{field_name}}}', value)
                except Exception as e:
                    logging.error(f"{self.__class__.__name__}: Failed to process field '{field}': {e}")
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api_saved_fields_manager_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\api\saved_fields_manager.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import logging
import re
import yaml
import os
from typing import Dict, Any
from libraries.common.utility_helpers import PROJECT_ROOT
from robot.libraries.BuiltIn import BuiltIn
from libraries.common.variable_transformer import VariableTransformer

builtin_lib = BuiltIn()


class SavedFieldsManager:
    def __init__(self, file_path: str = None) -&gt; None:
        self.project_root: str = PROJECT_ROOT
        self.file_path: str = file_path or os.path.join(self.project_root, 'configs', 'saved_fields.yaml')
        self.variable_transformer = VariableTransformer()

    def clear_saved_fields(self):
        with open(self.file_path, 'w') as f:
            f.write('')

    def load_saved_fields(self) -&gt; Dict[str, Any]:
        if not os.path.exists(self.file_path):
            return {}
        try:
            with open(self.file_path, 'r') as f:
                saved_fields: Dict[str, Any] = yaml.safe_load(f) or {}
            return saved_fields
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Failed to load saved fields from the yaml file: {str(e)}")
            raise

    def save_fields(self, field_data: Dict[str, Any]) -&gt; None:
        saved_fields: Dict[str, Any] = self.load_saved_fields()
        saved_fields.update(field_data)
        try:
            with open(self.file_path, 'w') as f:
                yaml.safe_dump(saved_fields, f, default_flow_style=False)
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Failed to save fields to the yaml file: {str(e)}")
            raise

    def apply_saved_fields(self, test_case, saved_fields: Dict) -&gt; None:
        try:
            for key, value in saved_fields.items():
                for column in ['Body Override', 'Exp Result']:
                    if column in test_case and test_case[column] != '':
                        lines = test_case[column].splitlines()
                        replaced_lines = [line.replace(f"${{{key}}}", str(value)) for line in lines]
                        test_case[column] = "\n".join(replaced_lines)
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Failed to apply saved fields to [Body Override], [Exp Result]: {str(e)}")
            raise

    def apply_suite_variables(self, test_case) -&gt; None:
        try:
            # Regular expression to match patterns like: assign_value($.result.amount,my_amount) or assign_value($.result.amount)
            transform_pattern = re.compile(r'(\w+)\(([^,]+)(?:,\s*([^)]+))?\)')

            for key in ['Body Override', 'Exp Result']:
                if key not in test_case or not test_case[key]:
                    continue  # Skip empty fields

                lines = test_case[key].splitlines()
                updated_lines = []

                for line in lines:
                    if not line.strip():
                        updated_lines.append(line)  # Preserve empty lines
                        continue

                    # Check if line matches transformation pattern
                    match = transform_pattern.search(line.strip())
                    if match:
                        # Handle transformation format
                        method_name, input_field, output_field = match.groups()
                        # If no second parameter, use input field as output variable name
                        if output_field is None:
                            output_field = input_field

                        # Extract input field value and transform it
                        input_value = BuiltIn().get_variable_value(input_field)
                        transformed_value = self.variable_transformer.transform(method_name, input_value)

                        # Replace entire pattern with transformed value
                        line = transform_pattern.sub(str(transformed_value), line)
                        logging.info(f"{self.__class__.__name__}: [{key}] Replaced transform pattern {match.group(0)} with [{transformed_value}]")
                    else:
                        # Handle standard variable replacement
                        matches = re.findall(r'\$\{[^}]+\}', line)
                        for match in matches:
                            replacement_value = BuiltIn().get_variable_value(match)
                            line = line.replace(match, str(replacement_value))
                            logging.info(f"{self.__class__.__name__}: [{key}] Replaced {match} with [{replacement_value}]")

                    updated_lines.append(line)

                # Update field content
                test_case[key] = "\n".join(updated_lines)

        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Failed to apply suite variables: {str(e)}")
            raise
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_api_template_renderer_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\api\template_renderer.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import json
from jinja2 import Environment, TemplateNotFound
from typing import Dict, Any, Union


class TemplateRenderer:
    @staticmethod
    def render_template(template_content, render_by: Dict[str, Any], format_type: str) -&gt; Union[Dict, str]:
        try:
            env = TemplateRenderer._create_environment()
            template = env.from_string(template_content)
            rendered_body: str = template.render(render_by)
            format_body = TemplateRenderer._format_rendered_body(rendered_body, format_type)
            return format_body
        except (TemplateNotFound, json.JSONDecodeError) as e:
            raise ValueError(f"TemplateRenderer: Error rendering template: {str(e)}")
        except Exception as e:
            raise ValueError(f"TemplateRenderer: An unexpected error occurred while rendering template: {str(e)}")

    @staticmethod
    def _create_environment() -&gt; Environment:
        env = Environment()
        env.filters['json_bool'] = lambda value: str(value).lower()
        return env

    @staticmethod
    def _format_rendered_body(rendered_body: str, format_type: str) -&gt; Union[Dict, str]:
        if format_type == 'json':
            return json.loads(rendered_body)
        elif format_type == 'xml':
            return rendered_body
        else:
            raise ValueError(f"TemplateRenderer: Unsupported format type: {format_type}")
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_common___init___py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\common\__init__.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre></pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_common_config_manager_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\common\config_manager.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import yaml
import json
import os
from typing import Dict


class ConfigManager:

    @staticmethod
    def load_json(file_path: str) -&gt; Dict:
        with open(file_path, 'r') as file:
            config = json.load(file)
        return config

    @staticmethod
    def load_yaml(file_path: str) -&gt; Dict:
        with open(file_path, 'r') as file:
            config = yaml.safe_load(file)
        return config

    @staticmethod
    def load_templates(template_dir: str) -&gt; Dict[str, str]:
        templates = {}
        for filename in os.listdir(template_dir):
            if filename.endswith('.json') or filename.endswith('.xml'):
                template_name = os.path.splitext(filename)[0]
                templates[template_name] = os.path.join(template_dir, filename)
        return templates
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_common_gen_temp_default_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\common\gen_temp_default.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import os
import re
import json
from collections import defaultdict

TEMPLATE_DIR = '../../configs/api/body_templates'
OUTPUT_DIR = '../../report'


def extract_placeholders(template_content):
    # 提取{{}}中的占位符，支持嵌套
    placeholders = re.findall(r'\{\{\s*([^}]+?)\s*\}\}', template_content)
    return placeholders


def nest_keys(keys):
    nested_dict = {}
    for key in keys:
        parts = key.split('.')
        current_level = nested_dict
        for part in parts[:-1]:
            if part not in current_level:
                current_level[part] = {}
            current_level = current_level[part]
        current_level[parts[-1]] = ""
    return nested_dict


def merge_dicts(dict1, dict2):
    for key in dict2:
        if key in dict1:
            if isinstance(dict1[key], dict) and isinstance(dict2[key], dict):
                merge_dicts(dict1[key], dict2[key])
            else:
                dict1[key] = dict2[key]
        else:
            dict1[key] = dict2[key]
    return dict1


def generate_json_from_template(template_filename):
    template_path = os.path.join(TEMPLATE_DIR, template_filename)
    if not os.path.exists(template_path):
        raise FileNotFoundError(f"The template file {template_filename} does not exist in {TEMPLATE_DIR}")

    with open(template_path, 'r', encoding='utf-8') as file:
        template_content = file.read()

    placeholders = extract_placeholders(template_content)
    nested_structure = {}

    for placeholder in placeholders:
        nested_dict = nest_keys([placeholder])
        nested_structure = merge_dicts(nested_structure, nested_dict)

    output_path = os.path.join(OUTPUT_DIR, f"{os.path.splitext(template_filename)[0]}_placeholders.json")
    os.makedirs(OUTPUT_DIR, exist_ok=True)
    with open(output_path, 'w', encoding='utf-8') as outfile:
        json.dump(nested_structure, outfile, indent=4)

    print(f"Generated JSON file with placeholders: {output_path}")


if __name__ == "__main__":
    template_filename = 'pacs.008_out.xml'  # 你可以更改为你想指定的模板文件名
    generate_json_from_template(template_filename)</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_common_log_manager_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\common\log_manager.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import logging
import logging.config
import os
import yaml
from libraries.common.utility_helpers import PROJECT_ROOT


class Logger:
    _instance = None

    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super(Logger, cls).__new__(cls)
        return cls._instance

    def __init__(self, config_path=None):
        if not hasattr(self, 'initialized'):
            self.config_path = config_path or os.path.join(PROJECT_ROOT, 'configs', 'logging_config.yaml')
            self.log_file_name = "robot_testing"
            self.load_config()
            self.initialized = True

    def load_config(self):
        if os.path.exists(self.config_path):
            with open(self.config_path, 'r', encoding='utf-8') as file:
                config = yaml.safe_load(file)

            log_file_path = os.path.join(PROJECT_ROOT, 'report', f"{self.log_file_name}.log")
            os.makedirs(os.path.dirname(log_file_path), exist_ok=True)

            if 'file' in config['handlers']:
                config['handlers']['file']['filename'] = log_file_path

            logging.config.dictConfig(config)
        else:
            logging.basicConfig(level=logging.DEBUG)

        self.logger = logging.getLogger('e2e_testing')

    def get_logger(self):
        return self.logger


class ColorLogger:
    @staticmethod
    def success(message):
        return f'&lt;span style="background-color: #90EE90; padding: 2px 5px; border-radius: 3px;"&gt;{message}&lt;/span&gt;'

    @staticmethod
    def error(message):
        return f'&lt;span style="background-color: #FFB6C1; padding: 2px 5px; border-radius: 3px;"&gt;{message}&lt;/span&gt;'

    @staticmethod
    def info(message):
        return f'&lt;span style="background-color: #B8E2F2; padding: 2px 5px; border-radius: 3px;"&gt;{message}&lt;/span&gt;'

logger_instance = Logger()
logger = logger_instance.get_logger()

__all__ = ['logger', 'logger_instance', 'ColorLogger']
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_common_utility_helpers_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\common\utility_helpers.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import json
import os
import time
from functools import wraps
from lxml import etree


class UtilityHelpers:
    @staticmethod
    def get_file_format(file_path: str) -&gt; str:
        """
        Determine the format of the file based on its extension.
        """
        if file_path.endswith('.json'):
            return 'json'
        elif file_path.endswith('.xml'):
            return 'xml'
        else:
            raise ValueError(f"UtilityHelpers: Unsupported file format for file: {file_path}")

    @staticmethod
    def escape_xml(value):
        """Escape XML characters."""
        return (
            value.replace("&amp;", "&amp;amp;")
            .replace("&lt;", "&amp;lt;")
            .replace("&gt;", "&amp;gt;")
            .replace('"', "&amp;quot;")
            .replace("'", "&amp;apos;")
        )

    @staticmethod
    def format_json(data):
        """
        Formats a given dictionary as a pretty-printed JSON string.

        :param data: Dictionary to format.
        :return: Pretty-printed JSON string.
        """
        return json.dumps(data, indent=4)

    @staticmethod
    def format_xml(xml_string: str) -&gt; str:
        """
        Formats a given XML string as a pretty-printed XML string without extra newlines.

        :param xml_string: XML string to format.
        :return: Pretty-printed XML string.
        """
        try:
            # check for XML declaration
            xml_declaration = ""
            if xml_string.startswith("&lt;?xml"):
                declaration_end_index = xml_string.find("?&gt;") + 2
                xml_declaration = xml_string[:declaration_end_index]
                xml_string = xml_string[declaration_end_index:].strip()

            parser = etree.XMLParser(remove_blank_text=True, strip_cdata=False)
            xml_element = etree.fromstring(xml_string, parser)

            # Ensure CDATA sections are preserved
            def _preserve_cdata(element):
                if element.text and isinstance(element.text, etree.CDATA):
                    element.text = etree.CDATA(element.text)
                for child in element:
                    _preserve_cdata(child)
                    if child.tail and isinstance(child.tail, etree.CDATA):
                        child.tail = etree.CDATA(child.tail)

            _preserve_cdata(xml_element)
            formatted_xml = etree.tostring(xml_element, pretty_print=True, encoding='unicode')
            if xml_declaration:
                formatted_xml = xml_declaration + "\n" + formatted_xml
            return formatted_xml.strip()
        except Exception as e:
            raise ValueError(f"UtilityHelpers: Invalid XML data: {str(e)}")

    @staticmethod
    def time_calculation():
        def decorator(func):
            @wraps(func)
            def wrapper(*args, **kwargs):
                start_time = time.time()
                result = func(*args, **kwargs)
                end_time = time.time()
                execution_time = end_time - start_time
                from libraries.common.log_manager import logger
                logger.info(f"UtilityHelpers: Function {func.__name__} executed in {execution_time:.4f} seconds")
                return result

            return wrapper

        return decorator

    @staticmethod
    def _find_project_root(current_dir=os.getcwd()):
        while True:
            if os.path.exists(os.path.join(current_dir, '.project_root')):
                return current_dir
            parent = os.path.dirname(current_dir)
            if parent == current_dir:
                raise FileNotFoundError("UtilityHelpers: Project root not found")
            current_dir = parent

    @staticmethod
    def get_project_root():
        # 尝试从脚本所在目录查找
        script_dir = os.path.dirname(os.path.abspath(__file__))
        project_root = UtilityHelpers._find_project_root(script_dir)

        if project_root is None:
            # 如果失败，尝试从当前工作目录查找
            current_dir = os.getcwd()
            project_root = UtilityHelpers._find_project_root(current_dir)

        if project_root is None:
            raise FileNotFoundError("UtilityHelpers: Project root not found")

        return project_root


PROJECT_ROOT = UtilityHelpers.get_project_root()
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_common_variable_generator_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\common\variable_generator.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import random
import string
import uuid
import datetime
from typing import Any, Dict, Callable


class VariableGenerator:
    @staticmethod
    def generate_dynamic_value(field_name: str) -&gt; Any:
        handlers: Dict[str, Callable[[str], Any]] = {
            'uetr': VariableGenerator._generate_uuid4,
            'uuid4': VariableGenerator._generate_uuid4,
            'value_date': VariableGenerator._generate_current_day,
            'msg_id': VariableGenerator._generate_msg_id,
            'timestamp': VariableGenerator._generate_timestamp,
            'formated_timestamp': VariableGenerator._generate_formated_timestamp,
            'bic': VariableGenerator._generate_bic
        }
        return handlers.get(field_name, VariableGenerator._generate_error_handling)()

    @staticmethod
    def _generate_uuid4() -&gt; str:
        return str(uuid.uuid4())

    @staticmethod
    def _generate_current_day(date_format: str = "%Y%m%d") -&gt; str:
        return datetime.datetime.now().strftime(date_format)

    @staticmethod
    def _generate_msg_id() -&gt; str:
        prefix = 'MSG'
        suffix = ''.join(random.choices(string.ascii_lowercase, k=5))
        timestamp = VariableGenerator._generate_timestamp()
        msg_id = f'{prefix}{timestamp}{suffix}'
        return msg_id

    @staticmethod
    def _generate_timestamp() -&gt; str:
        return str(int(datetime.datetime.now().timestamp()))

    @staticmethod
    def _generate_formated_timestamp() -&gt; str:
        now = datetime.datetime.now()
        timestamp_str = now.strftime("%m%d%H%M%S") + f"{now.microsecond // 1000:03d}"
        return timestamp_str

    @staticmethod
    def _generate_bic() -&gt; str:
        return ''.join(random.choices(string.ascii_uppercase, k=8))

    @staticmethod
    def _generate_error_handling() -&gt; str:
        raise ValueError(f"VariableGenerator: No handler registered for this field.")
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_common_variable_transformer_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\common\variable_transformer.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import re
import datetime
import pytz
from robot.libraries.BuiltIn import BuiltIn
from typing import Any, Dict
from robot.api import logger
from libraries.common.log_manager import ColorLogger

class VariableTransformer:
    def __init__(self):
        self.builtin = BuiltIn()
        self.functions = {
            'to_iso_date': self._compact_to_iso_date,
            'to_compact_date': self._iso_to_compact_date,
            'utc_to_poland_iso_datetime': self._utc_to_poland_iso_datetime,
            'to_uppercase': lambda x: x.upper(),
            'to_lowercase': lambda x: x.lower(),
            'assign_value': lambda x: x,
        }

    def transform(self, function_name, input_value) -&gt; Any:
        if function_name not in self.functions:
            raise ValueError(f"Unknown function: {function_name}")
        output_value = self.functions[function_name](input_value)
        return output_value

    def transform_and_save(self, function_name, input_value, output_field) -&gt; None:
        if function_name not in self.functions:
            raise ValueError(f"Unknown function: {function_name}")
        output_value = self.functions[function_name](input_value)
        self._save_as_global_variable(output_field, output_value)

    def _save_as_global_variable(self, output_field: str, value: Any) -&gt; None:
        logger.info(ColorLogger.info(f"=&gt; {self.__class__.__name__}: Setting global variable ${{{output_field}}} to {value}."), html=True)
        self.builtin.set_global_variable(f'${{{output_field}}}', value)

    # e.g. 20230101 -&gt; 2023-01-01
    def _compact_to_iso_date(self, value: str) -&gt; str:
        date_obj = datetime.datetime.strptime(value, "%Y%m%d")
        return date_obj.strftime("%Y-%m-%d")

    # e.g. 2023-01-01 -&gt; 20230101
    def _iso_to_compact_date(self, value: str) -&gt; str:
        date_obj = datetime.datetime.strptime(value, "%Y-%m-%d")
        return date_obj.strftime("%y%m%d")

    # e.g. 2023-10-05T12:00:00.000Z -&gt; 2023-10-05T14:00:00+02:00
    def _utc_to_poland_iso_datetime(self, utc_datetime_str: str) -&gt; str:
        utc_datetime = datetime.datetime.strptime(utc_datetime_str, "%Y-%m-%dT%H:%M:%S.%fZ").replace(microsecond=0)
        poland_zone = pytz.timezone('Europe/Warsaw')
        poland_datetime = utc_datetime.astimezone(poland_zone)
        return poland_datetime.isoformat()


if __name__ == "__main__":
    vt = VariableTransformer()
    print(vt._compact_to_iso_date("20230101"))
    print(vt._iso_to_compact_date("2023-01-01"))
    print(vt._utc_to_poland_iso_datetime("2023-10-05T12:00:00.000Z"))
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_db___init___py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\db\__init__.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre></pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_db_db_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\db\db.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>from typing import List, Dict, Optional, Any
from abc import ABC, abstractmethod
from sqlalchemy import create_engine, Table, MetaData, select, update, insert, delete, text
from sqlalchemy.orm import sessionmaker
from contextlib import contextmanager, closing


class DatabaseError(Exception):
    """Custom exception for database operations"""
    pass


class Database(ABC):
    @abstractmethod
    def connect(self, **kwargs) -&gt; None:
        pass

    @abstractmethod
    def disconnect(self) -&gt; None:
        pass

    @abstractmethod
    def execute_query(self, table: str, fields: Optional[List[str]] = None, where: Optional[str] = None) -&gt; List[Dict]:
        pass

    @abstractmethod
    def update(self, table: str, values: Dict, where: Optional[str] = None) -&gt; bool:
        pass

    @abstractmethod
    def insert(self, table: str, data: List[Dict]) -&gt; int:
        pass

    @abstractmethod
    def delete(self, table: str, where: Optional[str] = None) -&gt; int:
        pass

    @contextmanager
    def transaction(self):
        """Context manager for handling transactions"""
        session = self.Session()
        try:
            yield session
            session.commit()
        except Exception as e:
            session.rollback()
            raise DatabaseError(f"Transaction failed: {str(e)}")
        finally:
            session.close()


class SQLAlchemyDatabase(Database):
    def __init__(self):
        self.engine = None
        self.Session = None
        self.metadata = MetaData()
        self.default_schema = None
        self.db_type = None

    @classmethod
    def create_databases(cls, db_configs: Dict[str, Dict[str, Any]]) -&gt; Dict[str, 'SQLAlchemyDatabase']:
        databases = {}
        for db_name, config in db_configs.items():
            db_type = config.pop('type').lower()
            schema = config.pop('schema', None)
            db = cls()
            db.connect(db_type=db_type, schema=schema, **config)
            databases[db_name] = db
        return databases

    def connect(self, user: str, password: str, host: str, port: int, database: str, db_type: str = 'postgresql',
                schema: Optional[str] = None):
        try:
            url = self._build_db_url(user, password, host, port, database, db_type)
            self.default_schema = schema or self._default_schema(db_type, database)
            self.engine = create_engine(url)
            self.Session = sessionmaker(bind=self.engine)
            self.metadata.reflect(bind=self.engine, schema=self.default_schema if db_type != 'mysql' else None)
        except Exception as e:
            raise DatabaseError(f"Failed to create connection to {db_type}: {str(e)}")

    def disconnect(self):
        if self.engine:
            self.engine.dispose()

    def _build_db_url(self, user: str, password: str, host: str, port: int, database: str, db_type: str) -&gt; str:
        if db_type == 'postgresql':
            return f"{db_type}://{user}:{password}@{host}:{port}/{database}"
        elif db_type == 'oracle':
            return f"oracle+cx_oracle://{user}:{password}@{host}:{port}/?service_name={database}"
        elif db_type == 'mysql':
            return f"mysql+pymysql://{user}:{password}@{host}:{port}/{database}"
        else:
            raise ValueError(f"Unsupported database type: {db_type}")

    def _default_schema(self, db_type: str, database: str) -&gt; str:
        if db_type == 'oracle':
            return database.upper()
        elif db_type == 'mysql':
            return database
        return 'public'

    def _get_table(self, table_name: str, schema: Optional[str] = None) -&gt; Table:
        effective_schema = schema or self.default_schema
        if self.db_type == 'mysql' and effective_schema != self.default_schema:
            raise DatabaseError("MySQL does not support switching schemas after connection.")
        table_obj = self.metadata.tables.get(table_name) or Table(table_name, self.metadata, schema=effective_schema, autoload_with=self.engine)
        if table_obj is None:
            raise DatabaseError(f"Table '{table_name}' not found in schema '{effective_schema}'.")
        return table_obj

    def execute_query(self, table: str, fields: Optional[List[str]] = None, where: Optional[str] = None, order_by: Optional[str] = None) -&gt; List[Dict]:
        table_obj = self._get_table(table, self.default_schema)
        columns = self._construct_columns(fields, table_obj)
        stmt = select(*columns).where(text(where)) if where else select(*columns)
        if order_by:
            stmt = stmt.order_by(*self._construct_order_by(order_by, table_obj))
        with closing(self.engine.connect()) as connection:
            return [row._mapping for row in connection.execute(stmt)]

    def _construct_columns(self, fields: Optional[List[str]], table_obj: Table) -&gt; List:
        if fields:
            columns = [table_obj.c[field] for field in fields if field in table_obj.c]
            if len(columns) != len(fields):
                raise ValueError(f"Invalid field(s) specified: {', '.join(set(fields) - set(col.name for col in columns))}")
        else:
            columns = list(table_obj.columns)
        return columns

    def _construct_order_by(self, order_by: str, table_obj: Table) -&gt; List:
        order_clauses = []
        for term in order_by.split(','):
            direction = 'desc' if term.lower().endswith(' desc') else 'asc'
            col_name = term.split()[0]
            if col_name not in table_obj.c:
                raise ValueError(f"Invalid order_by column: {col_name}")
            order_clauses.append(getattr(table_obj.c[col_name], direction)())
        return order_clauses

    def insert(self, table: str, data: List[Dict]) -&gt; int:
        table_obj = self._get_table(table, self.default_schema)
        with closing(self.engine.connect()) as connection, connection.begin() as transaction:
            try:
                result = connection.execute(insert(table_obj).values(data))
                return result.rowcount
            except Exception as e:
                transaction.rollback()
                raise DatabaseError(f"Insert operation failed: {str(e)}")

    def update(self, table: str, values: Dict, where: Optional[str] = None) -&gt; bool:
        table_obj = self._get_table(table, self.default_schema)
        stmt = update(table_obj).values(values).where(text(where)) if where else update(table_obj).values(values)
        with closing(self.engine.connect()) as connection, connection.begin() as transaction:
            try:
                result = connection.execute(stmt)
                return result.rowcount &gt; 0
            except Exception as e:
                transaction.rollback()
                raise DatabaseError(f"Update operation failed: {str(e)}")

    def delete(self, table: str, where: Optional[str] = None) -&gt; int:
        table_obj = self._get_table(table, self.default_schema)
        stmt = delete(table_obj).where(text(where)) if where else delete(table_obj)
        with closing(self.engine.connect()) as connection, connection.begin() as transaction:
            try:
                result = connection.execute(stmt)
                return result.rowcount
            except Exception as e:
                transaction.rollback()
                raise DatabaseError(f"Delete operation failed: {str(e)}")</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_db_db_operator_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\db\db_operator.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import logging
import os
import re
from typing import Tuple, Any, Dict, Optional
from libraries.db.db import SQLAlchemyDatabase
from libraries.common.config_manager import ConfigManager
from libraries.common.utility_helpers import PROJECT_ROOT
from libraries.common.variable_generator import VariableGenerator
from robot.libraries.BuiltIn import BuiltIn


class DBOperationError(Exception):
    """Custom exception for DBOperator operations"""
    pass


class SingletonMeta(type):
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            instance = super().__call__(*args, **kwargs)
            cls._instances[cls] = instance
        return cls._instances[cls]


class DBOperator(metaclass=SingletonMeta):
    def __init__(self):
        self.db_connections: Dict[str, SQLAlchemyDatabase] = {}
        self.db_configs = self._load_db_configs()
        self.active_environment = self._get_active_environment()
        self._initialized = False

    def _load_db_configs(self) -&gt; Dict[str, Any]:
        config_path = os.path.join(PROJECT_ROOT, 'configs', 'db_config.yaml')
        return ConfigManager.load_yaml(config_path)

    def _get_active_environment(self) -&gt; str:
        return BuiltIn().get_variable_value("${active_environment}")

    def _initialize_databases(self):
        if self._initialized:
            logging.info("Databases already initialized, skipping.")
            return
        try:
            env_db_configs = self.db_configs.get('database', {}).get(self.active_environment, {})
            if not env_db_configs:
                raise ValueError(f"No database configurations found for environment: {self.active_environment}")

            self.db_connections = SQLAlchemyDatabase.create_databases(env_db_configs)
            logging.info(f"Database connections initialized for environment: {self.active_environment}")
            self._initialized = True
        except ValueError as ve:
            logging.error(f"Configuration error: {str(ve)}")
            raise
        except Exception as e:
            logging.error(f"Unexpected error initializing databases: {str(e)}")
            raise

    def get_db_connection(self, db_name: str) -&gt; SQLAlchemyDatabase:
        if not self._initialized:
            self._initialize_databases()
        try:
            db_conn = self.db_connections[db_name]
            return db_conn
        except KeyError:
            raise DBOperationError(f"Database connection '{db_name}' not found")

    def validate_database_value(self, db_name: str, db_clause: str) -&gt; Tuple[bool, str]:
        try:
            db = self.get_db_connection(db_name)
            # db_{db_name}.TableName.FieldName[FilterField1=FilterValue1;FilterField2=FilterValue2][OrderBy=CreateTime]=ExpectedValue
            pattern = r'^db_\w+\.(?P&lt;Table&gt;\w+)\.(?P&lt;Field&gt;\w+)\s*\[(?P&lt;Filters&gt;[^\]]+)\](?:\s*\[(?P&lt;OrderBy&gt;[^\]]+)\])?\s*=\s*(?P&lt;ExpectedValue&gt;.+)$'
            match = re.match(pattern, db_clause)
            if not match:
                raise ValueError(f"Invalid format for validate_database_value: {db_clause}")

            table_name = match.group('Table')
            field_name = match.group('Field')
            filters = match.group('Filters')
            order_by = match.group('OrderBy')
            expected_value = match.group('ExpectedValue').strip()

            where_clause = " AND ".join(f"{f.split('=')[0].strip()} = '{f.split('=')[1].strip()}'" for f in filters.split(';') if '=' in f)
            order_by_clause = f"{order_by.replace('OrderBy=', '').strip()}" if order_by else ""

            logging.info(f"{self.__class__.__name__}: Generated SQL query: SELECT {field_name} FROM {table_name} WHERE {where_clause} ORDER BY {order_by_clause}")

            result = db.execute_query(table_name, fields=[field_name], where=where_clause, order_by=order_by_clause)
            if not result:
                raise AssertionError(f"No data found for field '{field_name}' in table '{db_name}.{table_name}' with filters '{where_clause}' and order '{order_by_clause}'.")

            actual_value = result[0][field_name]
            msg = f"Database validation for '{field_name}' in table '{db_name}.{table_name}'. Expected: '{expected_value}', Actual: '{actual_value}'."
            return actual_value == expected_value, msg

        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Database validation failed: {str(e)}")
            return False, f"Database validation failed: {str(e)}"

    def insert_data(self, db_name: str, table: str, data_template: Dict[str, Any], row_count: int = 1) -&gt; int:
        try:
            db = self.get_db_connection(db_name)
            rows = [self._replace_placeholders(data_template) for _ in range(row_count)]
            if row_count == 1:
                for col, value in rows[0].items():
                    BuiltIn().set_global_variable(f'${{{col}}}', value)

            with db.transaction():
                inserted_count = db.insert(table, rows)
                logging.info(f"{self.__class__.__name__}: Inserted {inserted_count} row(s) into '{table}'")
                return inserted_count

        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Failed to insert data into table '{table}': {str(e)}")
            raise DBOperationError(f"Failed to insert data into table '{table}': {str(e)}")

    def update_data(self, db_name: str, table: str, data_template: Dict[str, Any], where_template: str = "") -&gt; bool:
        try:
            db = self.get_db_connection(db_name)
            update_values = self._replace_placeholders(data_template)
            where_clause = self._replace_placeholders(where_template)

            with db.transaction():
                success = db.update(table, update_values, where=where_clause)
                logging.info(f"{self.__class__.__name__}: Update on '{table}' with {update_values}, where: '{where_clause}', success: {success}")
                return success

        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Failed to update data in table '{table}': {str(e)}")
            raise DBOperationError(f"Failed to update data in table '{table}': {str(e)}")

    def delete_data(self, db_name: str, table: str, where_template: str = "") -&gt; int:
        try:
            db = self.get_db_connection(db_name)
            where_clause = self._replace_placeholders(where_template)

            with db.transaction():
                deleted_count = db.delete(table, where=where_clause)
                logging.info(f"{self.__class__.__name__}: Deleted {deleted_count} row(s) from '{table}', where: '{where_clause}'")
                return deleted_count

        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Failed to delete data from table '{table}': {str(e)}")
            raise DBOperationError(f"Failed to delete data from table '{table}': {str(e)}")

    def _replace_placeholders(self, template: Any, placeholder_cache: Optional[Dict[str, str]] = None) -&gt; Any:
        placeholder_cache = placeholder_cache or {}

        if isinstance(template, str):
            template = self._replace_dynamic_variables(template, placeholder_cache)
            template = self._replace_robot_variables(template)
        elif isinstance(template, dict):
            for key, value in template.items():
                template[key] = self._replace_placeholders(value, placeholder_cache)
        return template

    def _replace_dynamic_variables(self, text: str, placeholder_cache: Dict[str, str]) -&gt; str:
        matches = re.findall(r'\{\{\s*([^}]+?)\s*\}\}', text)
        for match in matches:
            if match not in placeholder_cache:
                try:
                    replaced_value = VariableGenerator.generate_dynamic_value(match.strip())
                    placeholder_cache[match] = str(replaced_value)
                except Exception as e:
                    placeholder_cache[match] = f"{{{{UNKNOWN_{match}}}}}"
                    logging.error(f"{self.__class__.__name__}: Failed to replace dynamic value {match}: {e}")
            text = text.replace(f"{{{{{match}}}}}", placeholder_cache[match])
        return text

    def _replace_robot_variables(self, text: str) -&gt; str:
        matches = re.findall(r'\$\{([^}]+)\}', text)
        for match in matches:
            replaced_value = BuiltIn().get_variable_value(f'${{{match}}}')
            text = text.replace(f"${{{match}}}", str(replaced_value))
        return text
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_performance___init___py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\performance\__init__.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre></pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_performance_web_pt_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\performance\web_pt.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import logging
import os
import json
import time
from typing import Dict, Tuple
from libraries.common.utility_helpers import PROJECT_ROOT
from libraries.common.config_manager import ConfigManager
from libraries.performance.web_pt_loader import PerformanceTestLoader
from libraries.web.web_actions import WebActions
from libraries.web.webdriver_factory import WebDriverFactory
from libraries.performance.web_pt_reporter import WebPerformanceReporter


class WebPerformanceTester:
    def __init__(self, test_config_path: str = None, test_cases_path: str = None):
        self.project_root = PROJECT_ROOT
        self.test_config_path = test_config_path or os.path.join(self.project_root, 'configs', 'web_pt_config.yaml')
        self.test_cases_path = test_cases_path or os.path.join(self.project_root, 'test_cases', 'web_pt_cases.xlsx')

        self._web_actions_instance = None
        self._driver = None
        self.current_case_id = None
        self.response_time_data = []
        self.memory_usage_data = []

        self._load_configuration()
        self._initialize_components()

    def _load_configuration(self):
        self.test_config = ConfigManager.load_yaml(self.test_config_path)
        self.performance_test_loader = PerformanceTestLoader(self.test_cases_path, self.test_config)
        self.env_config = self._load_environment_config()
        self.main_config = self._load_main_config()

    def _load_main_config(self):
        web_environments = self.performance_test_loader.get_web_environments()
        active_env = self.test_config['active_environment']
        env_config = web_environments[web_environments['Environment'] == active_env].iloc[0].to_dict()
        return {
            'Target URL': env_config['TargetURL'],
            'Rounds': env_config['Rounds'],
            'Log Details': env_config['LogDetails']
        }

    def _load_environment_config(self):
        web_environments = self.performance_test_loader.get_web_environments()
        active_env = self.test_config['active_environment']
        env_config = web_environments[web_environments['Environment'] == active_env].iloc[0].to_dict()
        env_config['BrowserOptions'] = json.loads(env_config['BrowserOptions'])

        return {
            'environments': {
                active_env: {
                    'browser': env_config['Browser'],
                    'is_remote': env_config['IsRemote'],
                    'remote_url': env_config['RemoteURL'],
                    'chrome_path': env_config['ChromePath'],
                    'chrome_driver_path': env_config['ChromeDriverPath'],
                    'edge_path': env_config['EdgePath'],
                    'edge_driver_path': env_config['EdgeDriverPath'],
                    'browser_options': env_config['BrowserOptions']
                }
            }
        }

    def _initialize_components(self):
        self.test_cases = self.performance_test_loader.get_test_cases()
        self.test_functions = self.performance_test_loader.get_test_functions()
        self.sub_functions = self.performance_test_loader.get_sub_functions()
        self.locators = self.performance_test_loader.get_locators()
        self.page_elements = self._load_page_elements()
        self.custom_actions = self.performance_test_loader.get_custom_actions()

    @property
    def driver(self):
        if self._driver is None:
            active_env_config = self.env_config['environments'][self.test_config['active_environment']]
            self._driver = WebDriverFactory.create_driver(active_env_config)
        return self._driver

    @property
    def web_actions(self):
        if self._web_actions_instance is None:
            self._web_actions_instance = WebActions(self.driver)
        return self._web_actions_instance

    def get_js_memory(self):
        try:
            js_memory = self.driver.execute_script("return window.performance.memory;")
            if js_memory:
                used_js_memory_mb = js_memory.get("usedJSHeapSize", 0) / (1024 * 1024)
                return round(used_js_memory_mb, 2)
        except Exception as e:
            logging.error(f"Error in get_js_memory: {e}")
        return None

    def execute_single_test(self, case_id: str):
        case_name = self.test_cases[self.test_cases['Case ID'] == case_id]['Name'].iloc[0]
        logging.info(f"Executing test case: {case_id} - {case_name}")

        test_case = self.test_cases[self.test_cases['Case ID'] == case_id].iloc[0]
        if test_case['Run'] != 'Y':
            logging.warning(f"Test case {case_id} is not marked to run.")
            return

        rounds = int(self.main_config['Rounds'])
        target_url = self.main_config['Target URL']
        case_functions = self.test_functions[self.test_functions['Case ID'] == case_id].sort_values('Execution Order')

        for round_num in range(rounds):
            try:
                logging.info(f"Starting round {round_num + 1}/{rounds}")
                self.driver.get(target_url)

                memory_usage = self.get_js_memory()
                if memory_usage is not None:
                    self.memory_usage_data.append({
                        "round": round_num + 1,
                        "case_id": case_id,
                        "used_MB": memory_usage
                    })

                for _, function in case_functions.iterrows():
                    try:
                        function_name = function['Function Name']
                        self._execute_test_function(round_num, function_name, case_id)
                    except Exception as e:
                        logging.error(f"Error in function '{function_name}' during round {round_num + 1}: {e}")
                        # Continue with next function
                        continue

                logging.info(f"Completed round {round_num + 1}/{rounds}")

            except Exception as e:
                logging.error(f"Error in round {round_num + 1}: {e}")
                # Continue with next round
                continue

        logging.info(f"Finished executing test case: {case_id} - {case_name}")

    def _execute_test_function(self, round_num: int, function_name: str, case_id: str):
        function_steps = self.test_functions[self.test_functions['Function Name'] == function_name].iloc[0]

        try:
            # Execute precondition steps
            precondition_steps = self.sub_functions[
                self.sub_functions['Sub Function Name'] == function_steps['Precondition subFunction']
                ].sort_values('Step Order')

            for _, step in precondition_steps.iterrows():
                self._execute_step(step)

            # Execute and time operation steps
            operation_steps = self.sub_functions[
                self.sub_functions['Sub Function Name'] == function_steps['Operation subFunction']
                ].sort_values('Step Order')

            start_time = time.time()
            for _, step in operation_steps.iterrows():
                self._execute_step(step)
            end_time = time.time()

            response_time = round(end_time - start_time, 2)
            self.response_time_data.append({
                "round": round_num + 1,
                "case_id": case_id,
                "function_name": function_name,
                "response_time": response_time
            })

            # Execute postcondition steps
            postcondition_steps = self.sub_functions[
                self.sub_functions['Sub Function Name'] == function_steps['Postcondition subFunction']
                ].sort_values('Step Order')

            for _, step in postcondition_steps.iterrows():
                self._execute_step(step)

        except Exception as e:
            logging.error(f"Error executing function '{function_name}': {e}")
            raise  # Re-raise to be caught by execute_single_test

    def _execute_step(self, step: Dict):
        action_name = step['Action'].lower()
        page = step['Page']
        element = step['Element']
        input_value = step['Input Value (if applicable)']
        locator = self.page_elements[page][element] if element else None

        log_message = (
                f"{self.__class__.__name__}: Executing action:[{action_name}] on page:[{page}]"
                + (f" element:[{element}]" if element else "")
                + (f" with input:[{input_value}]" if input_value else "")
        )
        logging.info(log_message)

        logger = logging.getLogger()
        original_level = logger.level

        try:
            if self.main_config['Log Details'] != 'Y':
                logger.setLevel(logging.WARNING)

            if not hasattr(self.web_actions, action_name):
                raise ValueError(f"Unknown action type: {action_name}")

            action = getattr(self.web_actions, action_name)

            if locator is not None:
                action(locator, input_value) if input_value else action(locator)
            else:
                action(input_value) if input_value else action()

            logging.info("=" * 100)

        finally:
            if self.main_config['Log Details'] != 'Y':
                logger.setLevel(original_level)

    def _load_page_elements(self) -&gt; Dict[str, Dict[str, Tuple[str, str]]]:
        elements = {}
        for _, row in self.locators.iterrows():
            elements.setdefault(row['Page'], {})[row['Element']] = (row['Locator Type'], row['Locator Value'])
        return elements

    def generate_reports(self, case_id: str = None):
        if case_id is None:
            case_id = self.current_case_id

        case_name = self.test_cases[self.test_cases['Case ID'] == case_id]['Name'].iloc[0]
        filtered_response_time_data = [data for data in self.response_time_data if data['case_id'] == case_id]
        filtered_memory_usage_data = [data for data in self.memory_usage_data if data['case_id'] == case_id]

        reporter = WebPerformanceReporter(filtered_response_time_data, filtered_memory_usage_data)

        return {
            'memory_chart': reporter.generate_memory_usage_chart(case_id, case_name),
            'response_time_stats_chart': reporter.generate_response_time_statistics_chart(case_id, case_name),
            'response_time_trend_chart': reporter.generate_response_time_trend_chart(case_id, case_name),
            'response_time_table': reporter.generate_response_time_statistics_table(case_id, case_name)
        }

    def save_to_csv(self):
        reporter = WebPerformanceReporter(self.response_time_data, self.memory_usage_data)
        reporter.save_to_csv()

    def close(self):
        if self._driver:
            self._driver.quit()
            self._driver = None</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_performance_web_pt_loader_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\performance\web_pt_loader.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import json
import logging
import pandas as pd
import os
from typing import Dict, List

class PerformanceTestLoader:
    _instances = {}

    def __new__(cls, excel_path, test_config):
        key = (excel_path, id(test_config))  # Use a tuple of excel_path and test_config id as the key
        if key not in cls._instances:
            instance = super().__new__(cls)
            instance.__init__(excel_path, test_config)
            cls._instances[key] = instance
        return cls._instances[key]

    def __init__(self, excel_path, test_config):
        if hasattr(self, 'initialized'):
            return
        self.excel_path = excel_path
        self.test_config = test_config
        self.data = self._load_excel_data()
        self._validate_data()
        self.initialized = True

    def _load_excel_data(self) -&gt; Dict[str, pd.DataFrame]:
        sheets = [
            'TestCases', 'TestFunctions', 'SubFunctions', 'Locators', 'WebEnvironments', 'CustomActions'
        ]
        return {sheet: pd.read_excel(self.excel_path, sheet_name=sheet).fillna("") for sheet in sheets}

    def _validate_data(self):
        self._validate_test_cases()
        self._validate_test_functions()
        self._validate_sub_functions()
        self._validate_locators()
        self._validate_web_environments()
        self._validate_custom_actions()

    def _validate_test_cases(self):
        test_cases = self.get_data_by_sheet_name('TestCases')
        required_columns = ['Case ID', 'Description', 'Run']
        missing_columns = set(required_columns) - set(test_cases.columns)
        if missing_columns:
            logging.error(f"PerformanceTestLoader: Missing required columns in TestCases sheet: {', '.join(missing_columns)}")

        for index, row in test_cases.iterrows():
            if pd.isna(row['Case ID']) or row['Case ID'] == '':
                logging.error(f"PerformanceTestLoader: Empty Case ID in TestCases row {index + 2}")
            if row['Run'] not in ['Y', 'N']:
                logging.error(f"PerformanceTestLoader: Invalid Run value in TestCases row {index + 2}. Must be 'Y' or 'N'")

    def _validate_test_functions(self):
        test_functions = self.get_data_by_sheet_name('TestFunctions')
        required_columns = ['Case ID', 'Execution Order', 'Function Name', 'Precondition subFunction', 'Operation subFunction', 'Postcondition subFunction', 'Description']
        missing_columns = set(required_columns) - set(test_functions.columns)
        if missing_columns:
            logging.error(f"PerformanceTestLoader: Missing required columns in TestFunctions sheet: {', '.join(missing_columns)}")

        for index, row in test_functions.iterrows():
            if pd.isna(row['Case ID']) or row['Case ID'] == '':
                logging.error(f"PerformanceTestLoader: Empty Case ID in TestFunctions row {index + 2}")
            if pd.isna(row['Function Name']) or row['Function Name'] == '':
                logging.error(f"PerformanceTestLoader: Empty Function Name in TestFunctions row {index + 2}")

    def _validate_sub_functions(self):
        sub_functions = self.get_data_by_sheet_name('SubFunctions')
        required_columns = ['Sub Function Name', 'Step Order', 'Page', 'Element', 'Action', 'Input Value (if applicable)', 'Description']
        missing_columns = set(required_columns) - set(sub_functions.columns)
        if missing_columns:
            logging.error(f"PerformanceTestLoader: Missing required columns in SubFunctions sheet: {', '.join(missing_columns)}")

        for index, row in sub_functions.iterrows():
            if pd.isna(row['Sub Function Name']) or row['Sub Function Name'] == '':
                logging.error(f"PerformanceTestLoader: Empty Sub Function Name in SubFunctions row {index + 2}")

    def _validate_locators(self):
        locators = self.get_data_by_sheet_name('Locators')
        required_columns = ['Page', 'Element', 'Locator Type', 'Locator Value', 'Description']
        missing_columns = set(required_columns) - set(locators.columns)
        if missing_columns:
            logging.error(f"PerformanceTestLoader: Missing required columns in Locators sheet: {', '.join(missing_columns)}")

        for index, row in locators.iterrows():
            if pd.isna(row['Page']) or row['Page'] == '':
                logging.error(f"PerformanceTestLoader: Empty Page in Locators row {index + 2}")
            if pd.isna(row['Element']) or row['Element'] == '':
                logging.error(f"PerformanceTestLoader: Empty Element in Locators row {index + 2}")
            if row['Locator Type'] not in ['id', 'name', 'xpath', 'css', 'class', 'tag', 'link_text', 'partial_link_text']:
                logging.error(f"PerformanceTestLoader: Invalid Locator Type '{row['Locator Type']}' in Locators row {index + 2}")

    def _validate_web_environments(self):
        web_environments = self.get_data_by_sheet_name('WebEnvironments')

        if web_environments.empty:
            logging.error("PerformanceTestLoader: WebEnvironments sheet is empty or does not exist.")
            return

        required_columns = ['Environment', 'TargetURL', 'Rounds', 'LogDetails', 'Browser', 'IsRemote', 'RemoteURL', 'ChromePath', 'ChromeDriverPath', 'EdgePath', 'EdgeDriverPath',
                            'BrowserOptions']
        missing_columns = set(required_columns) - set(web_environments.columns)
        if missing_columns:
            logging.error(f"PerformanceTestLoader: Missing required columns in WebEnvironments sheet: {', '.join(missing_columns)}")
            return

        # Check if active_environment exists in WebEnvironments
        active_environment = self.test_config.get('active_environment')
        if active_environment and active_environment not in web_environments['Environment'].values:
            logging.error(f"PerformanceTestLoader: Active environment '{active_environment}' specified in config file does not exist in WebEnvironments sheet.")

        for index, row in web_environments.iterrows():
            if self.test_config.get('active_environment') != row['Environment']:
                continue
            if pd.isna(row['Environment']) or row['Environment'] == '':
                logging.error(f"PerformanceTestLoader: Empty Environment name in WebEnvironments row {index + 2}")

            if pd.isna(row['TargetURL']) or row['TargetURL'] == '':
                logging.error(f"PerformanceTestLoader: TargetURL cannot be empty in WebEnvironments row {index + 2}")

            if pd.isna(row['Rounds']) or row['Rounds'] == '':
                logging.error(f"PerformanceTestLoader: Rounds cannot be empty in WebEnvironments row {index + 2}")
            else:
                try:
                    rounds = int(row['Rounds'])
                    if rounds &lt;= 0:
                        logging.error(f"PerformanceTestLoader: Rounds must be a positive integer in WebEnvironments row {index + 2}")
                except ValueError:
                    logging.error(f"PerformanceTestLoader: Rounds must be a valid integer in WebEnvironments row {index + 2}")

            if row['Browser'].lower() not in ['chrome', 'edge']:
                logging.error(f"PerformanceTestLoader: Invalid Browser '{row['Browser']}' in WebEnvironments row {index + 2}. Must be 'chrome' or 'edge'.")

            if not isinstance(row['IsRemote'], bool):
                logging.error(f"PerformanceTestLoader: IsRemote must be a boolean value in WebEnvironments row {index + 2}")

            if row['IsRemote']:
                if pd.isna(row['RemoteURL']) or row['RemoteURL'] == '':
                    logging.error(f"PerformanceTestLoader: RemoteURL is required when IsRemote is True in WebEnvironments row {index + 2}")
            else:
                if row['Browser'].lower() == 'chrome':
                    for path_column in ['ChromePath', 'ChromeDriverPath']:
                        if pd.isna(row[path_column]) or row[path_column] == '':
                            logging.error(f"PerformanceTestLoader: {path_column} is required when IsRemote is False and Browser is Chrome in WebEnvironments row {index + 2}")
                        elif not os.path.exists(row[path_column]):
                            logging.warning(f"PerformanceTestLoader: {path_column} '{row[path_column]}' does not exist in WebEnvironments row {index + 2}")
                elif row['Browser'].lower() == 'edge':
                    for path_column in ['EdgePath', 'EdgeDriverPath']:
                        if pd.isna(row[path_column]) or row[path_column] == '':
                            logging.error(f"PerformanceTestLoader: {path_column} is required when IsRemote is False and Browser is Edge in WebEnvironments row {index + 2}")
                        elif not os.path.exists(row[path_column]):
                            logging.warning(f"PerformanceTestLoader: {path_column} '{row[path_column]}' does not exist in WebEnvironments row {index + 2}")

            try:
                if not pd.isna(row['BrowserOptions']) and row['BrowserOptions'] != '':
                    json.loads(row['BrowserOptions'])
            except json.JSONDecodeError:
                logging.error(f"PerformanceTestLoader: Invalid JSON in BrowserOptions in WebEnvironments row {index + 2}")

        logging.info("PerformanceTestLoader: WebEnvironments data validation completed.")

    def _validate_custom_actions(self):
        custom_actions = self.get_data_by_sheet_name('CustomActions')
        required_columns = ['Action Name', 'Description', 'Python Code']
        missing_columns = set(required_columns) - set(custom_actions.columns)
        if missing_columns:
            logging.error(f"PerformanceTestLoader: Missing required columns in CustomActions sheet: {', '.join(missing_columns)}")

        for index, row in custom_actions.iterrows():
            if pd.isna(row['Action Name']) or row['Action Name'] == '':
                logging.error(f"PerformanceTestLoader: Empty Action Name in CustomActions row {index + 2}")
            if pd.isna(row['Python Code']) or row['Python Code'] == '':
                logging.error(f"PerformanceTestLoader: Empty Python Code for Action '{row['Action Name']}' in CustomActions row {index + 2}")

    def get_data_by_sheet_name(self, sheet_name: str) -&gt; pd.DataFrame:
        return self.data.get(sheet_name, pd.DataFrame())

    def get_test_cases(self) -&gt; pd.DataFrame:
        return self.get_data_by_sheet_name('TestCases')

    def get_test_functions(self) -&gt; pd.DataFrame:
        return self.get_data_by_sheet_name('TestFunctions')

    def get_sub_functions(self) -&gt; pd.DataFrame:
        return self.get_data_by_sheet_name('SubFunctions')

    def get_locators(self) -&gt; pd.DataFrame:
        return self.get_data_by_sheet_name('Locators')

    def get_web_environments(self) -&gt; pd.DataFrame:
        return self.get_data_by_sheet_name('WebEnvironments')

    def get_custom_actions(self) -&gt; pd.DataFrame:
        return self.get_data_by_sheet_name('CustomActions')
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_performance_web_pt_reporter_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\performance\web_pt_reporter.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import os

import pandas as pd
import matplotlib.pyplot as plt
from io import BytesIO
import base64
import logging
from libraries.common.utility_helpers import PROJECT_ROOT


class WebPerformanceReporter:
    def __init__(self, response_time_data, memory_usage_data):
        self.response_time_data = response_time_data
        self.memory_usage_data = memory_usage_data

    def generate_memory_usage_chart(self, case_id, case_name):
        df = pd.DataFrame(self.memory_usage_data)
        plt.figure(figsize=(10, 6))
        plt.plot(df["round"], df["used_MB"], marker="o", label="Used Memory (MB)", color="blue")
        plt.title(f"JavaScript Memory Usage Trend - Case ID: {case_id}, Case Name: {case_name}")
        plt.xlabel("Round")
        plt.ylabel("Memory (MB)")
        plt.grid()
        plt.legend()
        return self._save_fig_as_base64()

    def generate_response_time_statistics_chart(self, case_id, case_name):
        df = pd.DataFrame(self.response_time_data)
        stats = df.groupby("function_name").agg({"response_time": ["mean", "max"]})
        stats.columns = ["Mean", "Max"]
        stats.reset_index(inplace=True)

        stats.plot(kind="bar", x="function_name", figsize=(10, 6), colormap="coolwarm")
        plt.title(f"Response Time Statistics - Case ID: {case_id}, Case Name: {case_name}")
        plt.xlabel("Function Name")
        plt.ylabel("Time (s)")
        plt.grid(axis="y")
        plt.xticks(rotation=45)
        return self._save_fig_as_base64()

    def generate_response_time_trend_chart(self, case_id, case_name):
        df = pd.DataFrame(self.response_time_data)
        plt.figure(figsize=(10, 6))
        for func in df["function_name"].unique():
            func_data = df[df["function_name"] == func]
            plt.plot(func_data["round"], func_data["response_time"], marker="o", label=func)

        plt.title(f"Response Time Trend - Case ID: {case_id}, Case Name: {case_name}")
        plt.xlabel("Round")
        plt.ylabel("Response Time (s)")
        plt.legend(title="Function Names")
        plt.grid()
        return self._save_fig_as_base64()

    def generate_response_time_statistics_table(self, case_id, case_name):
        df = pd.DataFrame(self.response_time_data)
        stats = df.groupby("function_name").agg({
            "response_time": [
                lambda x: round(x.mean(), 2),
                lambda x: round(x.max(), 2),
                lambda x: round(x.min(), 2),
                lambda x: round(x.median(), 2),
                lambda x: round(x.quantile(0.9), 2),
                lambda x: round(x.quantile(0.95), 2),
                lambda x: round(x.quantile(0.99), 2)
            ]
        }).reset_index()

        stats.columns = ["Function Name", "Mean (s)", "Max (s)", "Min (s)",
                         "Median (s)", "P90 (s)", "P95 (s)", "P99 (s)"]

        fig, ax = plt.subplots(figsize=(10, len(stats) * 0.5))
        ax.axis("tight")
        ax.axis("off")
        table = plt.table(cellText=stats.values, colLabels=stats.columns, cellLoc="center", loc="center")
        table.auto_set_font_size(False)
        table.set_fontsize(10)
        table.scale(1.3, 1.5)
        plt.title(f"Response Time Statistics Table - Case ID: {case_id}, Case Name: {case_name}", y=1.1)
        return self._save_fig_as_base64()

    def save_to_csv(self):
        output_dir = os.path.join(PROJECT_ROOT, 'report')
        response_time_data_path = os.path.join(output_dir, 'response_time_data.csv')
        memory_usage_data_path = os.path.join(output_dir, 'memory_usage_data.csv')

        if self.response_time_data:
            response_time_df = pd.DataFrame(self.response_time_data)
            response_time_df.to_csv(response_time_data_path, index=False)
            logging.info("Response time data saved to 'response_time_data.csv'.")

        if self.memory_usage_data:
            memory_usage_df = pd.DataFrame(self.memory_usage_data)
            memory_usage_df.to_csv(memory_usage_data_path, index=False)
            logging.info("Memory usage data saved to 'memory_usage_data.csv'.")

    def _save_fig_as_base64(self):
        buf = BytesIO()
        plt.savefig(buf, format="png", bbox_inches="tight")
        buf.seek(0)
        base64_image = base64.b64encode(buf.getvalue()).decode("utf-8")
        plt.close()
        return base64_image
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_performance_web_pt_robot_keyword_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\performance\web_pt_robot_keyword.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>from robot.api import logger
from libraries.performance.web_pt import WebPerformanceTester

class RobotFrameworkWebTester:
    ROBOT_LIBRARY_SCOPE = 'TEST SUITE'
    def __init__(self):
        self.tester = None

    def initialize_tester(self, test_config_path=None, test_cases_path=None):
        """Initialize the performance tester."""
        self.tester = WebPerformanceTester(test_config_path, test_cases_path)
        logger.info("Performance tester initialized successfully.")

    def execute_single_test(self, case_id: str):
        """Execute a single performance test case."""
        if not self.tester:
            raise ValueError("Tester is not initialized.")
        self.tester.execute_single_test(case_id)

    def generate_reports(self, case_id: str):
        """Generate performance reports (charts and tables) for a specific case."""
        if not self.tester:
            raise ValueError("Tester is not initialized.")

        report_data = self.tester.generate_reports(case_id)

        logger.info('&lt;h2&gt;Memory Usage Trend Chart&lt;/h2&gt;', html=True)
        logger.info(f'&lt;img src="data:image/png;base64,{report_data["memory_chart"]}" alt="Memory Usage Trend"/&gt;', html=True)

        logger.info('&lt;h2&gt;Response Time Statistics Chart&lt;/h2&gt;', html=True)
        logger.info(f'&lt;img src="data:image/png;base64,{report_data["response_time_stats_chart"]}" alt="Response Time Statistics"/&gt;', html=True)

        logger.info('&lt;h2&gt;Response Time Trend Chart&lt;/h2&gt;', html=True)
        logger.info(f'&lt;img src="data:image/png;base64,{report_data["response_time_trend_chart"]}" alt="Response Time Trend"/&gt;', html=True)

        logger.info('&lt;h2&gt;Response Time Statistics Table&lt;/h2&gt;', html=True)
        logger.info(f'&lt;img src="data:image/png;base64,{report_data["response_time_table"]}" alt="Response Time Statistics Table"/&gt;', html=True)


    def finalize_and_close_tester(self):
        """Finalize the test by saving data to CSV, then close the tester and release resources."""
        if self.tester:
            self.tester.save_to_csv()
            self.tester.close()
            logger.info("Tester finalized and closed successfully.")</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_robot___init___py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\robot\__init__.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre></pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_robot_case___init___py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\robot\case\__init__.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre></pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_robot_case_api_generator_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\robot\case\api_generator.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import os
import logging
from typing import Dict, List
import pandas as pd
from robot.api import TestSuite
from libraries.common.config_manager import ConfigManager
from libraries.common.utility_helpers import PROJECT_ROOT
from libraries.api.api_test_loader import APITestLoader
from libraries.robot.case.base_generator import RobotCaseGenerator

class APIRobotCaseGenerator(RobotCaseGenerator):
    def __init__(self, test_config_path: str = None, test_cases_path: str = None):
        self.project_root: str = PROJECT_ROOT
        self.test_config_path = test_config_path
        self.test_cases_path = test_cases_path
        self.test_config = None
        self.api_test_loader = None
        self.api_suite = None

    def load_configuration(self):
        self.test_config_path = self.test_config_path or os.path.join(self.project_root, 'configs', 'api_test_config.yaml')
        try:
            self.test_config: Dict = ConfigManager.load_yaml(self.test_config_path)
            logging.info(f"{self.__class__.__name__}: Configuration loaded successfully from {self.test_config_path}")
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error loading configuration: {str(e)}")
            raise

    def initialize_components(self):
        default_test_cases_path: str = os.path.join('test_cases', 'api_test_cases.xlsx')
        self.test_cases_path = (
            os.path.join(self.project_root, self.test_config.get('test_cases_path', default_test_cases_path))
            if self.test_cases_path is None
            else self.test_cases_path
        )

        if not os.path.exists(self.test_cases_path):
            logging.error(f"{self.__class__.__name__}: Test cases file not found at {self.test_cases_path}")
            raise FileNotFoundError(f"{self.__class__.__name__}: Test cases file does not exist: {self.test_cases_path}")

        self.api_test_loader = APITestLoader(self.test_cases_path)
        logging.info(f"{self.__class__.__name__}: Components initialized successfully")

    def create_test_suite(self, tc_id_list: List[str] = None, tags: List[str] = None, parent_suite=None) -&gt; TestSuite:
        self.api_suite = parent_suite or TestSuite('API TestSuite')
        self.api_suite.teardown.config(name='suite_teardown', args=[])

        self._configure_test_resources(self.api_suite)

        tc_id_list = tc_id_list or self.test_config.get('tc_id_list', [])
        tags = tags or self.test_config.get('tags', [])

        filtered_cases = self._filter_cases(tc_id_list, tags)

        self._create_test_cases(filtered_cases)

        logging.info(f"{self.__class__.__name__}: Test suite created successfully")
        return self.api_suite

    def create_test_case(self, suite, test_case):
        try:
            robot_api_test_name = f"{test_case['TCID']}"
            robot_api_test = suite.tests.create(
                name=robot_api_test_name,
                doc=test_case['Descriptions']
            )
            robot_api_test.body.create_keyword(name='api_sanity_check', args=[])
            self._add_test_tags(robot_api_test, test_case)
            robot_api_test.body.create_keyword(name='execute_api_test_case', args=[test_case['TCID']])
            self._configure_test_conditions(suite, robot_api_test, test_case)
            logging.info(f"{self.__class__.__name__}: Test case {test_case['TCID']} created successfully")
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error creating test case {test_case.get('TCID', 'Unknown')}: {str(e)}")
            raise

    def create_test_steps(self, robot_test, test_steps, data_set):
        # API tests don't have specific steps like Web or E2E tests
        pass

    def _filter_cases(self, tc_id_list: List[str], tags: List[str]) -&gt; pd.DataFrame:
        try:
            return self.api_test_loader.filter_cases(tcid_list=tc_id_list, tags=tags)
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Failed to filter test cases: {str(e)}")
            raise

    def _create_test_cases(self, filtered_cases: pd.DataFrame) -&gt; None:
        try:
            for index, row in filtered_cases.iterrows():
                suite_name = row['Suite']
                if suite_name not in [suite.name for suite in self.api_suite.suites]:
                    suite = self.api_suite.suites.create(name=suite_name)
                    self._configure_test_resources(suite)
                self.create_test_case(suite, row)
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error creating test cases: {str(e)}")
            raise

    def _configure_test_resources(self, suite) -&gt; None:
        test_cases_path_arg = os.path.normpath(self.test_cases_path).replace(os.path.sep, '/')
        suite.resource.imports.library(
            'libraries.api.api_test_keywords.APITestKeywords',
            args=[None, test_cases_path_arg]
        )

    def _add_test_tags(self, robot_api_test, test_case) -&gt; None:
        try:
            if 'Tags' in test_case and pd.notna(test_case['Tags']):
                tags = [tag.strip() for tag in test_case['Tags'].split(',')]
                for tag in tags:
                    robot_api_test.tags.add(tag)
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error adding tags to test case: {str(e)}")
            raise

    def _configure_test_conditions(self, suite, robot_api_test, test_case) -&gt; None:
        try:
            if pd.notna(test_case['Conditions']):
                conditions = test_case['Conditions'].splitlines()
                for condition in conditions:
                    self._process_condition(condition, suite, robot_api_test)
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error configuring test conditions: {str(e)}")
            raise

    def _process_condition(self, condition: str, suite, robot_api_test) -&gt; None:
        try:
            condition_mapping = {
                '[TestSetup]': (robot_api_test.setup, 'Test setup'),
                '[TestTeardown]': (robot_api_test.teardown, 'Test teardown'),
                '[SuiteSetup]': (suite.setup, 'Suite setup'),
                '[SuiteTeardown]': (suite.teardown, 'Suite teardown')
            }

            for condition_type, (config_object, condition_name) in condition_mapping.items():
                if condition_type in condition:
                    case_ids = condition.strip(condition_type).split(',')
                    config_object.config(
                        name='execute_conditions_cases',
                        args=[case_ids]
                    )
                    logging.info(f"{self.__class__.__name__}: Configured {condition_name} with case IDs: {case_ids}")
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error processing condition '{condition}': {str(e)}")
            raise</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_robot_case_base_generator_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\robot\case\base_generator.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>from abc import ABC, abstractmethod

class RobotCaseGenerator(ABC):
    @abstractmethod
    def load_configuration(self):
        pass

    @abstractmethod
    def initialize_components(self):
        pass

    @abstractmethod
    def create_test_suite(self, tc_id_list=None, tags=None, parent_suite=None):
        pass

    @abstractmethod
    def create_test_case(self, suite, test_case):
        pass

    @abstractmethod
    def create_test_steps(self, robot_test, test_steps, data_set):
        pass</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_robot_case_e2e_generator_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\robot\case\e2e_generator.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import os
import logging
from typing import Dict, List
import pandas as pd
from robot.api import TestSuite
from libraries.common.config_manager import ConfigManager
from libraries.common.utility_helpers import PROJECT_ROOT
from libraries.web.web_test_loader import WebTestLoader
from libraries.robot.case.base_generator import RobotCaseGenerator
from libraries.robot.case.api_generator import APIRobotCaseGenerator

class E2ERobotCaseGenerator(RobotCaseGenerator):
    def __init__(self, test_config_path: str = None, test_cases_path: str = None):
        self.project_root: str = PROJECT_ROOT
        self.test_config_path: str = test_config_path
        self.test_cases_path: str = test_cases_path
        self.test_config = None
        self.web_test_loader = None
        self.api_robot_generator = None
        self.robot_suite = None
        self.main_suite = None
        self.case_suite = None

    def load_configuration(self):
        """Load configuration from YAML file"""
        try:
            self.test_config_path = (
                os.path.join(self.project_root, 'configs', 'e2e_test_config.yaml')
                if self.test_config_path is None
                else self.test_config_path
            )
            self.test_config: Dict = ConfigManager.load_yaml(self.test_config_path)
            logging.info(f"{self.__class__.__name__}: Configuration loaded successfully")
        except FileNotFoundError:
            logging.error(f"{self.__class__.__name__}: Config file not found at {self.test_config_path}")
            raise
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error loading configuration: {str(e)}")
            raise

    def initialize_components(self):
        """Initialize test loaders and other components"""
        try:
            default_test_cases_path: str = os.path.join('test_cases', 'e2e_test_cases.xlsx')
            self.test_cases_path: str = (
                os.path.join(self.project_root, self.test_config.get('test_cases_path', default_test_cases_path))
                if self.test_cases_path is None
                else self.test_cases_path
            )

            if not os.path.exists(self.test_cases_path):
                logging.error(f"{self.__class__.__name__}: Test cases file not found at {self.test_cases_path}")
                raise FileNotFoundError(f"Test cases file does not exist: {self.test_cases_path}")

            self.web_test_loader = WebTestLoader(self.test_cases_path, self.test_config)
            self.api_robot_generator = APIRobotCaseGenerator(None, self.test_cases_path)
            self.api_robot_generator.load_configuration()
            self.api_robot_generator.initialize_components()
            logging.info(f"{self.__class__.__name__}: Components initialized successfully")
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error initializing components: {str(e)}")
            raise

    def create_test_suite(self, tc_id_list: List[str] = None, tags: List[str] = None, parent_suite=None) -&gt; TestSuite:
        """Create test suite with hierarchical structure"""
        try:
            self.robot_suite = TestSuite('End To End TestSuite')
            self._import_required_libraries(self.robot_suite)
            self.robot_suite.setup.config(name='set_environment_variables', args=[])

            tc_id_list = tc_id_list or self.test_config.get('tc_id_list', [])
            tags = tags or self.test_config.get('tags', [])
            test_cases = self.web_test_loader.filter_cases(tc_id_list, tags)

            if test_cases.empty:
                logging.warning(f"{self.__class__.__name__}: No test cases found matching criteria.")
                return self.robot_suite

            for _, test_case in test_cases.iterrows():
                suite_name = test_case['Suite']
                case_id = test_case['Case ID']

                # Create or get main suite layer
                if suite_name not in [suite.name for suite in self.robot_suite.suites]:
                    self.main_suite = self.robot_suite.suites.create(name=suite_name)
                    self._import_required_libraries(self.main_suite)
                else:
                    self.main_suite = next(suite for suite in self.robot_suite.suites if suite.name == suite_name)

                # Create or get case ID suite layer
                case_suite_name = f"Case_{case_id}"
                if case_suite_name not in [suite.name for suite in self.main_suite.suites]:
                    self.case_suite = self.main_suite.suites.create(name=case_suite_name)
                    self._import_required_libraries(self.case_suite)
                else:
                    self.case_suite = next(suite for suite in self.main_suite.suites if suite.name == case_suite_name)

                self.create_test_case(self.case_suite, test_case)

            self.robot_suite.teardown.config(name='close_browser', args=[])
            return self.robot_suite
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error creating test suite: {str(e)}")
            raise RuntimeError(f"Failed to create test suite: {str(e)}")

    def create_test_case(self, suite, test_case: Dict):
        """Create test case with data sets"""
        try:
            case_id = test_case['Case ID']
            test_steps = self.web_test_loader.get_test_steps(case_id)
            test_data_sets = self.web_test_loader.get_test_data(case_id)

            if not test_data_sets:
                logging.warning(f"{self.__class__.__name__}: No data sets found for test case {case_id}. Using empty data")
                test_data_sets = [{}]

            for data_set_index, data_set in enumerate(test_data_sets, 1):
                test_name = f"{case_id}.{data_set_index}"
                robot_test = suite.tests.create(name=test_name, doc=test_case['Descriptions'])
                robot_test.body.create_keyword(name='sanity_check', args=[])

                if 'Tags' in test_case and pd.notna(test_case['Tags']):
                    tags = [tag.strip() for tag in test_case['Tags'].split(',')]
                    for tag in tags:
                        robot_test.tags.add(tag)

                self.create_test_steps(robot_test, test_steps, data_set)
                logging.info(f"{self.__class__.__name__}: Test case {case_id}.{data_set_index} created successfully")

        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error creating test case {test_case.get('Case ID', 'Unknown')}: {str(e)}")
            raise

    def create_test_steps(self, robot_test, test_steps: List[Dict], data_set: Dict):
        """Create test steps for both UI and API tests"""
        try:
            for _, step in test_steps.iterrows():
                if step['Run'] == 'Y':
                    page_name = step['Page Name']
                    module_name = step['Module Name']

                    if module_name == 'API':
                        self._generate_api_step(step, robot_test)
                    else:
                        self._generate_ui_step(robot_test, page_name, module_name, data_set)

        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error creating test steps: {str(e)}")
            raise

    def _import_required_libraries(self, suite):
        """Import required Robot Framework libraries"""
        try:
            test_config_path_arg = os.path.normpath(self.test_config_path).replace(os.path.sep, '/')
            test_cases_path_arg = os.path.normpath(self.test_cases_path).replace(os.path.sep, '/')
            suite.resource.imports.library('libraries.robot.robot_test_executor.RobotTestExecutor', args=[test_config_path_arg, test_cases_path_arg])
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error importing required libraries: {str(e)}")
            raise

    def _generate_api_step(self, step, robot_test):
        """Generate API test steps using APIRobotCasesGenerator"""
        try:
            self.case_suite.tests.remove(robot_test)
            tc_id_list = step['APIs'].split(',')
            self.api_robot_generator.create_test_suite(tc_id_list, None, self.case_suite)
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error generating API step: {str(e)}")
            raise

    def _generate_ui_step(self, robot_test, page_name: str, module_name: str, params: Dict):
        """Generate UI test steps"""
        try:
            robot_test.body.create_keyword(name='execute_module', args=[page_name, module_name, params])
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error generating UI step for {page_name}.{module_name}: {str(e)}")
            raise</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_robot_case_unified_generator_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\robot\case\unified_generator.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>from libraries.robot.case.api_generator import APIRobotCaseGenerator
from libraries.robot.case.e2e_generator import E2ERobotCaseGenerator
from libraries.robot.case.web_generator import WebRobotCaseGenerator
from libraries.robot.case.web_pt_robot_generator import WebPerformanceRobotCaseGenerator


class RobotCaseGeneratorFactory:
    @staticmethod
    def get_generator(test_type):
        if test_type == "api":
            return APIRobotCaseGenerator()
        elif test_type == "web":
            return WebRobotCaseGenerator()
        elif test_type == "e2e":
            return E2ERobotCaseGenerator()
        elif test_type == "performance":
            return WebPerformanceRobotCaseGenerator()
        else:
            raise ValueError(f"Unsupported test type: {test_type}")

class UnifiedRobotCaseGenerator:
    def __init__(self, test_type):
        self.generator = RobotCaseGeneratorFactory.get_generator(test_type)

    def generate_test_cases(self, tc_id_list=None, tags=None):
        self.generator.load_configuration()
        self.generator.initialize_components()
        suite = self.generator.create_test_suite(tc_id_list, tags)
        return suite</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_robot_case_web_generator_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\robot\case\web_generator.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import os
import logging
from typing import Dict, List
import pandas as pd
from robot.api import TestSuite
from libraries.common.config_manager import ConfigManager
from libraries.common.utility_helpers import PROJECT_ROOT
from libraries.robot.case.base_generator import RobotCaseGenerator
from libraries.web.web_test_loader import WebTestLoader

class WebRobotCaseGenerator(RobotCaseGenerator):
    def __init__(self, test_config_path: str = None, test_cases_path: str = None):
        self.project_root: str = PROJECT_ROOT
        self.test_config_path: str = test_config_path
        self.test_cases_path: str = test_cases_path
        self.test_config = None
        self.web_test_loader = None
        self.robot_suite = None

    def load_configuration(self):
        try:
            self.test_config_path = (
                os.path.join(self.project_root, 'configs', 'web_test_config.yaml')
                if self.test_config_path is None
                else self.test_config_path
            )
            self.test_config: Dict = ConfigManager.load_yaml(self.test_config_path)
        except FileNotFoundError:
            logging.error(f"{self.__class__.__name__}: Config file not found at {self.test_config_path}")
            raise
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error loading configuration: {str(e)}")
            raise

    def initialize_components(self):
        try:
            default_test_cases_path: str = os.path.join('test_cases', 'web_test_cases.xlsx')
            self.test_cases_path: str = (
                os.path.join(self.project_root, self.test_config.get('test_cases_path', default_test_cases_path))
                if self.test_cases_path is None
                else self.test_cases_path
            )

            if not os.path.exists(self.test_cases_path):
                logging.error(f"{self.__class__.__name__}: Test cases file not found at {self.test_cases_path}")
                raise FileNotFoundError(f"Test cases file does not exist: {self.test_cases_path}")

            self.web_test_loader = WebTestLoader(self.test_cases_path, self.test_config)
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error initializing components: {str(e)}")
            raise

    def create_test_suite(self, tc_id_list: List[str] = None, tags: List[str] = None, parent_suite=None) -&gt; TestSuite:
        try:
            self.robot_suite = TestSuite('Web UI TestSuite')
            self._import_required_libraries(self.robot_suite)

            self.robot_suite.setup.config(name='set_environment_variables', args=[])

            tc_id_list = tc_id_list or self.test_config.get('tc_id_list', [])
            tags = tags or self.test_config.get('tags', [])
            test_cases = self.web_test_loader.filter_cases(tc_id_list, tags)

            if test_cases.empty:
                logging.warning(f"{self.__class__.__name__}: No test cases found matching criteria")
                return self.robot_suite

            for _, test_case in test_cases.iterrows():
                suite_name = test_case['Suite']
                if suite_name not in [suite.name for suite in self.robot_suite.suites]:
                    sub_suite = self.robot_suite.suites.create(name=suite_name)
                    self._import_required_libraries(sub_suite)
                self.create_test_case(sub_suite, test_case)

            self.robot_suite.teardown.config(name='close_browser', args=[])
            return self.robot_suite
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error creating test suite: {str(e)}")
            raise RuntimeError(f"Failed to create test suite: {str(e)}")

    def create_test_case(self, suite, test_case: Dict):
        try:
            case_id = test_case['Case ID']
            test_steps = self.web_test_loader.get_test_steps(case_id)
            test_data_sets = self.web_test_loader.get_test_data(case_id)

            if not test_data_sets:
                logging.warning(f"{self.__class__.__name__}: No data sets found for test case {case_id}. Using empty data")
                test_data_sets = [{}]

            for data_set_index, data_set in enumerate(test_data_sets, 1):
                test_name = f"UI.{case_id}.{data_set_index}"
                robot_test = suite.tests.create(name=test_name, doc=test_case['Descriptions'])
                robot_test.body.create_keyword(name='sanity_check', args=[])

                if 'Tags' in test_case and pd.notna(test_case['Tags']):
                    tags = [tag.strip() for tag in test_case['Tags'].split(',')]
                    for tag in tags:
                        robot_test.tags.add(tag)

                self.create_test_steps(robot_test, test_steps, data_set)
                logging.info(f"{self.__class__.__name__}: Test case {case_id}.{data_set_index} created successfully.")

        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error creating test case {test_case.get('Case ID', 'Unknown')}: {str(e)}")
            raise

    def create_test_steps(self, robot_test, test_steps: List[Dict], data_set: Dict):
        try:
            for _, step in test_steps.iterrows():
                if step['Run'] == 'Y':
                    page_name = step['Page Name']
                    module_name = step['Module Name']
                    self._generate_ui_step(robot_test, page_name, module_name, data_set)

        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error creating test steps: {str(e)}")
            raise

    def _import_required_libraries(self, suite):
        try:
            suite.resource.imports.library('libraries.robot.robot_test_executor.RobotTestExecutor')
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error importing required libraries: {str(e)}")
            raise

    def _generate_ui_step(self, robot_test, page_name: str, module_name: str, params: Dict):
        try:
            robot_test.body.create_keyword(name='execute_module', args=[page_name, module_name, params])
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error generating UI step for {page_name}.{module_name}: {str(e)}")
            raise</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_robot_case_web_pt_robot_generator_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\robot\case\web_pt_robot_generator.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import os
import logging
from typing import Dict, List
from robot.api import TestSuite
from libraries.common.config_manager import ConfigManager
from libraries.common.utility_helpers import PROJECT_ROOT
from libraries.robot.case.base_generator import RobotCaseGenerator
from libraries.performance.web_pt_loader import PerformanceTestLoader

class WebPerformanceRobotCaseGenerator(RobotCaseGenerator):
    def __init__(self, test_config_path: str = None, test_cases_path: str = None):
        self.project_root: str = PROJECT_ROOT
        self.test_config_path: str = test_config_path
        self.test_cases_path: str = test_cases_path
        self.test_config = None
        self.performance_test_loader = None
        self.robot_suite = None

    def load_configuration(self):
        try:
            self.test_config_path = (
                os.path.join(self.project_root, 'configs', 'web_pt_config.yaml')
                if self.test_config_path is None
                else self.test_config_path
            )
            self.test_config: Dict = ConfigManager.load_yaml(self.test_config_path)
        except FileNotFoundError:
            logging.error(f"{self.__class__.__name__}: Config file not found at {self.test_config_path}")
            raise
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error loading configuration: {str(e)}")
            raise

    def initialize_components(self):
        try:
            default_test_cases_path: str = os.path.join('test_cases', 'web_pt_cases.xlsx')
            self.test_cases_path: str = (
                os.path.join(self.project_root, self.test_config.get('test_cases_path', default_test_cases_path))
                if self.test_cases_path is None
                else self.test_cases_path
            )

            if not os.path.exists(self.test_cases_path):
                logging.error(f"{self.__class__.__name__}: Test cases file not found at {self.test_cases_path}")
                raise FileNotFoundError(f"Test cases file does not exist: {self.test_cases_path}")

            self.performance_test_loader = PerformanceTestLoader(self.test_cases_path, self.test_config)
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error initializing components: {str(e)}")
            raise

    def create_test_suite(self, tc_id_list: List[str] = None, tags: List[str] = None, parent_suite=None) -&gt; TestSuite:
        try:
            self.robot_suite = TestSuite('Web Performance TestSuite')
            self._import_required_libraries(self.robot_suite)

            test_cases = self.performance_test_loader.get_test_cases()

            for _, test_case in test_cases.iterrows():
                if test_case['Run'] == 'Y':
                    self.create_test_case(self.robot_suite, test_case)

            self.robot_suite.setup.config(name='initialize_tester', args=[])
            self.robot_suite.teardown.config(name='finalize_and_close_tester', args=[])
            return self.robot_suite
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error creating test suite: {str(e)}")
            raise RuntimeError(f"Failed to create test suite: {str(e)}")

    def create_test_case(self, suite, test_case: Dict):
        try:
            case_id = test_case['Case ID']
            test_name = f"Performance.{case_id}"
            robot_test = suite.tests.create(name=test_name, doc=test_case['Description'])
            self.create_test_steps(robot_test, case_id)
            logging.info(f"{self.__class__.__name__}: Test case {case_id} created successfully.")
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error creating test case {test_case.get('Case ID', 'Unknown')}: {str(e)}")
            raise

    def create_test_steps(self, robot_test, case_id, test_steps=None, data_set=None):
        try:
            robot_test.body.create_keyword(name='execute_single_test', args=[case_id])
            robot_test.body.create_keyword(name='generate_reports', args=[case_id])
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error creating test steps: {str(e)}")
            raise

    def _import_required_libraries(self, suite):
        try:
            suite.resource.imports.library('libraries.performance.web_pt_robot_keyword.RobotFrameworkWebTester')
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error importing required libraries: {str(e)}")
            raise</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_robot_custom_action_executor_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\robot\custom_action_executor.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import ast
from typing import Any, Dict
import inspect


class CustomActionExecutor:
    def __init__(self, custom_actions: Dict[str, str]):
        self.custom_actions = custom_actions
        self.parsed_actions = {}

    def execute_custom_action(self, action_name: str, element=None, web_actions=None, *args, **kwargs):
        if action_name not in self.custom_actions:
            raise ValueError(f"Custom action '{action_name}' not found")

        if action_name not in self.parsed_actions:
            code = self.custom_actions[action_name]
            try:
                parsed = ast.parse(code)
                # self._check_code_safety(parsed, action_name)
                self.parsed_actions[action_name] = code
            except SyntaxError:
                raise ValueError(f"Syntax error in custom action '{action_name}'")

        # 创建一个新的命名空间来执行代码
        namespace = {'element': element, 'web_action': web_actions, **kwargs}
        exec(self.parsed_actions[action_name], namespace)

        if 'execute' not in namespace:
            raise ValueError(f"Custom action '{action_name}' must define an 'execute' function")

        execute_func = namespace['execute']
        sig = inspect.signature(execute_func)

        # 检查 execute 函数是否需要 element 参数
        if 'element' in sig.parameters:
            return execute_func(element, web_actions, *args, **kwargs)
        else:
            return execute_func(web_actions, *args, **kwargs)

    def _check_code_safety(self, node, action_name):
        allowed_nodes = (
            ast.Module,
            ast.FunctionDef,
            ast.ClassDef,
            ast.Return,
            ast.Expr,
            ast.Call,
            ast.Name,
            ast.Attribute,
            ast.arguments,
            ast.arg,
            ast.Constant,
            ast.List,
            ast.Dict,
            ast.If,
            ast.For,
            ast.While,
            ast.Compare,
            ast.BinOp,
            ast.UnaryOp,
            ast.Assign,
            ast.AugAssign,
            ast.Break,
            ast.Continue,
            ast.Pass,
        )

        if not isinstance(node, allowed_nodes):
            raise ValueError(f"Unsupported Python construct in custom action '{action_name}': {type(node).__name__}")

        # 递归检查子节点
        # for child in ast.iter_child_nodes(node):
        #     self._check_code_safety(child, action_name)

        # 检查是否使用了不允许的内建函数
        if isinstance(node, ast.Call) and isinstance(node.func, ast.Name):
            disallowed_builtins = {'eval', 'exec', 'compile', '__import__', 'open'}
            if node.func.id in disallowed_builtins:
                raise ValueError(f"Use of '{node.func.id}' is not allowed in custom action '{action_name}'")</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_robot_robot_test_executor_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\robot\robot_test_executor.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import json
import logging
import os
import re
from typing import Dict, Tuple, List
from robot.api.deco import keyword
from libraries.web.web_actions import WebActions
from libraries.common.utility_helpers import PROJECT_ROOT
from libraries.common.config_manager import ConfigManager
from libraries.web.web_test_loader import WebTestLoader
from libraries.web.webdriver_factory import WebDriverFactory
from libraries.robot.custom_action_executor import CustomActionExecutor
from robot.libraries.BuiltIn import BuiltIn
from libraries.db.db_operator import DBOperator

builtin_lib = BuiltIn()


class WebDriverSingleton:
    _instance = None

    @classmethod
    def get_instance(cls, driver_config=None):
        logging.info("WebDriverSingleton: Getting WebDriver instance")
        if cls._instance is None:
            if driver_config is None:
                raise ValueError("WebDriverSingleton: Config path must be provided when creating the first instance")
            cls._instance = WebDriverFactory.create_driver(driver_config)
            logging.info("WebDriverSingleton: WebDriver instance created")
        return cls._instance

    @classmethod
    def quit(cls):
        if cls._instance:
            cls._instance.close()
            cls._instance = None
            logging.info("WebDriverSingleton: WebDriver instance closed")


class RobotTestExecutor:
    def __init__(self, test_config_path: str = None, test_cases_path: str = None):
        self.project_root = PROJECT_ROOT
        self.test_config_path = test_config_path or os.path.join(self.project_root, 'configs', 'web_test_config.yaml')
        self.test_cases_path = test_cases_path or os.path.join(self.project_root, 'test_cases', 'web_test_cases.xlsx')

        self._web_actions_instance = None
        self._driver = None
        self._load_configuration()
        self._initialize_components()
        self.database_operator = DBOperator()

    def _load_configuration(self):
        self.test_config = ConfigManager.load_yaml(self.test_config_path)
        self.web_test_loader = WebTestLoader(self.test_cases_path, self.test_config)
        self.env_config = self._load_environment_config()

    def _load_environment_config(self):
        environments = self.web_test_loader.get_web_environments()
        active_env = self.test_config['active_environment']
        builtin_lib.set_global_variable('${active_environment}', active_env)
        env_config = environments[environments['Environment'] == active_env].iloc[0].to_dict()
        env_config['BrowserOptions'] = json.loads(env_config['BrowserOptions'])

        return {
            'environments': {
                active_env: {
                    'browser': env_config['Browser'],
                    'is_remote': env_config['IsRemote'],
                    'remote_url': env_config['RemoteURL'],
                    'chrome_path': env_config['ChromePath'],
                    'chrome_driver_path': env_config['ChromeDriverPath'],
                    'edge_path': env_config['EdgePath'],
                    'edge_driver_path': env_config['EdgeDriverPath'],
                    'browser_options': env_config['BrowserOptions']
                }
            }
        }

    def _initialize_components(self):
        self.locators_df = self.web_test_loader.get_locators()
        self.page_object_df = self.web_test_loader.get_page_objects()
        self.page_elements = self._load_page_elements()
        self.page_modules = self._load_page_modules()
        self.custom_action_executor = CustomActionExecutor(self.web_test_loader.get_custom_actions())

    @property
    def driver(self):
        if self._driver is None:
            logging.info(f"{self.__class__.__name__}: Driver not yet initialized. It will be initialized when web_actions is used.")
        return self._driver

    @property
    def web_actions(self):
        if self._web_actions_instance is None:
            if self._driver is None:
                active_env_config = self.env_config['environments'][self.test_config['active_environment']]
                self._driver = WebDriverSingleton.get_instance(active_env_config)
                logging.info(f"{self.__class__.__name__}: Driver initialized lazily for web_actions.")
            self._web_actions_instance = WebActions(self._driver)
            logging.info(f"{self.__class__.__name__}: WebElementActions initialized.")
        return self._web_actions_instance

    def _load_page_elements(self) -&gt; Dict[str, Dict[str, Tuple[str, str]]]:
        elements = {}
        for _, row in self.locators_df.iterrows():
            elements.setdefault(row['Page Name'], {})[row['Element Name']] = (row['Locator Type'], row['Locator Value'])
        return elements

    def _load_page_modules(self) -&gt; Dict[str, Dict[str, List[Dict]]]:
        modules = {}
        for _, row in self.page_object_df.iterrows():
            action_info = {
                'element_name': row['Element Name'],
                'web_action': row['Actions'],
                'parameter_names': row['Parameter Name'].split(',') if row['Parameter Name'] else [],
                'highlight': row['Highlight'],
                'screen_capture': row['Screenshot'],
                'wait': row['Wait']
            }
            modules.setdefault(row['Page Name'], {}).setdefault(row['Module Name'], []).append(action_info)
        return modules

    @keyword
    def set_environment_variables(self):
        """设置环境变量为Robot Framework全局变量"""
        self.web_test_loader.set_global_variables()

    @keyword
    def close_browser(self):
        WebDriverSingleton.quit()

    @keyword
    def sanity_check(self) -&gt; None:
        skip_on_sanity_check_failure = BuiltIn().get_variable_value('${skip_on_sanity_check_failure}', default=False)
        if skip_on_sanity_check_failure:
            BuiltIn().skip("Skipping current test as sanity check failed.")
        else:
            logging.info(f"{self.__class__.__name__}: Sanity check succeeded, continuing with the test.")

    @keyword
    def execute_module(self, page_name: str, module_name: str, data_set: Dict = None):

        module_actions = self.page_modules[page_name][module_name]

        for action_info in module_actions:
            element_name = action_info['element_name']
            action = action_info['web_action']
            highlight = action_info['highlight']
            screen_capture = action_info['screen_capture']
            wait = action_info['wait']
            locator = self.page_elements[page_name][element_name] if element_name else None
            action_params = self._extract_parameters(data_set, action_info['parameter_names'])
            element_desc = f'{page_name}.{module_name}.{element_name}' if element_name else f'{page_name}.{module_name}'

            logging.info(
                f"{self.__class__.__name__}: Executing action:[{action}] on page:[{page_name}] module:[{module_name}]"
                + (f" element:[{element_name}]" if element_name else "")
                + (f" with parameters:{action_params}" if action_params else "")
            )

            new_args = self._resolve_variable_in_parameters(action_params, action)

            if highlight:
                self.execute_action('highlight_element', locator, element_desc)

            # Unified call to execute_action
            self.execute_action(action, locator, element_desc, *new_args, )

            if wait:
                try:
                    wait_time = float(wait)
                    if wait_time &gt; 0:
                        self.execute_action('wait', locator, element_desc, wait_time)
                except ValueError:
                    logging.warning(f"Invalid wait value: {wait}. Skipping wait.")

            if screen_capture:
                self.execute_action('capture_screenshot', locator, element_desc)

            logging.info("=" * 80)

    def execute_action(self, action_name, element, element_desc, *args, **kwargs):
        logging.debug(f"WebActionExecutor: Executing action '{action_name}' with element: {element}, args: {args}, kwargs: {kwargs}")

        db_actions = {
            "insert_data": self.database_operator.insert_data,
            "update_data": self.database_operator.update_data,
            "delete_data": self.database_operator.delete_data,
        }

        if hasattr(self.web_actions, action_name):
            action = getattr(self.web_actions, action_name)

            if 'locator' in action.__code__.co_varnames:
                kwargs['element_desc'] = element_desc
                result = action(element, *args, **kwargs)
            elif 'locator' not in action.__code__.co_varnames:
                result = action(*args, **kwargs)
            else:
                raise ValueError(f"Action '{action_name}' requires a WebElement, but none was provided.")

            logging.debug(f"WebActionExecutor: Action '{action_name}' executed successfully")
            return result
        elif action_name in db_actions:
            db_actions[action_name](*args)
            logging.debug(f"DBActionExecutor: Action '{action_name}' executed successfully")
            return
        elif action_name in self.custom_action_executor.custom_actions:
            self.custom_action_executor.execute_custom_action(action_name, element, self.web_actions, *args)
            logging.debug(f"CustomActionExecutor: Action '{action_name}' executed successfully")
            return
        else:
            error_msg = f"Unsupported action: '{action_name}'"
            logging.error(f"ActionExecutor: {error_msg}")
            raise ValueError(error_msg)

    def _extract_parameters(self, data_set: Dict, parameter_names: List[str]) -&gt; List:
        try:
            parameters = []
            if data_set and parameter_names:
                for name in parameter_names:
                    if name in data_set:
                        parameters.append(data_set[name])
                    else:
                        logging.warning(f"{self.__class__.__name__}: Parameter {name} not found in data set")
            return parameters
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: PageObject: Error extracting parameters: {str(e)}")
            raise

    def _resolve_variable_in_parameters(self, action_params, action):
        new_args = []
        for arg in action_params:
            if isinstance(arg, str):
                # 使用正则匹配所有 ${...} 格式的变量
                matches = re.findall(r'\$\{([^}]+)\}', arg)
                if matches:
                    for match in matches:
                        replacement_value = builtin_lib.get_variable_value(f'${{{match}}}')
                        arg = arg.replace(f'${{{match}}}', str(replacement_value))
                        logging.info(
                            f"{self.__class__.__name__}: Replaced {match} with value: {replacement_value} for web_action: {action}"
                        )
            new_args.append(arg)
        return new_args
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web___init___py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\__init__.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre></pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action___init___py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\web_action\__init__.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre></pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_alert_actions_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\web_action\alert_actions.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>from .base import Base
import logging

class AlertActions(Base):
    def accept_alert(self):
        logging.info(f"{self.__class__.__name__}: Accepting alert")
        self.driver.switch_to.alert.accept()
        logging.info(f"{self.__class__.__name__}: Alert accepted successfully")

    def dismiss_alert(self):
        logging.info(f"{self.__class__.__name__}: Dismissing alert")
        self.driver.switch_to.alert.dismiss()
        logging.info(f"{self.__class__.__name__}: Alert dismissed successfully")

    def get_alert_text(self):
        logging.info(f"{self.__class__.__name__}: Getting alert text")
        alert_text = self.driver.switch_to.alert.text
        logging.info(f"{self.__class__.__name__}: Alert text retrieved: '{alert_text}'")
        return alert_text</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_base_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\web_action\base.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import logging
from selenium.webdriver.remote.webdriver import WebDriver
from selenium.webdriver.remote.webelement import WebElement
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException
from libraries.web.web_action.table_verifier import TableVerifier


class Base:
    def __init__(self, driver: WebDriver, default_timeout: int = 60):
        self.driver = driver
        self.default_timeout = default_timeout
        self.table_verifier = TableVerifier(self.driver)

    def _get_element_description(self, element):
        if isinstance(element, WebElement):
            tag_name = element.tag_name
            element_id = element.get_attribute('id')
            element_class = element.get_attribute('class')
            element_name = element.get_attribute('name')
            element_text = element.text[:30] if element.text else ''

            description = f"&lt;{tag_name}"
            if element_id:
                description += f" id='{element_id}'"
            if element_class:
                classes = element_class.split()
                if len(classes) &gt; 2:
                    description += f" class='{' '.join(classes[:2])}...'"
                else:
                    description += f" class='{element_class}'"
            if element_name:
                description += f" name='{element_name}'"
            description += "&gt;"
            if element_text:
                description += f" text='{element_text}...'"

            return description
        elif isinstance(element, tuple):
            return f"locator: {element}"
        else:
            return str(element)

    def _resolve_element(self, element, element_desc, condition, timeout=None):
        """ 解析元素，若传入的是 locator 元组，则等待元素加载 """
        if isinstance(element, tuple):
            return self.wait_for_element(element, element_desc, condition=condition, timeout=timeout)
        return element

    def wait_for_element(self, locator, element_desc=None, condition="presence", timeout=None):
        if timeout is None:
            timeout = self.default_timeout

        logging.debug(f"{self.__class__.__name__}: Waiting for element {element_desc} with locator {locator}, condition: {condition}, timeout: {timeout}")
        wait = WebDriverWait(self.driver, timeout)

        try:
            if condition == "presence":
                result = wait.until(EC.presence_of_element_located(locator))
            elif condition == "visibility":
                result = wait.until(EC.visibility_of_element_located(locator))
            elif condition == "clickable":
                result = wait.until(EC.element_to_be_clickable(locator))
            elif condition == "invisibility":
                result = wait.until(EC.invisibility_of_element_located(locator))
            else:
                raise ValueError(f"{self.__class__.__name__}: Unsupported condition: {condition}")

            element_desc = element_desc or self._get_element_description(result)
            logging.info(f"{self.__class__.__name__}: Element found {element_desc} with locator {locator}, condition: {condition}.")
            return result
        except TimeoutException:
            logging.error(f"{self.__class__.__name__}: Timeout waiting for element {element_desc} with locator {locator}, condition: {condition}, timeout: {timeout}")
            raise
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_cookie_actions_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\web_action\cookie_actions.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>from .base import Base
import logging

class CookieActions(Base):
    def add_cookie(self, cookie_dict):
        logging.info(f"{self.__class__.__name__}: Adding cookie: {cookie_dict}")
        self.driver.add_cookie(cookie_dict)
        logging.info(f"{self.__class__.__name__}: Cookie added successfully")

    def get_cookie(self, name):
        logging.info(f"{self.__class__.__name__}: Getting cookie with name: '{name}'")
        cookie = self.driver.get_cookie(name)
        logging.info(f"{self.__class__.__name__}: Cookie retrieved: {cookie}")
        return cookie

    def delete_cookie(self, name):
        logging.info(f"{self.__class__.__name__}: Deleting cookie with name: '{name}'")
        self.driver.delete_cookie(name)
        logging.info(f"{self.__class__.__name__}: Cookie deleted successfully")

    def delete_all_cookies(self):
        logging.info(f"{self.__class__.__name__}: Deleting all cookies")
        self.driver.delete_all_cookies()
        logging.info(f"{self.__class__.__name__}: All cookies deleted successfully")</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_decorators_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\web_action\decorators.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import time


def timer(func):
    """计算方法执行时间的装饰器"""
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f'Function {func.__name__} execution time: {end - start} seconds')
        return result

    return wrapper</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_element_actions_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\web_action\element_actions.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>from selenium.webdriver import ActionChains
from selenium.webdriver.support.select import Select
import logging
from .base import Base


class ElementActions(Base):
    def send_keys(self, locator, value, element_desc=None, condition="presence"):
        element = self._resolve_element(locator, element_desc, condition)
        element_desc = element_desc or self._get_element_description(locator)
        logging.debug(f"{self.__class__.__name__}: Sending keys to element [ {element_desc}:{locator} ] with value: [ {value} ].")
        element.send_keys(value)
        logging.info(f"{self.__class__.__name__}: Sent keys to element [ {element_desc}:{locator} ] with value: [ {value} ] successfully.")

    def click(self, locator, element_desc=None, condition="clickable"):
        element = self._resolve_element(locator, element_desc, condition)
        element_desc = element_desc or self._get_element_description(locator)
        logging.debug(f"{self.__class__.__name__}: Clicking element [ {element_desc}:{locator} ].")
        element.click()
        logging.info(f"{self.__class__.__name__}: Clicked element [ {element_desc}:{locator} ] successfully.")

    def clear(self, locator, element_desc=None, condition="presence"):
        element = self._resolve_element(locator, element_desc, condition)
        element_desc = element_desc or self._get_element_description(locator)
        logging.debug(f"{self.__class__.__name__}: Clearing element [ {element_desc}:{locator} ].")
        element.clear()
        logging.info(f"{self.__class__.__name__}: Cleared element [ {element_desc}:{locator} ] successfully.")

    def get_text(self, locator, element_desc=None, condition="presence"):
        element = self._resolve_element(locator, element_desc, condition)
        element_desc = element_desc or self._get_element_description(locator)
        logging.debug(f"{self.__class__.__name__}: Getting text from element [ {element_desc}:{locator} ].")
        text = element.text
        logging.info(f"{self.__class__.__name__}: Got text '{text}' from element [ {element_desc}:{locator} ] successfully.")
        return text

    def get_attribute(self, locator, attribute_name, element_desc=None, condition="presence"):
        element = self._resolve_element(locator, element_desc, condition)
        element_desc = element_desc or self._get_element_description(locator)
        logging.debug(f"{self.__class__.__name__}: Getting attribute '{attribute_name}' from element [ {element_desc}:{locator} ].")
        attribute_value = element.get_attribute(attribute_name)
        logging.info(f"{self.__class__.__name__}: Got attribute '{attribute_name}'='{attribute_value}' from element [ {element_desc}:{locator} ] successfully.")
        return attribute_value

    def select_by_value(self, locator, value, element_desc=None, condition="presence"):
        element = self._resolve_element(locator, element_desc, condition)
        element_desc = element_desc or self._get_element_description(locator)
        logging.debug(f"{self.__class__.__name__}: Selecting option by value '{value}' for element [ {element_desc}:{locator} ].")
        Select(element).select_by_value(value)
        logging.info(f"{self.__class__.__name__}: Selected option by value '{value}' for element [ {element_desc}:{locator} ] successfully.")

    def select_by_visible_text(self, locator, text, element_desc=None, condition="presence"):
        element = self._resolve_element(locator, element_desc, condition)
        element_desc = element_desc or self._get_element_description(locator)
        logging.debug(f"{self.__class__.__name__}: Selecting option by visible text '{text}' for element [ {element_desc}:{locator} ].")
        Select(element).select_by_visible_text(text)
        logging.info(f"{self.__class__.__name__}: Selected option by visible text '{text}' for element [ {element_desc}:{locator} ] successfully.")

    def select_by_index(self, locator, index, element_desc=None, condition="presence"):
        element = self._resolve_element(locator, element_desc, condition)
        element_desc = element_desc or self._get_element_description(locator)
        logging.debug(f"{self.__class__.__name__}: Selecting option at index '{index}' for element [ {element_desc}:{locator} ].")
        Select(element).select_by_index(int(index))
        logging.info(f"{self.__class__.__name__}: Selected option at index '{index}' for element [ {element_desc}:{locator} ] successfully.")

    def hover(self, locator, element_desc=None, condition="visibility"):
        element = self._resolve_element(locator, element_desc, condition)
        element_desc = element_desc or self._get_element_description(locator)
        logging.debug(f"{self.__class__.__name__}: Hovering over element [ {element_desc}:{locator} ].")
        ActionChains(self.driver).move_to_element(element).perform()
        logging.info(f"{self.__class__.__name__}: Hovered over element [ {element_desc}:{locator} ] successfully.")

    def double_click(self, locator, element_desc=None, condition="clickable"):
        element = self._resolve_element(locator, element_desc, condition)
        element_desc = element_desc or self._get_element_description(locator)
        logging.debug(f"{self.__class__.__name__}: Double clicking element [ {element_desc}:{locator} ].")
        ActionChains(self.driver).double_click(element).perform()
        logging.info(f"{self.__class__.__name__}: Double clicked element [ {element_desc}:{locator} ] successfully.")

    def right_click(self, locator, element_desc=None, condition="clickable"):
        element = self._resolve_element(locator, element_desc, condition)
        element_desc = element_desc or self._get_element_description(locator)
        logging.debug(f"{self.__class__.__name__}: Right clicking element [ {element_desc}:{locator} ].")
        ActionChains(self.driver).context_click(element).perform()
        logging.info(f"{self.__class__.__name__}: Right clicked element [ {element_desc}:{locator} ] successfully.")

    def select_radio(self, locator, element_desc=None, condition="clickable"):
        element = self._resolve_element(locator, element_desc, condition)
        element_desc = element_desc or self._get_element_description(locator)
        logging.debug(f"{self.__class__.__name__}: Selecting radio button [ {element_desc}:{locator} ].")
        element.click()
        logging.info(f"{self.__class__.__name__}: Selected radio button [ {element_desc}:{locator} ] successfully.")

    def select_radio_by_value(self, locator, value, element_desc=None, condition="clickable"):
        formatted_locator = (locator[0], locator[1].format(value))
        element = self._resolve_element(formatted_locator, element_desc, condition)
        element_desc = element_desc or self._get_element_description(formatted_locator)
        logging.debug(f"{self.__class__.__name__}: Selecting radio button with value '{value}' in radio group [ {element_desc}:{formatted_locator} ].")
        element.click()
        logging.info(f"{self.__class__.__name__}: Selected radio button with value '{value}' in radio group [ {element_desc}:{formatted_locator} ] successfully.")
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_javascript_actions_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\web_action\javascript_actions.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>from .base import Base
import logging
from .js import click_by_js_script, fill_by_js_script


class JavaScriptActions(Base):
    def execute_script(self, script, *args):
        logging.debug(f"{self.__class__.__name__}: Executing JavaScript: {script}, Arguments: {args}")
        result = self.driver.execute_script(script, *args)
        logging.info(f"{self.__class__.__name__}: JavaScript executed successfully, Result: {result}")
        return result

    def execute_async_script(self, script, *args):
        logging.debug(f"{self.__class__.__name__}: Executing asynchronous JavaScript: {script}, Arguments: {args}")
        result = self.driver.execute_async_script(script, *args)
        logging.info(f"{self.__class__.__name__}: Asynchronous JavaScript executed successfully, Result: {result}")
        return result

    def js_scroll_into_view(self, locator, element_desc=None, condition="presence"):
        element = self._resolve_element(locator, element_desc, condition)
        element_desc = element_desc or self._get_element_description(locator)
        logging.debug(f"{self.__class__.__name__}: Scrolling element [ {element_desc}:{locator} ] into view using JavaScript.")
        self.driver.execute_script("arguments[0].scrollIntoView(true);", element)
        logging.info(f"{self.__class__.__name__}: Scrolled element [ {element_desc}:{locator} ] into view using JavaScript successfully.")

    def js_scroll_to_element(self, locator, element_desc=None, condition="presence"):
        element = self._resolve_element(locator, element_desc, condition)
        element_desc = element_desc or self._get_element_description(locator)
        logging.debug(f"{self.__class__.__name__}: Scrolling to element [ {element_desc}:{locator} ] with smooth behavior using JavaScript.")
        self.driver.execute_script("arguments[0].scrollIntoView({behavior: 'smooth', block: 'center', inline: 'nearest'});", element)
        logging.info(f"{self.__class__.__name__}: Scrolled to element [ {element_desc}:{locator} ] with smooth behavior using JavaScript successfully.")

    def click_by_js(self, locator, element_desc=None, condition="clickable"):
        element = self._resolve_element(locator, element_desc, condition)
        element_desc = element_desc or self._get_element_description(locator)
        logging.debug(f"{self.__class__.__name__}: Clicking element [ {element_desc}:{locator} ] using JavaScript.")
        js = click_by_js_script
        self.driver.execute_script(js, element)
        logging.info(f"{self.__class__.__name__}: Clicked element [ {element_desc}:{locator} ] using JavaScript successfully.")

    def fill_by_js(self, locator, value, element_desc=None, condition="presence"):
        element = self._resolve_element(locator, element_desc, condition)
        element_desc = element_desc or self._get_element_description(locator)
        logging.debug(f"{self.__class__.__name__}: Sending keys to element [ {element_desc}:{locator} ] using JavaScript with value: [ {value} ].")
        js = fill_by_js_script.format(text=value)
        self.driver.execute_script(js, element)
        logging.info(f"{self.__class__.__name__}: Sent keys to element [ {element_desc}:{locator} ] using JavaScript with value: [ {value} ] successfully.")

    def js_click(self, locator, element_desc=None, condition="clickable"):
        element = self._resolve_element(locator, element_desc, condition)
        element_desc = element_desc or self._get_element_description(locator)
        logging.debug(f"{self.__class__.__name__}: Clicking element [ {element_desc}:{locator} ] using JavaScript.")
        self.driver.execute_script("arguments[0].click();", element)
        logging.info(f"{self.__class__.__name__}: Clicked element [ {element_desc}:{locator} ] using JavaScript successfully.")

    def js_send_keys(self, locator, value, element_desc=None, condition="presence"):
        element = self._resolve_element(locator, element_desc, condition)
        element_desc = element_desc or self._get_element_description(locator)
        logging.debug(f"{self.__class__.__name__}: Sending keys to element [ {element_desc}:{locator} ] using JavaScript with value: [ {value} ].")
        self.driver.execute_script(f"arguments[0].value = '{value}';", element)
        logging.info(f"{self.__class__.__name__}: Sent keys to element [ {element_desc}:{locator} ] using JavaScript with value: [ {value} ] successfully.")

    def js_clear(self, locator, element_desc=None, condition="presence"):
        element = self._resolve_element(locator, element_desc, condition)
        element_desc = element_desc or self._get_element_description(locator)
        logging.debug(f"{self.__class__.__name__}: Clearing element [ {element_desc}:{locator} ] using JavaScript.")
        self.driver.execute_script("arguments[0].value = '';", element)
        logging.info(f"{self.__class__.__name__}: Cleared element [ {element_desc}:{locator} ] using JavaScript successfully.")

    def js_select_option(self, locator, option_text, element_desc=None, condition="presence"):
        element = self._resolve_element(locator, element_desc, condition)
        element_desc = element_desc or self._get_element_description(locator)
        logging.debug(f"{self.__class__.__name__}: Selecting option [ {option_text} ] for element [ {element_desc}:{locator} ] using JavaScript.")
        self.driver.execute_script(
            "var select = arguments[0];"
            "for(var i = 0; i &lt; select.options.length; i++) {"
            "  if(select.options[i].text == arguments[1]) {"
            "    select.options[i].selected = true;"
            "    var event = new Event('change', { bubbles: true });"
            "    select.dispatchEvent(event);"
            "    break;"
            "  }"
            "}", element, option_text
        )
        logging.info(f"{self.__class__.__name__}: Selected option [ {option_text} ] for element [ {element_desc}:{locator} ] using JavaScript successfully.")

    def js_hover(self, locator, element_desc=None, condition="visibility"):
        element = self._resolve_element(locator, element_desc, condition)
        element_desc = element_desc or self._get_element_description(locator)
        logging.debug(f"{self.__class__.__name__}: Hovering over element [ {element_desc}:{locator} ] using JavaScript.")
        self.driver.execute_script(
            "var event = new MouseEvent('mouseover', {"
            "  'view': window,"
            "  'bubbles': true,"
            "  'cancelable': true"
            "});"
            "arguments[0].dispatchEvent(event);", element
        )
        logging.info(f"{self.__class__.__name__}: Hovered over element [ {element_desc}:{locator} ] using JavaScript successfully.")
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_js_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\web_action\js.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>fill_by_js_script = '''
    function setNativeValue(element,value) {{
        const {{
            set: valueSetter
        }} = Object.getOwnPropertyDescriptor(element,'value') || {{}};
        const prototype = Object.getPrototypeOf(element);
        const {{
            set: prototypeValueSetter
        }} = Object.getOwnPropertyDescriptor(prototype,'value') || {{}};

        if (prototypeValueSetter &amp;&amp; valueSetter !== prototypeValueSetter) {{
            prototypeValueSetter.call(element,value);
        }}

        else if (valueSetter) {{
            valueSetter.call(element,value);
        }} else {{
            throw new Error('The given element does not have a value setter');
        }}
    }}
    function fireEvent(element,value) {{
    setNativeValue(element,value);
    element.dispatchEvent(new Event('change',{{bubbles: true}}));
    }}
    fireEvent(arguments[0], '{text}')
'''

click_by_js_script = '''
    function clickByJsFireEvent(element) {
        // Check if the element is not null and is an instance of HTMLElement
        if (element instanceof HTMLElement) {
            element.click(); // Programmatically click the element
            element.dispatchEvent(new Event('click', { bubbles: true })); // Dispatch the click event, making it bubble up
        } else {
            throw new Error('The given element is not a valid HTML element');
        }
    }
    clickByJsFireEvent(arguments[0]);
'''
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_navigation_actions_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\web_action\navigation_actions.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>from .base import Base
import logging

class NavigationActions(Base):
    def open_url(self, url):
        logging.info(f"{self.__class__.__name__}: Opening URL: {url}")
        # self.driver.maximize_window()
        self.driver.get(url)
        logging.info(f"{self.__class__.__name__}: URL opened successfully: {url}")

    def refresh_page(self):
        logging.info(f"{self.__class__.__name__}: Refreshing the current page")
        self.driver.refresh()
        logging.info(f"{self.__class__.__name__}: Page refreshed successfully")

    def go_back(self):
        logging.info(f"{self.__class__.__name__}: Navigating back in browser history")
        self.driver.back()
        logging.info(f"{self.__class__.__name__}: Navigated back successfully")

    def go_forward(self):
        logging.info(f"{self.__class__.__name__}: Navigating forward in browser history")
        self.driver.forward()
        logging.info(f"{self.__class__.__name__}: Navigated forward successfully")

    def get_current_url(self):
        logging.info(f"{self.__class__.__name__}: Getting current URL")
        url = self.driver.current_url
        logging.info(f"{self.__class__.__name__}: Current URL is: '{url}'")
        return url</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_table_actions_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\web_action\table_actions.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>from .base import Base
from typing import Union, List, Dict
from selenium.webdriver.remote.webelement import WebElement
import logging

class TableActions(Base):
    def verify_table_exact(self, table_locator: Union[tuple, WebElement], expected_data: List[Dict[str, str]]):
        logging.info(f"{self.__class__.__name__}: Verifying entire table with exact match")
        table_element = self.wait_for_element(table_locator) if isinstance(table_locator, tuple) else table_locator
        table_desc = self._get_element_description(table_element)
        self.table_verifier.verify_table(table_element, expected_data, match_type='exact')
        logging.info(f"{self.__class__.__name__}: Table verification (exact match) completed for table: {table_desc}")

    def verify_table_row_exact(self, table_locator: Union[tuple, WebElement], row_index: int, expected_data: Dict[str, str]):
        logging.info(f"{self.__class__.__name__}: Verifying table row at index {row_index} with exact match")
        table_element = self.wait_for_element(table_locator) if isinstance(table_locator, tuple) else table_locator
        table_desc = self._get_element_description(table_element)
        self.table_verifier.verify_table_row(table_element, row_index, expected_data, match_type='exact')
        logging.info(f"{self.__class__.__name__}: Table row verification (exact match) completed for table: {table_desc}, row: {row_index}")

    def verify_specific_cell_exact(self, table_locator: Union[tuple, WebElement], row_index: int, column: Union[str, int], expected_value: str):
        logging.info(f"{self.__class__.__name__}: Verifying specific cell at row {row_index}, column {column} with exact match")
        table_element = self.wait_for_element(table_locator) if isinstance(table_locator, tuple) else table_locator
        table_desc = self._get_element_description(table_element)
        self.table_verifier.verify_specific_cell(table_element, row_index, column, expected_value, match_type='exact')
        logging.info(f"{self.__class__.__name__}: Specific cell verification (exact match) completed for table: {table_desc}, row: {row_index}, column: {column}")

    def verify_table_partial(self, table_locator: Union[tuple, WebElement], expected_data: List[Dict[str, str]]):
        logging.info(f"{self.__class__.__name__}: Verifying entire table with partial match")
        table_element = self.wait_for_element(table_locator) if isinstance(table_locator, tuple) else table_locator
        table_desc = self._get_element_description(table_element)
        self.table_verifier.verify_table(table_element, expected_data, match_type='partial')
        logging.info(f"{self.__class__.__name__}: Table verification (partial match) completed for table: {table_desc}")

    def verify_table_row_partial(self, table_locator: Union[tuple, WebElement], row_index: int, expected_data: Dict[str, str]):
        logging.info(f"{self.__class__.__name__}: Verifying table row at index {row_index} with partial match")
        table_element = self.wait_for_element(table_locator) if isinstance(table_locator, tuple) else table_locator
        table_desc = self._get_element_description(table_element)
        self.table_verifier.verify_table_row(table_element, row_index, expected_data, match_type='partial')
        logging.info(f"{self.__class__.__name__}: Table row verification (partial match) completed for table: {table_desc}, row: {row_index}")

    def verify_specific_cell_partial(self, table_locator: Union[tuple, WebElement], row_index: int, column: Union[str, int], expected_value: str):
        logging.info(f"{self.__class__.__name__}: Verifying specific cell at row {row_index}, column {column} with partial match")
        table_element = self.wait_for_element(table_locator) if isinstance(table_locator, tuple) else table_locator
        table_desc = self._get_element_description(table_element)
        self.table_verifier.verify_specific_cell(table_element, row_index, column, expected_value, match_type='partial')
        logging.info(f"{self.__class__.__name__}: Specific cell verification (partial match) completed for table: {table_desc}, row: {row_index}, column: {column}")

    def verify_table_regex(self, table_locator: Union[tuple, WebElement], expected_data: List[Dict[str, str]]):
        logging.info(f"{self.__class__.__name__}: Verifying entire table with regex match")
        table_element = self.wait_for_element(table_locator) if isinstance(table_locator, tuple) else table_locator
        table_desc = self._get_element_description(table_element)
        self.table_verifier.verify_table(table_element, expected_data, match_type='regex')
        logging.info(f"{self.__class__.__name__}: Table verification (regex match) completed for table: {table_desc}")

    def verify_table_row_regex(self, table_locator: Union[tuple, WebElement], row_index: int, expected_data: Dict[str, str]):
        logging.info(f"{self.__class__.__name__}: Verifying table row at index {row_index} with regex match")
        table_element = self.wait_for_element(table_locator) if isinstance(table_locator, tuple) else table_locator
        table_desc = self._get_element_description(table_element)
        self.table_verifier.verify_table_row(table_element, row_index, expected_data, match_type='regex')
        logging.info(f"{self.__class__.__name__}: Table row verification (regex match) completed for table: {table_desc}, row: {row_index}")

    def verify_specific_cell_regex(self, table_locator: Union[tuple, WebElement], row_index: int, column: Union[str, int], expected_value: str):
        logging.info(f"{self.__class__.__name__}: Verifying specific cell at row {row_index}, column {column} with regex match")
        table_element = self.wait_for_element(table_locator) if isinstance(table_locator, tuple) else table_locator
        table_desc = self._get_element_description(table_element)
        self.table_verifier.verify_specific_cell(table_element, row_index, column, expected_value, match_type='regex')
        logging.info(f"{self.__class__.__name__}: Specific cell verification (regex match) completed for table: {table_desc}, row: {row_index}, column: {column}")

    def verify_table_is_empty(self, table_locator: Union[tuple, WebElement]):
        logging.info(f"{self.__class__.__name__}: Verifying table is empty")
        try:
            table_element = self.wait_for_element(table_locator) if isinstance(table_locator, tuple) else table_locator
            table_desc = self._get_element_description(table_element)
            self.table_verifier.verify_table_is_empty(table_element)
            logging.info(f"{self.__class__.__name__}: Table empty verification completed successfully for table: {table_desc}")
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error verifying table is empty: {str(e)}")
            raise

    def verify_unique_column_values(self, table_locator: Union[tuple, WebElement], column: Union[str, int]):
        logging.info(f"{self.__class__.__name__}: Verifying unique values in column: {column}")
        try:
            table_element = self.wait_for_element(table_locator) if isinstance(table_locator, tuple) else table_locator
            table_desc = self._get_element_description(table_element)
            self.table_verifier.verify_unique_column_values(table_element, column)
            logging.info(f"{self.__class__.__name__}: Unique column values verification completed successfully for table: {table_desc}, column: {column}")
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error verifying unique column values: {str(e)}")
            raise

    def verify_value_in_table(self, table_locator: Union[tuple, WebElement], search_value: str):
        logging.info(f"{self.__class__.__name__}: Verifying value '{search_value}' exists in table")
        try:
            table_element = self.wait_for_element(table_locator) if isinstance(table_locator, tuple) else table_locator
            table_desc = self._get_element_description(table_element)
            result = self.table_verifier.verify_value_in_table(table_element, search_value)
            logging.info(f"{self.__class__.__name__}: Value verification in table completed successfully for table: {table_desc}")
            return result
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error verifying value in table: {str(e)}")
            raise

    def verify_row_count(self, table_locator: Union[tuple, WebElement], expected_row_count: int):
        logging.info(f"{self.__class__.__name__}: Verifying row count: expected {expected_row_count}")
        try:
            table_element = self.wait_for_element(table_locator) if isinstance(table_locator, tuple) else table_locator
            table_desc = self._get_element_description(table_element)
            self.table_verifier.verify_row_count(table_element, expected_row_count)
            logging.info(f"{self.__class__.__name__}: Row count verification completed successfully for table: {table_desc}")
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error verifying row count: {str(e)}")
            raise

    def verify_column_sorted(self, table_locator: Union[tuple, WebElement], column: Union[str, int], expected_order='ascending', strip_spaces=True):
        logging.info(f"{self.__class__.__name__}: Verifying column '{column}' is sorted in {expected_order} order")
        try:
            table_element = self.wait_for_element(table_locator) if isinstance(table_locator, tuple) else table_locator
            table_desc = self._get_element_description(table_element)
            self.table_verifier.verify_column_sorted(table_element, column, expected_order, strip_spaces)
            logging.info(f"{self.__class__.__name__}: Column sorting verification completed successfully for table: {table_desc}, column: {column}")
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error verifying column sorting: {str(e)}")
            raise

    def select_table_row_checkbox(self, table_locator: Union[tuple, WebElement], identifier_column: Union[str, int], identifier_value: str, checkbox_column: int = 1):
        logging.info(f"{self.__class__.__name__}: Selecting checkbox for row with {identifier_column}: {identifier_value}")
        try:
            table_element = self.wait_for_element(table_locator) if isinstance(table_locator, tuple) else table_locator
            table_desc = self._get_element_description(table_element)
            self.table_verifier.select_table_row_checkbox(table_element, identifier_column, identifier_value, checkbox_column)
            logging.info(f"{self.__class__.__name__}: Checkbox selected successfully for row with {identifier_column}: {identifier_value} in table: {table_desc}")
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error selecting checkbox: {str(e)}")
            raise

    def select_multiple_table_row_checkboxes(self, table_locator: Union[tuple, WebElement], identifier_column: Union[str, int], identifier_values: List[str], checkbox_column: int = 1):
        logging.info(f"{self.__class__.__name__}: Selecting checkboxes for multiple rows with {identifier_column}: {identifier_values}")
        try:
            table_element = self.wait_for_element(table_locator) if isinstance(table_locator, tuple) else table_locator
            table_desc = self._get_element_description(table_element)
            self.table_verifier.select_multiple_table_row_checkboxes(table_element, identifier_column, identifier_values, checkbox_column)
            logging.info(f"{self.__class__.__name__}: Checkboxes selected successfully for rows with {identifier_column}: {identifier_values} in table: {table_desc}")
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error selecting multiple checkboxes: {str(e)}")
            raise</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_table_verifier_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\web_action\table_verifier.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import logging
from selenium.webdriver.common.by import By
import re


class TableVerifier:
    def __init__(self, driver):
        self.driver = driver
        self.logger = logging.getLogger(__name__)

    def verify_table(self, table_element, expected_data, match_type='exact'):
        """
        Verify the entire table data.

        :param table_element: WebElement of the table
        :param expected_data: List of dictionaries, each representing a row
        :param match_type: Type of matching to perform ('exact', 'partial', 'regex')
        """
        try:
            rows = table_element.find_elements(By.TAG_NAME, "tr")
            headers = [header.text.strip().lower() for header in rows[0].find_elements(By.XPATH, ".//th | .//td")]

            for row_index, expected_row in enumerate(expected_data, start=1):
                if row_index &gt;= len(rows):
                    raise ValueError(f"Not enough rows in table. Expected at least {row_index}, but found {len(rows) - 1}")

                row = rows[row_index]
                cells = row.find_elements(By.XPATH, ".//td|.//th")

                for column, expected_value in expected_row.items():
                    cell_index = self._get_cell_index(headers, column)
                    if cell_index &gt;= len(cells):
                        raise ValueError(f"Column '{column}' is out of range. Row has {len(cells)} cells.")

                    actual_value = cells[cell_index].text.strip()
                    self._verify_cell_value(column, actual_value, expected_value, match_type)

            self.logger.info("All table data verified successfully.")
        except Exception as e:
            self.logger.error(f"Error verifying table data: {str(e)}")
            raise

    def verify_table_row(self, table_element, row_index, expected_data, match_type='exact'):
        """
        Verify the data in a specific row of a table.

        :param table_element: WebElement of the table
        :param row_index: Index of the row to verify (1-based index)
        :param expected_data: Dictionary of column name (or index) and expected value
        :param match_type: Type of matching to perform ('exact', 'partial', 'regex')
        """
        try:
            rows = table_element.find_elements(By.TAG_NAME, "tr")
            headers = [header.text.strip().lower() for header in rows[0].find_elements(By.XPATH, ".//th | .//td")]

            if row_index &lt; 1 or row_index &gt;= len(rows):
                raise ValueError(f"Invalid row index: {row_index}. Table has {len(rows) - 1} data rows.")

            row = rows[row_index]
            cells = row.find_elements(By.XPATH, ".//td|.//th")

            for column, expected_value in expected_data.items():
                cell_index = self._get_cell_index(headers, column)
                if cell_index &gt;= len(cells):
                    raise ValueError(f"Column '{column}' is out of range. Row has {len(cells)} cells.")

                actual_value = cells[cell_index].text.strip()
                self._verify_cell_value(column, actual_value, expected_value, match_type)

            self.logger.info(f"All expected data in row {row_index} verified successfully.")
        except Exception as e:
            self.logger.error(f"Error verifying table row data: {str(e)}")
            raise

    def verify_specific_cell(self, table_element, row_index, column, expected_value, match_type='exact'):
        """
        Verify the data in a specific cell of a table.

        :param table_element: WebElement of the table
        :param row_index: Index of the row to verify (1-based index)
        :param column: Column name or index (1-based if index)
        :param expected_value: Expected value of the cell
        :param match_type: Type of matching to perform ('exact', 'partial', 'regex')
        """
        try:
            rows = table_element.find_elements(By.TAG_NAME, "tr")
            headers = [header.text.strip().lower() for header in rows[0].find_elements(By.XPATH, ".//th | .//td")]

            if row_index &lt; 1 or row_index &gt;= len(rows):
                raise ValueError(f"Invalid row index: {row_index}. Table has {len(rows) - 1} data rows.")

            row = rows[row_index]
            cells = row.find_elements(By.XPATH, ".//td|.//th")

            cell_index = self._get_cell_index(headers, column)
            if cell_index &gt;= len(cells):
                raise ValueError(f"Column '{column}' is out of range. Row has {len(cells)} cells.")

            actual_value = cells[cell_index].text.strip()
            self._verify_cell_value(column, actual_value, expected_value, match_type)

            self.logger.info(f"Cell at row {row_index}, column '{column}' verified successfully.")
        except Exception as e:
            self.logger.error(f"Error verifying specific cell: {str(e)}")
            raise

    def _get_cell_index(self, headers, column):
        """
        Get the index of a cell based on column name or index.
        """
        if isinstance(column, int):
            return column - 1  # Convert to 0-based index

        column_lower = column.lower()
        for i, header in enumerate(headers):
            if header == column_lower:
                return i

        raise ValueError(f"Column '{column}' not found in table headers.")

    def _verify_cell_value(self, column, actual_value, expected_value, match_type):
        """
        Verify cell value based on the specified match type.
        """
        if match_type == 'exact':
            assert actual_value == expected_value, f"Mismatch in column '{column}'. Expected: {expected_value}, Actual: {actual_value}"
            self.logger.info(f"Verified column '{column}': expected: {expected_value}, actual: {actual_value}")
        elif match_type == 'partial':
            assert expected_value in actual_value, f"Value '{expected_value}' not found in column '{column}'. Actual: {actual_value}"
            self.logger.info(f"Verified column '{column}': partial match: {expected_value} in {actual_value}")
        elif match_type == 'regex':
            assert re.search(expected_value, actual_value), f"Regex '{expected_value}' did not match in column '{column}'. Actual: {actual_value}"
            self.logger.info(f"Verified column '{column}': regex match: {expected_value} in {actual_value}")
        else:
            raise ValueError(f"Invalid match_type: {match_type}")

        self.logger.info(f"Verified column '{column}': {actual_value}")

    def verify_table_is_empty(self, table_element):
        """
        Verify that the table contains no data rows.

        :param table_element: WebElement of the table
        """
        try:
            rows = table_element.find_elements(By.TAG_NAME, "tr")
            assert len(rows) == 1, f"Table is not empty. Found {len(rows) - 1} data rows."

            self.logger.info("Table is empty as expected.")
        except Exception as e:
            self.logger.error(f"Error verifying if table is empty: {str(e)}")
            raise

    def verify_unique_column_values(self, table_element, column):
        """
        Verify that all values in a specific column are unique.

        :param table_element: WebElement of the table
        :param column: Column name or index to verify uniqueness
        """
        try:
            rows = table_element.find_elements(By.TAG_NAME, "tr")
            headers = [header.text.strip().lower() for header in rows[0].find_elements(By.XPATH, ".//th | .//td")]

            column_index = self._get_cell_index(headers, column)
            values = set()

            for row in rows[1:]:  # Skip header row
                cells = row.find_elements(By.XPATH, ".//td|.//th")
                if column_index &lt; len(cells):
                    value = cells[column_index].text.strip()
                    assert value not in values, f"Duplicate value found in column '{column}': {value}"
                    values.add(value)

            self.logger.info(f"All values in column '{column}' are unique.")
        except Exception as e:
            self.logger.error(f"Error verifying unique values in column: {str(e)}")
            raise

    def verify_value_in_table(self, table_element, search_value):
        """
        Verify if a specific value exists in the table.

        :param table_element: WebElement of the table
        :param search_value: The value to search for in the table
        """
        try:
            rows = table_element.find_elements(By.TAG_NAME, "tr")

            for row in rows[1:]:  # Skip header row
                cells = row.find_elements(By.XPATH, ".//td|.//th")
                for cell in cells:
                    if search_value in cell.text.strip():
                        self.logger.info(f"Value '{search_value}' found in table.")
                        return True

            raise ValueError(f"Value '{search_value}' not found in the table.")
        except Exception as e:
            self.logger.error(f"Error verifying presence of value in table: {str(e)}")
            raise

    def verify_row_count(self, table_element, expected_row_count):
        """
        Verify the number of rows in the table (excluding the header row).

        :param table_element: WebElement of the table
        :param expected_row_count: The expected number of data rows
        """
        try:
            rows = table_element.find_elements(By.TAG_NAME, "tr")
            actual_row_count = len(rows) - 1  # Exclude header row

            assert actual_row_count == expected_row_count, \
                f"Row count mismatch. Expected: {expected_row_count}, Actual: {actual_row_count}"

            self.logger.info(f"Row count verified successfully: {actual_row_count}")
        except Exception as e:
            self.logger.error(f"Error verifying row count: {str(e)}")
            raise

    def verify_column_sorted(self, table_element, column, expected_order='ascending', strip_spaces=True):
        """
        Verify if a specific column in the table is sorted in the expected order.

        :param table_element: WebElement of the table
        :param column: Column name (or 1-based index) to verify sorting
        :param expected_order: Expected sorting order, either 'ascending' or 'descending' (default is 'ascending')
        :param strip_spaces: Boolean to determine whether to remove leading/trailing spaces from cell values (default is True)
        """
        try:
            # Retrieve all rows and headers of the table
            rows = table_element.find_elements(By.TAG_NAME, "tr")
            headers = [header.text.strip().lower() for header in rows[0].find_elements(By.XPATH, ".//th | .//td")]

            # Get the index of the target column
            column_index = self._get_cell_index(headers, column)

            # Collect all values from the target column (skipping the header row)
            column_data = []
            for row in rows[1:]:
                cells = row.find_elements(By.XPATH, ".//td|.//th")
                if column_index &lt; len(cells):
                    cell_text = cells[column_index].text.strip()
                    if strip_spaces:
                        cell_text = cell_text.strip()  # Optionally strip spaces
                    column_data.append(cell_text)
                else:
                    raise ValueError(f"Column '{column}' is out of range. This row has {len(cells)} columns.")

            # Sort the column data based on the expected order
            sorted_data = sorted(column_data)
            if expected_order == 'descending':
                sorted_data.reverse()

            # Validate if the column data is sorted as expected
            assert column_data == sorted_data, f"Column '{column}' is not sorted in {expected_order} order."

            self.logger.info(f"Column '{column}' is correctly sorted in {expected_order} order.")
        except Exception as e:
            self.logger.error(f"Error verifying sorting for column '{column}': {str(e)}")
            raise

    def select_table_row_checkbox(self, table_element, identifier_column, identifier_value, checkbox_column=1):
        """
        Select the checkbox in a specific row based on an identifier value in a specific column.

        :param table_element: WebElement of the table
        :param identifier_column: Column name or index (1-based if index) containing the identifier
        :param identifier_value: Value to identify the row
        :param checkbox_column: Column index (1-based) of the checkbox (default is 1, assuming checkbox is in the first column)
        """
        try:
            rows = table_element.find_elements(By.TAG_NAME, "tr")
            headers = [header.text.strip().lower() for header in rows[0].find_elements(By.XPATH, ".//th | .//td")]

            identifier_index = self._get_cell_index(headers, identifier_column)
            checkbox_index = checkbox_column - 1  # Convert to 0-based index

            for row in rows[1:]:  # Skip header row
                cells = row.find_elements(By.XPATH, ".//td|.//th")
                if identifier_index &lt; len(cells) and cells[identifier_index].text.strip() == identifier_value:
                    if checkbox_index &lt; len(cells):
                        checkbox = cells[checkbox_index].find_element(By.TAG_NAME, "input")
                        if checkbox.get_attribute("type") == "checkbox":
                            if not checkbox.is_selected():
                                checkbox.click()
                            self.logger.info(f"Checkbox selected for row with {identifier_column}: {identifier_value}")
                            return
                    else:
                        raise ValueError(
                            f"Checkbox column index {checkbox_column} is out of range. Row has {len(cells)} cells.")

            raise ValueError(f"No row found with {identifier_column}: {identifier_value}")

        except Exception as e:
            self.logger.error(f"Error selecting row checkbox: {str(e)}")
            raise

    def select_multiple_table_row_checkboxes(self, table_element, identifier_column, identifier_values, checkbox_column=1):
        """
        Select checkboxes in multiple rows based on identifier values in a specific column.

        :param table_element: WebElement of the table
        :param identifier_column: Column name or index (1-based if index) containing the identifier
        :param identifier_values: List of values to identify the rows
        :param checkbox_column: Column index (1-based) of the checkbox (default is 1, assuming checkbox is in the first column)
        """
        for identifier_value in identifier_values:
            self.select_table_row_checkbox(table_element, identifier_column, identifier_value, checkbox_column)

</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_utils_actions_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\web_action\utils_actions.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import base64
import datetime
import io
import logging
import time
from PIL import Image
from robot.libraries.BuiltIn import BuiltIn
from .base import Base

class UtilsActions(Base):
    def capture_screenshot(self):
        try:
            if self.driver:
                screenshot_binary = self.driver.get_screenshot_as_png()
                image = Image.open(io.BytesIO(screenshot_binary))
                base_width = 1440
                w_percent = (base_width / float(image.size[0]))
                h_size = int((float(image.size[1]) * float(w_percent)))
                image = image.resize((base_width, h_size), Image.LANCZOS)
                buffer = io.BytesIO()
                image.save(buffer, format="WebP", quality=30)
                encoded_string = base64.b64encode(buffer.getvalue()).decode('utf-8')
                logging.info(
                    f"{self.__class__.__name__}: Screenshot captured successfully at: " + str(datetime.datetime.now()))
                BuiltIn().log(f'&lt;img src="data:image/webp;base64,{encoded_string}" width="1440px"&gt;', html=True)
            else:
                logging.error(f"{self.__class__.__name__}: WebDriver is not initialized.")
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Failed to capture screenshot: {str(e)}")
            BuiltIn().log(f"{self.__class__.__name__}: Failed to capture screenshot: {str(e)}", level="ERROR")

    def highlight_element(self, locator, duration=2, color="lightgreen", border="3px solid red", element_desc=None, condition="visibility"):
        element = self._resolve_element(locator, element_desc, condition)
        element_desc = element_desc or self._get_element_description(locator)
        logging.debug(f"{self.__class__.__name__}: Highlighting element [ {element_desc}:{locator} ] using JavaScript.")
        def apply_style(s):
            self.driver.execute_script("arguments[0].setAttribute('style', arguments[1]);", element, s)
        original_style = element.get_attribute('style')
        for _ in range(int(duration)):
            apply_style(f"background: {color}; border: {border};")
            time.sleep(0.25)
            apply_style(original_style)
            time.sleep(0.25)
        logging.info(f"{self.__class__.__name__}: Highlighted element [ {element_desc}:{locator} ] using JavaScript successfully.")</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_verification_actions_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\web_action\verification_actions.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>from numpy import around
from selenium.common import NoSuchElementException, TimeoutException
from robot.libraries.BuiltIn import BuiltIn
from .base import Base
import logging
from robot.api import logger
from libraries.common.log_manager import ColorLogger


class VerificationActions(Base):
    def verify_text_is(self, locator, expected_text, element_desc=None, condition="presence"):
        element = self._resolve_element(locator, element_desc, condition)
        element_desc = element_desc or self._get_element_description(locator)
        logging.debug(f"{self.__class__.__name__}: Checking if element text matches expected: {element_desc}, expected text: '{expected_text}'")
        actual_text = element.text
        result = actual_text == expected_text
        log_message = f"UI Verification: Asserting: {element_desc}, verify_text_is, Expected: {expected_text}, Actual: {actual_text}"
        self._log_result(result, log_message)
        assert result, f"{self.__class__.__name__}: Expected text: '{expected_text}' is not matching actual text: '{actual_text}'"

    def verify_figure_is(self, locator, expected_figure, element_desc=None, condition="presence"):
        element = self._resolve_element(locator, element_desc, condition)
        element_desc = element_desc or self._get_element_description(locator)
        logging.debug(f"{self.__class__.__name__}: Checking if element figure matches expected: {element_desc}, expected figure: '{expected_figure}'")
        try:
            expected_value = float(expected_figure.replace(",", "").strip())
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error converting expected figure to float: {expected_figure}")
            raise e
        try:
            actual_value = float(element.text.replace(",", "").strip())
        except Exception as e:
            logging.error(f"{self.__class__.__name__}: Error converting actual figure to float from element text: {element.text}")
            raise e
        result = around(actual_value, decimals=2) == around(expected_value, decimals=2)
        log_message = f"UI Verification: Asserting: {element_desc}, verify_figure_is, Expected: {expected_value}, Actual: {actual_value}"
        self._log_result(result, log_message)
        assert result, f"{self.__class__.__name__}: Expected figure: '{expected_value}' is not matching actual figure: '{actual_value}'"

    def verify_text_contains(self, locator, expected_text, element_desc=None, condition="presence"):
        element = self._resolve_element(locator, element_desc, condition)
        element_desc = element_desc or self._get_element_description(locator)
        logging.debug(f"{self.__class__.__name__}: Checking if element text contains expected: {element_desc}, expected text: '{expected_text}'")
        actual_text = element.text
        result = expected_text in actual_text
        log_message = f"UI Verification: Asserting: {element_desc}, verify_text_contains, Expected: {expected_text}, Actual: {actual_text}"
        self._log_result(result, log_message)
        assert result, f"{self.__class__.__name__}: Expected text: '{expected_text}' is not in actual text: '{actual_text}'"

    def verify_figure_text_contains(self, locator, expected_text, element_desc=None, condition="presence"):
        element = self._resolve_element(locator, element_desc, condition)
        element_desc = element_desc or self._get_element_description(locator)
        logging.debug(f"{self.__class__.__name__}: Checking if element figure text contains expected: {element_desc}, expected text: '{expected_text}'")
        expected_text_clean = expected_text.replace(",", "").strip()
        actual_text_clean = element.text.replace(",", "").strip()
        result = expected_text_clean in actual_text_clean
        log_message = f"UI Verification: Asserting: {element_desc}, verify_figure_text_contains, Expected: {expected_text_clean}, Actual: {actual_text_clean}"
        self._log_result(result, log_message)
        assert result, f"{self.__class__.__name__}: Expected text: '{expected_text_clean}' is not in actual text: '{actual_text_clean}'"

    def verify_title_is(self, expected_title, element_desc="Page Title"):
        logging.debug(f"{self.__class__.__name__}: Checking if page title matches expected: '{expected_title}'")
        actual_title = self.driver.title
        result = actual_title == expected_title
        log_message = f"UI Verification: Asserting: {element_desc}, verify_title_is, Expected: {expected_title}, Actual: {actual_title}"
        self._log_result(result, log_message)
        assert result, f"{self.__class__.__name__}: Expected title: '{expected_title}' is not matching actual title: '{actual_title}'"

    def verify_title_contains(self, expected_title, element_desc="Page Title"):
        logging.debug(f"{self.__class__.__name__}: Checking if page title contains expected: '{expected_title}'")
        actual_title = self.driver.title
        result = expected_title in actual_title
        log_message = f"UI Verification: Asserting: {element_desc}, verify_title_contains, Expected: {expected_title}, Actual: {actual_title}"
        self._log_result(result, log_message)
        assert result, f"{self.__class__.__name__}: Expected title: '{expected_title}' is not in actual title: '{actual_title}'"

    def verify_element_exists(self, locator, element_desc=None):
        element_desc = element_desc or self._get_element_description(locator)
        logging.debug(f"{self.__class__.__name__}: Checking if element exists: {element_desc}")
        try:
            self._resolve_element(locator, element_desc, condition="presence")
            result = True
        except NoSuchElementException:
            result = False
        log_message = f"UI Verification: Asserting: {element_desc}, verify_element_exists, Expected: True, Actual: {result}"
        self._log_result(result, log_message)
        return result

    def verify_element_visible(self, locator, timeout=None, element_desc=None):
        element_desc = element_desc or self._get_element_description(locator)
        logging.debug(f"{self.__class__.__name__}: Checking if element is visible: {element_desc}, timeout: {timeout}")
        try:
            self.wait_for_element(locator, condition="visibility", timeout=timeout)
            result = True
        except TimeoutException:
            result = False
        log_message = f"UI Verification: Asserting: {element_desc}, verify_element_visible, Expected: True, Actual: {result}"
        self._log_result(result, log_message)
        return result

    def verify_element_invisible(self, locator, timeout=None, element_desc=None):
        element_desc = element_desc or self._get_element_description(locator)
        logging.debug(f"{self.__class__.__name__}: Checking if element is invisible: {element_desc}, timeout: {timeout}")
        try:
            self.wait_for_element(locator, condition="invisibility", timeout=timeout)
            result = True
        except TimeoutException:
            result = False
        log_message = f"UI Verification: Asserting: {element_desc}, verify_element_invisible, Expected: True, Actual: {result}"
        self._log_result(result, log_message)
        return result

    def verify_element_clickable(self, locator, timeout=None, element_desc=None):
        element_desc = element_desc or self._get_element_description(locator)
        logging.debug(f"{self.__class__.__name__}: Checking if element is clickable: {element_desc}, timeout: {timeout}")
        try:
            self.wait_for_element(locator, condition="clickable", timeout=timeout)
            result = True
        except TimeoutException:
            result = False
        log_message = f"UI Verification: Asserting: {element_desc}, verify_element_clickable, Expected: True, Actual: {result}"
        self._log_result(result, log_message)
        return result

    def verify_element_selected(self, locator, element_desc=None, condition="presence"):
        element = self._resolve_element(locator, element_desc, condition)
        element_desc = element_desc or self._get_element_description(locator)
        logging.debug(f"{self.__class__.__name__}: Checking if element is selected: {element_desc}")
        is_selected = element.is_selected()
        log_message = f"UI Verification: Asserting: {element_desc}, verify_element_selected, Expected: True, Actual: {is_selected}"
        self._log_result(is_selected, log_message)
        assert is_selected, f"{self.__class__.__name__}: Element {element_desc} is not selected as expected."
        return is_selected

    def verify_element_enabled(self, locator, element_desc=None, condition="presence"):
        element = self._resolve_element(locator, element_desc, condition)
        element_desc = element_desc or self._get_element_description(locator)
        logging.debug(f"{self.__class__.__name__}: Checking if element is enabled: {element_desc}")
        is_enabled = element.is_enabled()
        log_message = f"UI Verification: Asserting: {element_desc}, verify_element_enabled, Expected: True, Actual: {is_enabled}"
        self._log_result(is_enabled, log_message)
        assert is_enabled, f"{self.__class__.__name__}: Element {element_desc} is not enabled as expected."
        return is_enabled

    def get_text_save_to_variable(self, locator, variable_name, element_desc=None, condition="presence"):
        element = self._resolve_element(locator, element_desc, condition)
        element_desc = element_desc or self._get_element_description(locator)
        logging.debug(f"{self.__class__.__name__}: Capturing text from element: {element_desc}")
        value = element.text
        BuiltIn().set_global_variable(f"${{{variable_name}}}", value)
        logging.debug(f"{self.__class__.__name__}: Captured text: {value}")
        return value

    def verify_element_value_diff(self, locator, initial_value_variable, expected_change, element_desc=None, condition="presence"):
        element = self._resolve_element(locator, element_desc, condition)
        element_desc = element_desc or self._get_element_description(locator)
        logging.debug(f"{self.__class__.__name__}: Checking value difference for element: {element_desc}")
        initial_value = float(BuiltIn().get_variable_value(f"${{{initial_value_variable}}}"))
        current_value = float(element.text)
        actual_change = around(current_value - initial_value, decimals=2)
        expected_change_float = float(expected_change)
        result = self._compare_diff(actual_change, expected_change_float)
        log_message = f"UI Verification: Asserting: {element_desc}, verify_element_value_diff, Expected Change: {expected_change_float}, Actual Change: {actual_change}"
        self._log_result(result, log_message)
        assert result, f"{self.__class__.__name__}: Expected change: '{expected_change_float}' does not match actual change: '{actual_change}' for element {element_desc}"

    def _compare_diff(self, actual, expected):
        return around(actual, decimals=2) == around(expected, decimals=2)

    def _log_result(self, success: bool, message: str):
        """Logs the result of a check with appropriate color."""
        logging.debug(f"{self.__class__.__name__}: {message}")
        logger.info(
            ColorLogger.success(f"=&gt; {message}") if success else ColorLogger.error(f"=&gt; {message}"), html=True)
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_wait_actions_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\web_action\wait_actions.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>from .base import Base
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException
import logging
import time


class WaitActions(Base):

    def wait_for_element_present(self, locator, element_desc=None, timeout=None):
        """
        Waits until the element is present in the DOM.
        """
        element_desc = element_desc or self._get_element_description(locator)
        logging.info(f"{self.__class__.__name__}: Waiting for element to be present: [ {element_desc}:{locator} ].")
        element = self._resolve_element(locator, element_desc, condition="presence", timeout=timeout)
        return element

    def wait_for_element_visible(self, locator, element_desc=None, timeout=None):
        """
        Waits until the element is visible on the page.
        """
        element_desc = element_desc or self._get_element_description(locator)
        logging.info(f"{self.__class__.__name__}: Waiting for element to be visible: [ {element_desc}:{locator} ].")
        element = self._resolve_element(locator, element_desc, condition="visibility", timeout=timeout)
        return element

    def wait_for_element_clickable(self, locator, element_desc=None, timeout=None):
        """
        Waits until the element is clickable.
        """
        element_desc = element_desc or self._get_element_description(locator)
        logging.info(f"{self.__class__.__name__}: Waiting for element to be clickable: [ {element_desc}:{locator} ].")
        element = self._resolve_element(locator, element_desc, condition="clickable", timeout=timeout)
        return element

    def wait_for_element_invisible(self, locator, element_desc=None, timeout=None):
        """
        Waits until the element becomes invisible.
        Note: This expected condition returns a boolean.
        """
        element_desc = element_desc or self._get_element_description(locator)
        logging.info(f"{self.__class__.__name__}: Waiting for element to become invisible: [ {element_desc}:{locator} ].")
        if timeout is None:
            timeout = self.default_timeout
        wait = WebDriverWait(self.driver, timeout)
        try:
            result = wait.until(EC.invisibility_of_element_located(locator))
            logging.info(f"{self.__class__.__name__}: Element is now invisible: [ {element_desc}:{locator} ].")
            return result
        except TimeoutException:
            logging.error(f"{self.__class__.__name__}: Timeout waiting for element to become invisible: [ {element_desc}:{locator} ].")
            raise

    def wait_for_text_present_in_element(self, locator, text, element_desc=None, timeout=None):
        """
        Waits until the given text is present in the specified element.
        """
        element_desc = element_desc or self._get_element_description(locator)
        logging.info(f"{self.__class__.__name__}: Waiting for text '{text}' to be present in element: [ {element_desc}:{locator} ].")
        if timeout is None:
            timeout = self.default_timeout
        wait = WebDriverWait(self.driver, timeout)
        try:
            result = wait.until(EC.text_to_be_present_in_element(locator, text))
            element = self.driver.find_element(*locator)
            element_desc = self._get_element_description(element)
            logging.info(f"{self.__class__.__name__}: Text '{text}' is present in element: [ {element_desc}:{locator} ].")
            return element
        except TimeoutException:
            logging.error(f"{self.__class__.__name__}: Timeout waiting for text '{text}' in element: [ {element_desc}:{locator} ].")
            raise

    def wait_for_staleness_of(self, element, timeout=None):
        """
        Waits until the element is no longer attached to the DOM.
        """
        element_desc = self._get_element_description(element)
        logging.info(f"{self.__class__.__name__}: Waiting for staleness of element: [ {element_desc} ].")
        if timeout is None:
            timeout = self.default_timeout
        wait = WebDriverWait(self.driver, timeout)
        try:
            wait.until(EC.staleness_of(element))
            logging.info(f"{self.__class__.__name__}: Element is stale: [ {element_desc} ].")
            return True
        except TimeoutException:
            logging.error(f"{self.__class__.__name__}: Timeout waiting for element to become stale: [ {element_desc} ].")
            return False

    def wait(self, seconds):
        """
        Pauses execution for the given number of seconds.
        """
        logging.info(f"{self.__class__.__name__}: Waiting for {seconds} seconds.")
        time.sleep(int(seconds))
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_action_window_actions_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\web_action\window_actions.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>from .base import Base
import logging

class WindowActions(Base):
    def switch_to_frame(self, element, condition="presence"):
        element_desc = self._get_element_description(element)
        logging.info(f"{self.__class__.__name__}: Switching to frame: {element_desc}")

        if isinstance(element, tuple):
            element = self.wait_for_element(element, condition=condition)

        self.driver.switch_to.frame(element)
        logging.info(f"{self.__class__.__name__}: Switched to frame successfully: {element_desc}")

    def switch_to_default_content(self):
        logging.info(f"{self.__class__.__name__}: Switching to default content")
        self.driver.switch_to.default_content()
        logging.info(f"{self.__class__.__name__}: Switched to default content successfully")

    def switch_to_window(self, window_handle):
        logging.info(f"{self.__class__.__name__}: Switching to window with handle: {window_handle}")
        self.driver.switch_to.window(window_handle)
        logging.info(f"{self.__class__.__name__}: Switched to window successfully")

    def get_window_handles(self):
        logging.info(f"{self.__class__.__name__}: Getting all window handles")
        handles = self.driver.window_handles
        logging.info(f"{self.__class__.__name__}: Retrieved {len(handles)} window handles")
        return handles

    def close_current_window(self):
        logging.info(f"{self.__class__.__name__}: Closing current window")
        self.driver.close()
        logging.info(f"{self.__class__.__name__}: Current window closed successfully")

    def set_window_size(self, width, height):
        logging.info(f"{self.__class__.__name__}: Setting window size to {width}x{height}")
        self.driver.set_window_size(width, height)
        logging.info(f"{self.__class__.__name__}: Window size set successfully")

    def maximize_window(self):
        logging.info(f"{self.__class__.__name__}: Maximizing window")
        self.driver.maximize_window()
        logging.info(f"{self.__class__.__name__}: Window maximized successfully")

    def minimize_window(self):
        logging.info(f"{self.__class__.__name__}: Minimizing window")
        self.driver.minimize_window()
        logging.info(f"{self.__class__.__name__}: Window minimized successfully")

    def fullscreen_window(self):
        logging.info(f"{self.__class__.__name__}: Setting window to full screen")
        self.driver.fullscreen_window()
        logging.info(f"{self.__class__.__name__}: Window set to full screen successfully")</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_actions_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\web_actions.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>from libraries.web.web_action.alert_actions import AlertActions
from libraries.web.web_action.element_actions import ElementActions
from libraries.web.web_action.navigation_actions import NavigationActions
from libraries.web.web_action.cookie_actions import CookieActions
from libraries.web.web_action.window_actions import WindowActions
from libraries.web.web_action.javascript_actions import JavaScriptActions
from libraries.web.web_action.utils_actions import UtilsActions
from libraries.web.web_action.table_actions import TableActions
from libraries.web.web_action.verification_actions import VerificationActions
from libraries.web.web_action.wait_actions import WaitActions


class WebActions(
    ElementActions,
    VerificationActions,
    WaitActions,
    WindowActions,
    JavaScriptActions,
    TableActions,
    NavigationActions,
    CookieActions,
    AlertActions,
    UtilsActions):
    pass
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_web_test_loader_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\web_test_loader.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import json
import logging
import pandas as pd
import os
from typing import Dict, List
from robot.libraries.BuiltIn import BuiltIn


class WebTestLoader:
    _instances = {}

    def __new__(cls, excel_path, test_config):
        key = (excel_path, id(test_config))  # Use a tuple of excel_path and test_config id as the key
        if key not in cls._instances:
            instance = super().__new__(cls)
            instance.__init__(excel_path, test_config)
            cls._instances[key] = instance
        return cls._instances[key]

    def __init__(self, excel_path, test_config):
        if hasattr(self, 'initialized'):
            return
        self.excel_path = excel_path
        self.test_config = test_config
        self.data = self._load_excel_data()
        self._validate_data()
        self.initialized = True

    def _load_excel_data(self) -&gt; Dict[str, pd.DataFrame]:
        sheets = ['Locators', 'PageModules', 'TestCases', 'TestSteps', 'TestData', 'WebEnvironments', 'CustomActions', 'EnvVariables']
        return {sheet: pd.read_excel(self.excel_path, sheet_name=sheet).fillna("") for sheet in sheets}

    def _validate_data(self):
        self._validate_test_cases()
        self._validate_test_steps()
        self._validate_page_objects()
        self._validate_test_data()
        self._validate_web_environments()
        self._validate_custom_actions()
        self._validate_environments()  # 验证新添加的 Environments Sheet

    def _validate_environments(self):
        environments = self.get_data_by_sheet_name('EnvVariables')
        required_columns = ['Environment', 'Variable Name', 'Variable Value']
        missing_columns = set(required_columns) - set(environments.columns)
        if missing_columns:
            logging.error(f"WebTestLoader: Missing required columns in Environments sheet: {', '.join(missing_columns)}")
            raise ValueError(f"WebTestLoader: Missing required columns in Environments sheet: {', '.join(missing_columns)}")

    def _validate_test_cases(self):
        test_cases = self.get_data_by_sheet_name('TestCases')
        test_steps = self.get_data_by_sheet_name('TestSteps')

        case_ids_in_steps = set(test_steps['Case ID'].unique())
        for _, row in test_cases.iterrows():
            case_id = row['Case ID']
            if case_id not in case_ids_in_steps:
                logging.error(f"WebTestLoader: Case ID '{case_id}' does not have any steps defined in the TestSteps sheet.")

    def _validate_test_steps(self):
        test_steps = self.get_data_by_sheet_name('TestSteps')
        page_modules = self.get_data_by_sheet_name('PageModules')

        page_module_combinations = set(zip(page_modules[page_modules['Run'] == 'Y']['Page Name'],
                                           page_modules[page_modules['Run'] == 'Y']['Module Name']))
        for _, row in test_steps[test_steps['Run'] == 'Y'].iterrows():
            if (row['Page Name'], row['Module Name']) not in page_module_combinations and row['Module Name'] != 'API':
                logging.error(
                    f"WebTestLoader: Invalid Page Name '{row['Page Name']}' and Module Name '{row['Module Name']}' combination in TestSteps for Case ID '{row['Case ID']}'.")
            self._validate_parameters(row)

    def _validate_parameters(self, step_row):
        page_modules = self.get_data_by_sheet_name('PageModules')
        test_data = self.get_data_by_sheet_name('TestData')

        module_params = page_modules[(page_modules['Page Name'] == step_row['Page Name']) &amp;
                                     (page_modules['Module Name'] == step_row['Module Name'])]['Parameter Name'].tolist()
        module_params = [param for param in module_params if param]

        if module_params:
            expected_params = set()
            for param in module_params:
                expected_params.update(param.split(','))

            case_data = test_data[test_data['Case ID'] == step_row['Case ID']]
            for param in expected_params:
                if param not in case_data['Parameter Name'].values:
                    logging.error(f"No data provided for parameter '{param}' in TestData for Case ID '{step_row['Case ID']}'")

    def _validate_page_objects(self):
        page_objects = self.get_data_by_sheet_name('PageModules')
        locators = self.get_data_by_sheet_name('Locators')

        locator_map = set(zip(locators['Page Name'], locators['Element Name']))
        for _, row in page_objects[page_objects['Run'] == 'Y'].iterrows():
            if row['Element Name'] and (row['Page Name'], row['Element Name']) not in locator_map:
                logging.error(f"WebTestLoader: Element '{row['Element Name']}' on page '{row['Page Name']}' not found in Locators sheet.")

    def _validate_test_data(self):
        test_data = self.get_data_by_sheet_name('TestData')
        test_steps = self.get_data_by_sheet_name('TestSteps')

        case_ids_in_steps = set(test_steps['Case ID'].unique())
        for _, row in test_data.iterrows():
            if row['Case ID'] not in case_ids_in_steps:
                logging.error(f"WebTestLoader: Test data for Case ID '{row['Case ID']}' does not have corresponding test steps.")

    def _validate_web_environments(self):
        web_environments = self.get_data_by_sheet_name('WebEnvironments')

        if web_environments.empty:
            logging.error("WebTestLoader: WebEnvironments sheet is empty or does not exist.")
            return

        required_columns = ['Environment', 'Browser', 'IsRemote', 'RemoteURL', 'ChromePath', 'ChromeDriverPath', 'EdgePath', 'EdgeDriverPath', 'BrowserOptions']
        missing_columns = set(required_columns) - set(web_environments.columns)
        if missing_columns:
            logging.error(f"WebTestLoader: Missing required columns in WebEnvironments sheet: {', '.join(missing_columns)}")
            return

        # Check if active_environment exists in WebEnvironments
        active_environment = self.test_config.get('active_environment')
        if active_environment and active_environment not in web_environments['Environment'].values:
            logging.error(f"WebTestLoader: Active environment '{active_environment}' specified in config file does not exist in WebEnvironments sheet.")

        for index, row in web_environments.iterrows():
            if self.test_config.get('active_environment') != row['Environment']:
                continue
            if pd.isna(row['Environment']) or row['Environment'] == '':
                logging.error(f"WebTestLoader: Empty Environment name in row {index + 2}")

            if row['Browser'].lower() not in ['chrome', 'edge']:
                logging.error(f"WebTestLoader: Invalid Browser '{row['Browser']}' in row {index + 2}. Must be 'chrome' or 'edge'.")

            if not isinstance(row['IsRemote'], bool):
                logging.error(f"WebTestLoader: IsRemote must be a boolean value in row {index + 2}")

            if row['IsRemote']:
                if pd.isna(row['RemoteURL']) or row['RemoteURL'] == '':
                    logging.error(f"WebTestLoader: RemoteURL is required when IsRemote is True in row {index + 2}")
            else:
                if row['Browser'].lower() == 'chrome':
                    for path_column in ['ChromePath', 'ChromeDriverPath']:
                        if pd.isna(row[path_column]) or row[path_column] == '':
                            logging.error(f"WebTestLoader: {path_column} is required when IsRemote is False and Browser is Chrome in row {index + 2}")
                        elif not os.path.exists(row[path_column]):
                            logging.warning(f"WebTestLoader: {path_column} '{row[path_column]}' does not exist in row {index + 2}")
                elif row['Browser'].lower() == 'edge':
                    for path_column in ['EdgePath', 'EdgeDriverPath']:
                        if pd.isna(row[path_column]) or row[path_column] == '':
                            logging.error(f"WebTestLoader: {path_column} is required when IsRemote is False and Browser is Edge in row {index + 2}")
                        elif not os.path.exists(row[path_column]):
                            logging.warning(f"WebTestLoader: {path_column} '{row[path_column]}' does not exist in row {index + 2}")

            try:
                if not pd.isna(row['BrowserOptions']) and row['BrowserOptions'] != '':
                    json.loads(row['BrowserOptions'])
            except json.JSONDecodeError:
                logging.error(f"WebTestLoader: Invalid JSON in BrowserOptions in row {index + 2}")

        logging.info("WebTestLoader: WebEnvironments data validation completed.")

    def _validate_custom_actions(self):
        custom_actions = self.get_data_by_sheet_name('CustomActions')
        if custom_actions.empty:
            logging.warning("WebTestLoader: CustomActions sheet is empty.")
            return

        required_columns = ['Action Name', 'Python Code']
        missing_columns = set(required_columns) - set(custom_actions.columns)
        if missing_columns:
            logging.error(f"WebTestLoader: Missing required columns in CustomActions sheet: {', '.join(missing_columns)}")
            return

        for index, row in custom_actions.iterrows():
            if pd.isna(row['Action Name']) or row['Action Name'] == '':
                logging.error(f"WebTestLoader: Empty Action Name in CustomActions row {index + 2}")
            if pd.isna(row['Python Code']) or row['Python Code'] == '':
                logging.error(f"WebTestLoader: Empty Python Code for web_element_actions '{row['Action Name']}' in CustomActions row {index + 2}")

    def get_data_by_sheet_name(self, sheet_name: str) -&gt; pd.DataFrame:
        return self.data.get(sheet_name, pd.DataFrame())

    def filter_cases(self, tcid_list: List[str] = None, tags: List[str] = None) -&gt; pd.DataFrame:
        test_cases = self.get_test_cases()

        if tcid_list:
            test_cases = test_cases[test_cases['Case ID'].isin(tcid_list)]

        if tags:
            test_cases = test_cases[test_cases['Tags'].apply(lambda x: any(tag in str(x).split(',') for tag in tags))]

        if test_cases.empty:
            logging.error("WebTestLoader: No test cases found matching criteria.")
            raise ValueError("No test cases found matching criteria.")

        test_cases = test_cases[test_cases['Run'] == 'Y']

        return test_cases

    def get_test_cases(self) -&gt; pd.DataFrame:
        return self.get_data_by_sheet_name('TestCases')

    def get_test_steps(self, case_id: str) -&gt; pd.DataFrame:
        test_steps = self.get_data_by_sheet_name('TestSteps')
        result = test_steps[(test_steps['Case ID'] == case_id) &amp; (test_steps['Run'] == 'Y')]
        if result.empty:
            logging.warning(f"WebTestLoader: No test steps found for case ID: {case_id}")
        return result

    def get_test_data(self, case_id: str) -&gt; List[Dict]:
        test_data = self.get_data_by_sheet_name('TestData')
        case_data = test_data[test_data['Case ID'] == case_id]

        test_steps = self.get_test_steps(case_id)
        non_api_steps = test_steps[test_steps['Module Name'] != 'API']

        if case_data.empty and not non_api_steps.empty:
            logging.warning(f"WebTestLoader: No test data found for case ID: {case_id}")

        grouped_data = case_data.groupby('Data Set')

        data_sets = []
        for _, group in grouped_data:
            data_set = {}
            for _, row in group.iterrows():
                value = self._parse_value(row['Value'], row['Data Type'])
                data_set[row['Parameter Name']] = value
            data_sets.append(data_set)

        return data_sets

    def _parse_value(self, value: str, data_type: str):
        if data_type.lower() == 'json':
            try:
                return json.loads(value)
            except json.JSONDecodeError:
                logging.error(f"Invalid JSON string: {value}")
                return value
        elif data_type.lower() == 'integer':
            try:
                return int(value)
            except ValueError:
                logging.error(f"Invalid integer value: {value}")
                return value
        elif data_type.lower() == 'float':
            try:
                return float(value)
            except ValueError:
                logging.error(f"Invalid float value: {value}")
                return value
        elif data_type.lower() == 'boolean':
            return value.lower() in ('true', 'yes', '1', 'on')
        else:
            return value

    def get_page_objects(self) -&gt; pd.DataFrame:
        page_objects = self.get_data_by_sheet_name('PageModules')
        return page_objects[page_objects['Run'] == 'Y']

    def get_locators(self) -&gt; pd.DataFrame:
        return self.get_data_by_sheet_name('Locators')

    def get_web_environments(self) -&gt; pd.DataFrame:
        return self.get_data_by_sheet_name('WebEnvironments')

    def get_custom_actions(self) -&gt; Dict[str, str]:
        custom_actions_df = self.get_data_by_sheet_name('CustomActions')
        return dict(zip(custom_actions_df['Action Name'], custom_actions_df['Python Code']))

    def get_environments_variables(self) -&gt; List[Dict[str, str]]:
        """获取当前激活环境的所有变量"""
        environments = self.get_data_by_sheet_name('EnvVariables')
        active_env = self.test_config.get('active_environment')
        if not active_env:
            logging.error("WebTestLoader: 'active_environment' is not defined in test_config.")
            return []
        env_vars = environments[environments['Environment'] == active_env]
        if env_vars.empty:
            logging.warning(f"WebTestLoader: No variables found for environment '{active_env}'.")
            return []
        return env_vars.to_dict('records')

    def set_global_variables(self):
        """将环境变量设置为Robot Framework的全局变量"""
        env_variables = self.get_environments_variables()
        built_in = BuiltIn()
        for var in env_variables:
            var_name = var['Variable Name']
            var_value = var['Variable Value']
            built_in.set_global_variable(f"${{{var_name}}}", var_value)
            logging.info(f"WebTestLoader: Set global variable ${{{var_name}}} = {var_value}")</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_libraries_web_webdriver_factory_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\libraries\web\webdriver_factory.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import logging
from selenium import webdriver
from selenium.webdriver.chrome.service import Service as ChromeService
from selenium.webdriver.edge.service import Service as EdgeService
from selenium.webdriver.chrome.options import Options as ChromeOptions
from selenium.webdriver.edge.options import Options as EdgeOptions


class WebDriverFactory:
    @staticmethod
    def create_driver(driver_config):
        browser = driver_config['browser']
        is_remote = driver_config.get('is_remote', False)
        remote_url = driver_config.get('remote_url')
        browser_options = driver_config.get('browser_options', {})

        logging.info(f"WebDriverFactory: Configuring for browser: {browser}")
        logging.info(f"WebDriverFactory: Remote execution: {'Yes' if is_remote else 'No'}")
        browser_path = None
        if browser.lower() == 'chrome':
            options = ChromeOptions()
            if not is_remote:
                service = ChromeService(executable_path=driver_config.get('chrome_driver_path'))
                browser_path = driver_config.get('chrome_path')
                logging.info(f"WebDriverFactory: Using ChromeDriver path: {driver_config.get('chrome_driver_path')}")
        elif browser.lower() == 'edge':
            options = EdgeOptions()
            if not is_remote:
                service = EdgeService(executable_path=driver_config.get('edge_driver_path'))
                browser_path = driver_config.get('edge_path')
                logging.info(f"WebDriverFactory: Using EdgeDriver path: {driver_config.get('edge_driver_path')}")
        else:
            logging.error(f"WebDriverFactory: Unsupported browser: {browser}")
            raise ValueError(f"WebDriverFactory: Unsupported browser: {browser}")

        # 设置浏览器路径
        if browser_path and not is_remote:
            options.binary_location = browser_path
            logging.info(f"WebDriverFactory: Set browser binary location: {browser_path}")

        # 设置浏览器选项
        logging.info("WebDriverFactory: Configuring browser options:")
        for option, value in browser_options.items():
            if isinstance(value, bool) and value:
                options.add_argument(f'--{option}')
                logging.info(f"WebDriverFactory: Added browser option: --{option}")
            elif isinstance(value, str):
                options.add_argument(f'--{option}={value}')
                logging.info(f"WebDriverFactory: Added browser option: --{option}={value}")

        if is_remote:
            if not remote_url:
                logging.error(f"WebDriverFactory: Remote URL is required for remote execution")
                raise ValueError(f"WebDriverFactory: Remote URL is required for remote execution")
            logging.info(f"WebDriverFactory: Creating remote WebDriver with URL: {remote_url}")
            driver = webdriver.Remote(command_executor=remote_url, options=options)
        else:
            if browser.lower() == 'chrome':
                logging.info(f"WebDriverFactory: Creating local Chrome WebDriver")
                driver = webdriver.Chrome(service=service, options=options)
            elif browser.lower() == 'edge':
                logging.info(f"WebDriverFactory: Creating local Edge WebDriver")
                driver = webdriver.Edge(service=service, options=options)

        logging.info(f"WebDriverFactory: WebDriver created successfully")
        return driver

    @staticmethod
    def quit_driver(driver):
        if driver:
            logging.info(f"WebDriverFactory: Quitting WebDriver")
            driver.close()
            logging.info(f"WebDriverFactory: WebDriver quit successfully")
        else:
            logging.warning(f"WebDriverFactory: Attempted to quit a non-existent WebDriver")
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_main_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\main.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import os
import argparse
from robot.libraries.BuiltIn import BuiltIn
from robot.reporting import ResultWriter
from libraries.common.utility_helpers import PROJECT_ROOT
from libraries.robot.report.summary_report_generator import SummaryReportGenerator
from libraries.robot.report.robot_dashboard_generator import DashboardGenerator
from libraries.robot.case.unified_generator import UnifiedRobotCaseGenerator
from libraries.common.log_manager import logger_instance


class ExitOnFailureListener:
    ROBOT_LISTENER_API_VERSION = 3

    def __init__(self):
        self.exit_on_failure = False

    def end_test(self, data, result):
        if 'sanity check' in [tag.lower() for tag in result.tags] and result.status == 'FAIL':
            self.exit_on_failure = True
            BuiltIn().set_global_variable('${skip_on_sanity_check_failure}', True)


def run_test_suite(suite):
    listener = ExitOnFailureListener()
    output_dir = os.path.join(PROJECT_ROOT, 'report')
    output_xml = os.path.join(output_dir, 'output.xml')
    report_file = os.path.join(output_dir, 'report.html')
    log_file = os.path.join(output_dir, 'log.html')

    suite.run(output=output_xml, listener=listener)

    ResultWriter(output_xml).write_results(report=report_file, log=log_file)

    dashboard_generator = DashboardGenerator()
    dashboard_generator.generate_dashboard(output_xml)

    report_generator = SummaryReportGenerator(output_xml)
    report_generator.generate_html_report()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Run API, Web UI, or E2E tests.')
    parser.add_argument('--api', action='store_true', help='Run API tests')
    parser.add_argument('--web', action='store_true', help='Run Web UI tests')
    parser.add_argument('--e2e', action='store_true', help='Run E2E tests')
    parser.add_argument('--performance', action='store_true', help='Run performance tests')
    args = parser.parse_args()

    test_type_map = {
        'api': args.api,
        'web': args.web,
        'e2e': args.e2e,
        'performance': args.performance
    }
    
    # 获取第一个为True的测试类型，如果都为False则使用默认值
    default_test_type = 'e2e'
    test_type = next((t for t, enabled in test_type_map.items() if enabled), default_test_type)
    
    robot_case_generator = UnifiedRobotCaseGenerator(test_type)
    suite_to_run = robot_case_generator.generate_test_cases()
    run_test_suite(suite_to_run)

</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_requirements_txt">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\requirements.txt</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>Jinja2==3.1.4
pandas==2.2.2
lxml~=5.2.2
openpyxl~=3.1.5
PyYAML==6.0.1
requests==2.32.2
xmltodict~=0.13.0
selenium~=4.22.0
robotframework~=7.0.1
jsonpath-ng~=1.6.1
pillow~=10.4.0
ruamel.yaml~=0.18.6
flask~=3.0.3
urllib3~=2.2.2
numpy~=2.0.1
cx-Oracle~=8.3.0
psycopg2~=2.9.10
matplotlib~=3.9.4
colorama~=0.4.6
pyreadline3~=3.5.4
SQLAlchemy~=2.0.38
pytz~=2024.1</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_templates_rf_report_template_html">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\templates\rf_report_template.html</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet"&gt;
    &lt;link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" rel="stylesheet"&gt;
    &lt;link rel="stylesheet" href="https://cdn.datatables.net/1.11.5/css/dataTables.bootstrap5.min.css"&gt;
    &lt;title&gt;Metrics Report&lt;/title&gt;
    &lt;style&gt;
        .sidebar {
            width: 140px;
            background: #343a40;
            padding: 1rem 0;
            position: fixed;
            height: 100%;
            overflow-y: auto;
            transition: transform 0.3s ease-in-out;
            z-index: 1000;
        }

        @media (max-width: 767.98px) {
            .sidebar {
                transform: translateX(-100%);
            }

            .sidebar.show {
                transform: translateX(0);
            }

            .content {
                margin-left: 0 !important;
            }
        }

        .sidebar .nav-link {
            color: #ffffff;
            text-align: center;
            padding: 1rem 0.5rem;
            transition: all 0.3s ease;
        }

        .sidebar .nav-link i {
            font-size: 2rem;
            display: block;
            margin-bottom: 0.5rem;
        }

        .sidebar .nav-link span {
            font-size: 0.8rem;
            display: block;
        }

        .sidebar .nav-link:hover,
        .sidebar .nav-link.active {
            background-color: #495057;
            border-left: 4px solid #007bff;
        }

        .content {
            margin-left: 160px;
            padding: 1rem;
        }

        .table {
            font-size: 0.875rem;
            border-radius: 10px;
            overflow: hidden;
            border-collapse: separate;
        }

        .table-hover tbody tr:hover {
            background-color: #f1f1f1;
        }

        .table thead th {
            background-color: #343a40;
            color: #ffffff;
            border-bottom: 1px solid #495057;
            border-top: 1px solid #495057;
        }

        .table tbody td {
            border-top: 1px solid #dee2e6;
        }

        .table thead th:first-child {
            border-top-left-radius: 10px;
            border-left: 1px solid #dee2e6;
        }

        .table thead th:last-child {
            border-top-right-radius: 10px;
            border-right: 1px solid #dee2e6;
        }

        .table tbody tr:last-child td:first-child {
            border-bottom-left-radius: 10px;
            border-left: 1px solid #dee2e6;
        }

        .table tbody tr:last-child td:last-child {
            border-bottom-right-radius: 10px;
            border-right: 1px solid #dee2e6;
        }

        .pie-chart {
            width: 100%;
            height: 400px;
            margin-bottom: 2rem;
            background-color: #e9ecef;
            border-radius: 10px;
            padding: 15px;
        }

        .loader {
            border: 0.5rem solid #f3f3f3;
            border-radius: 50%;
            border-top: 0.5rem solid #3498db;
            width: 5rem;
            height: 5rem;
            animation: spin 1s linear infinite;
            margin: auto;
            display: block;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .clickable-link {
            color: #007bff !important;
            cursor: pointer;
        }

        .clickable-link:hover {
            color: #343a40 !important;
            text-decoration: none;
        }

        #menu-toggle {
            position: fixed;
            top: 33px;
            left: 5px;
            z-index: 1001;
            display: none;
            background-color: transparent;
            color: #343a40;
            border: none;
        }

        @media (max-width: 767.98px) {
            #menu-toggle {
                display: block;
            }
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="loader" id="loadingDiv"&gt;&lt;/div&gt;

&lt;button id="menu-toggle" class="btn btn-primary"&gt;
    &lt;i class="fas fa-bars"&gt;&lt;/i&gt;
&lt;/button&gt;

&lt;nav class="sidebar" id="sidebar"&gt;
    &lt;div class="nav flex-column"&gt;
        &lt;a class="nav-link active" href="#" id="defaultOpen" onclick="openPage('dashboard', this)"&gt;
            &lt;i class="fa fa-dashboard"&gt;&lt;/i&gt;
            &lt;span&gt;Dashboard&lt;/span&gt;
        &lt;/a&gt;
        &lt;a class="nav-link" href="#" onclick="openPage('suiteMetrics', this); executeDataTable('#sm', 10, 6);"&gt;
            &lt;i class="fa fa-th-large"&gt;&lt;/i&gt;
            &lt;span&gt;Suite Metrics&lt;/span&gt;
        &lt;/a&gt;
        &lt;a class="nav-link" href="#" onclick="openPage('testMetrics', this); executeDataTable('#tm', 10, 3);"&gt;
            &lt;i class="fa fa-list-alt"&gt;&lt;/i&gt;
            &lt;span&gt;Test Metrics&lt;/span&gt;
        &lt;/a&gt;
        &lt;a class="nav-link" href="#" onclick="openPage('log', this);"&gt;
            &lt;i class="fa fa-file-text"&gt;&lt;/i&gt;
            &lt;span&gt;Robot Logs&lt;/span&gt;
        &lt;/a&gt;
        &lt;a class="nav-link" href="#" onclick="openPage('testSummary', this);"&gt;
            &lt;i class="fa fa-list-check"&gt;&lt;/i&gt;
            &lt;span&gt;Test Summary&lt;/span&gt;
        &lt;/a&gt;
    &lt;/div&gt;
&lt;/nav&gt;

&lt;div class="content" id="main"&gt;
    &lt;div class="tabcontent" id="suiteMetrics"&gt;
        &lt;h4&gt;&lt;b&gt;&lt;i class="fa fa-table"&gt;&lt;/i&gt; Suite Metrics&lt;/b&gt;&lt;/h4&gt;
        &lt;hr&gt;
        &lt;h6 class="text-end"&gt;**Click Suite name to view logs&lt;/h6&gt;
        &lt;table class="table table-hover table-bordered" id="sm"&gt;
            &lt;thead&gt;
            &lt;tr&gt;
                &lt;th&gt;Suite Name&lt;/th&gt;
                &lt;th&gt;Status&lt;/th&gt;
                &lt;th&gt;Total TC&lt;/th&gt;
                &lt;th&gt;Pass TC&lt;/th&gt;
                &lt;th&gt;Fail TC&lt;/th&gt;
                &lt;th&gt;Skip TC&lt;/th&gt;
                &lt;th&gt;Start Time&lt;/th&gt;
                &lt;th&gt;End Time&lt;/th&gt;
                &lt;th&gt;Elapsed Time (s)&lt;/th&gt;
            &lt;/tr&gt;
            &lt;/thead&gt;
            &lt;tbody&gt;
            {% for suite in suites %}
            &lt;tr&gt;
                &lt;td class="clickable-link" onclick="openInNewTab('log.html#{{ suite['Id'] }}','#{{ suite['Id'] }}')"&gt;
                    {{ suite['Name'] }}
                &lt;/td&gt;
                &lt;td class="{% if suite['Status'] == 'PASS' %}text-success{% elif suite['Status'] == 'FAIL' %}text-danger{% else %}text-warning{% endif %}"&gt;{{ suite['Status'] }}
                &lt;/td&gt;
                &lt;td&gt;{{ suite['Total'] }}&lt;/td&gt;
                &lt;td class="text-success"&gt;{{ suite['Pass'] }}&lt;/td&gt;
                &lt;td class="text-danger"&gt;{{ suite['Fail'] }}&lt;/td&gt;
                &lt;td class="text-warning"&gt;{{ suite['Skip'] }}&lt;/td&gt;
                &lt;td&gt;{{ suite['startTime'] }}&lt;/td&gt;
                &lt;td&gt;{{ suite['endTime'] }}&lt;/td&gt;
                &lt;td&gt;{{ (suite['Time']/1000)|round(2) }}&lt;/td&gt;
            &lt;/tr&gt;
            {% endfor %}
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/div&gt;

    &lt;div class="tabcontent" id="testMetrics"&gt;
        &lt;h4&gt;&lt;b&gt;&lt;i class="fa fa-table"&gt;&lt;/i&gt; Test Metrics&lt;/b&gt;&lt;/h4&gt;
        &lt;hr&gt;
        &lt;h6 class="text-end"&gt;**Click Test Case name to view logs&lt;/h6&gt;
        &lt;table class="table table-hover table-bordered" id="tm"&gt;
            &lt;thead&gt;
            &lt;tr&gt;
                &lt;th&gt;Suite Name&lt;/th&gt;
                &lt;th&gt;Test Case&lt;/th&gt;
                &lt;th&gt;Status&lt;/th&gt;
                &lt;th&gt;Start Time&lt;/th&gt;
                &lt;th&gt;End Time&lt;/th&gt;
                &lt;th&gt;Elapsed Time (s)&lt;/th&gt;
                &lt;th&gt;Message&lt;/th&gt;
            &lt;/tr&gt;
            &lt;/thead&gt;
            &lt;tbody&gt;
            {% for test in tests %}
            &lt;tr&gt;
                &lt;td&gt;{{ test['Suite Name'] }}&lt;/td&gt;
                &lt;td class="clickable-link" onclick="openInNewTab('log.html#{{ test['Test Id'] }}','#{{ test['Test Id'] }}')"&gt;
                    {{ test['Test Name'] }}
                &lt;/td&gt;
                &lt;td class="{% if test['Status'] == 'PASS' %}text-success{% elif test['Status'] == 'FAIL' %}text-danger{% else %}text-warning{% endif %}"&gt;{{ test['Status'] }}&lt;/td&gt;
                &lt;td&gt;{{ test['startTime'] }}&lt;/td&gt;
                &lt;td&gt;{{ test['endTime'] }}&lt;/td&gt;
                &lt;td&gt;{{ (test['Time']/1000)|round(2) }}&lt;/td&gt;
                &lt;td&gt;{{ test['Message'] }}&lt;/td&gt;
            &lt;/tr&gt;
            {% endfor %}
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/div&gt;

    &lt;div class="tabcontent" id="log"&gt;
        &lt;h4&gt;&lt;b&gt;&lt;i class="fa fa-file-text"&gt;&lt;/i&gt; Robot Logs&lt;/b&gt;&lt;/h4&gt;
        &lt;hr&gt;
        &lt;p class="text-end"&gt;
            ** &lt;b&gt;Report.html&lt;/b&gt; and &lt;b&gt;Log.html&lt;/b&gt; need to be in the current folder to display here
        &lt;/p&gt;
        &lt;div class="ratio ratio-16x9"&gt;
            &lt;iframe src="log.html"&gt;&lt;/iframe&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class="tabcontent" id="dashboard"&gt;
        &lt;h4&gt;&lt;b&gt;&lt;i class="fa fa-dashboard"&gt;&lt;/i&gt; Dashboard&lt;/b&gt;&lt;/h4&gt;
        &lt;hr&gt;
        &lt;div class="row mb-4"&gt;
            &lt;div class="col-sm-3 col-md-3 mb-3"&gt;
                &lt;div class="card bg-dark text-white text-center"&gt;
                    &lt;div class="card-body"&gt;
                        &lt;h5 class="card-title"&gt;Suite&lt;/h5&gt;
                        &lt;p class="card-text"&gt;Statistics&lt;/p&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="col-sm-3 col-md-3 mb-3"&gt;
                &lt;div class="card bg-primary text-white text-center"&gt;
                    &lt;div class="card-body"&gt;
                        &lt;h5 class="card-title"&gt;{{suite_stats['Total']}}&lt;/h5&gt;
                        &lt;p class="card-text"&gt;Total&lt;/p&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="col-sm-2 col-md-2 mb-2"&gt;
                &lt;div class="card bg-success text-white text-center"&gt;
                    &lt;div class="card-body"&gt;
                        &lt;h5 class="card-title"&gt;{{suite_stats['Pass']}}&lt;/h5&gt;
                        &lt;p class="card-text"&gt;Passed&lt;/p&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="col-sm-2 col-md-2 mb-2"&gt;
                &lt;div class="card bg-danger text-white text-center"&gt;
                    &lt;div class="card-body"&gt;
                        &lt;h5 class="card-title"&gt;{{suite_stats['Fail']}}&lt;/h5&gt;
                        &lt;p class="card-text"&gt;Failed&lt;/p&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="col-sm-2 col-md-2 mb-2"&gt;
                &lt;div class="card bg-warning text-white text-center"&gt;
                    &lt;div class="card-body"&gt;
                        &lt;h5 class="card-title"&gt;{{suite_stats['Skip']}}&lt;/h5&gt;
                        &lt;p class="card-text"&gt;Skipped&lt;/p&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;div class="row mb-4"&gt;
            &lt;div class="col-sm-3 col-md-3 mb-3"&gt;
                &lt;div class="card bg-dark text-white text-center"&gt;
                    &lt;div class="card-body"&gt;
                        &lt;h5 class="card-title"&gt;Test Case&lt;/h5&gt;
                        &lt;p class="card-text"&gt;Statistics&lt;/p&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="col-sm-3 col-md-3 mb-3"&gt;
                &lt;div class="card bg-primary text-white text-center"&gt;
                    &lt;div class="card-body"&gt;
                        &lt;h5 class="card-title"&gt;{{test_stats['Total']}}&lt;/h5&gt;
                        &lt;p class="card-text"&gt;Total&lt;/p&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="col-sm-2 col-md-2 mb-2"&gt;
                &lt;div class="card bg-success text-white text-center"&gt;
                    &lt;div class="card-body"&gt;
                        &lt;h5 class="card-title"&gt;{{test_stats['Pass']}}&lt;/h5&gt;
                        &lt;p class="card-text"&gt;Passed&lt;/p&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="col-sm-2 col-md-2 mb-2"&gt;
                &lt;div class="card bg-danger text-white text-center"&gt;
                    &lt;div class="card-body"&gt;
                        &lt;h5 class="card-title"&gt;{{test_stats['Fail']}}&lt;/h5&gt;
                        &lt;p class="card-text"&gt;Failed&lt;/p&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="col-sm-2 col-md-2 mb-2"&gt;
                &lt;div class="card bg-warning text-white text-center"&gt;
                    &lt;div class="card-body"&gt;
                        &lt;h5 class="card-title"&gt;{{test_stats['Skip']}}&lt;/h5&gt;
                        &lt;p class="card-text"&gt;Skipped&lt;/p&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;div class="row"&gt;
            &lt;div class="col-sm-6 col-md-6 mb-4"&gt;
                &lt;div class="pie-chart"&gt;
                    &lt;canvas id="suiteChart"&gt;&lt;/canvas&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="col-sm-6 col-md-6 mb-4"&gt;
                &lt;div class="pie-chart"&gt;
                    &lt;canvas id="testChart"&gt;&lt;/canvas&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class="tabcontent" id="testSummary"&gt;
        &lt;h4&gt;&lt;b&gt;&lt;i class="fa fa-list-check"&gt;&lt;/i&gt; Test Summary&lt;/b&gt;&lt;/h4&gt;
        &lt;hr&gt;
        &lt;p class="text-end"&gt;
            ** &lt;b&gt;Test_summary.html&lt;/b&gt; needs to be in the current folder to display here
        &lt;/p&gt;
        &lt;div class="ratio ratio-16x9"&gt;
            &lt;iframe src="test_summary.html"&gt;&lt;/iframe&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;script src="https://code.jquery.com/jquery-3.6.0.min.js"&gt;&lt;/script&gt;
&lt;script src="https://cdn.datatables.net/1.11.5/js/jquery.dataTables.min.js"&gt;&lt;/script&gt;
&lt;script src="https://cdn.datatables.net/1.11.5/js/dataTables.bootstrap5.min.js"&gt;&lt;/script&gt;
&lt;script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"&gt;&lt;/script&gt;
&lt;script src="https://cdn.jsdelivr.net/npm/chart.js"&gt;&lt;/script&gt;
&lt;script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"&gt;&lt;/script&gt;
&lt;script&gt;
    document.addEventListener("DOMContentLoaded", function() {
        document.getElementById("loadingDiv").style.display = "none";
        document.getElementById("defaultOpen").click();

        createPieChart('suiteChart', 'Suite Results', ['Pass', 'Fail', 'Skip'],
                       [{{ suite_stats['Pass'] }}, {{ suite_stats['Fail'] }},{{ suite_stats['Skip'] }}],
                       {{ suite_stats['Total'] }});

    createPieChart('testChart', 'Test Case Results', ['Pass', 'Fail', 'Skip'],
                   [{{ test_stats['Pass'] }}, {{ test_stats['Fail'] }}, {{ test_stats['Skip'] }}],
                   {{ test_stats['Total'] }});

    // Toggle sidebar on menu button click
    document.getElementById('menu-toggle').addEventListener('click', function() {
        document.getElementById('sidebar').classList.toggle('show');
    });
});

    function createPieChart(canvasId, title, labels, data, total) {
        var ctx = document.getElementById(canvasId).getContext('2d');
        Chart.register(ChartDataLabels);
        var chart = new Chart(ctx, {
            type: 'pie',
            data: {
                labels: labels,
                datasets: [{
                    label: title,
                    data: data,
                    backgroundColor: ['#28a745', '#dc3545', '#ffc107'],
                    hoverOffset: 4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'bottom',
                    },
                    title: {
                        display: true,
                        text: title
                    },
                    tooltip: {
                        callbacks: {
                            label: function(tooltipItem) {
                                var value = tooltipItem.raw;
                                var percentage = ((value / total) * 100).toFixed(2);
                                return tooltipItem.label + ': ' + value + ' (' + percentage + '%)';
                            }
                        }
                    },
                    datalabels: {
                        color: '#fff',
                        font: {
                            weight: 'bold'
                        },
                        formatter: function(value, context) {
                            var percentage = ((value / total) * 100).toFixed(2);
                            return percentage + '%';
                        }
                    }
                }
            }
        });
    }

function openPage(pageName, elmnt) {
    var i, tabcontent, tablinks;
    tabcontent = document.getElementsByClassName("tabcontent");
    for (i = 0; i &lt; tabcontent.length; i++) {
        tabcontent[i].style.display = "none";
    }
    tablinks = document.getElementsByClassName("nav-link");
    for (i = 0; i &lt; tablinks.length; i++) {
        tablinks[i].className = tablinks[i].className.replace(" active", "");
    }
    document.getElementById(pageName).style.display = "block";
    elmnt.className += " active";

    // Hide sidebar on page change for mobile devices
    if (window.innerWidth &lt;= 767.98) {
        document.getElementById('sidebar').classList.remove('show');
    }
}

function executeDataTable(tableID, minRows, sortIndex) {
    if ($.fn.DataTable.isDataTable(tableID)) {
        $(tableID).DataTable().destroy();
    }
    $(tableID).DataTable({
        "pageLength": minRows,
        "ordering": true,
        "searching": true,
        "paging": true,
        "info": true,
        "lengthChange": true,
        "order": [[sortIndex, "asc"]],
        "language": {
            "paginate": {
                "previous": "&lt;",
                "next": "&gt;"
            }
        }
    });
}

$(document).ready(function () {
    $('[data-bs-toggle="tooltip"]').tooltip();
    executeDataTable('#sm', 10, 6);
    executeDataTable('#tm', 10, 3);
    document.getElementById("defaultOpen").click();
});
function openInNewTab(url) {
    window.open(url, '_blank').focus();
}
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_templates_test_summary_template_html">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\templates\test_summary_template.html</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Test Summary Report&lt;/title&gt;
    &lt;style&gt;
        body {
            font-family: sans-serif;
            margin: 0;
            padding: 20px;
        }

        h1 {
            text-align: center;
        }

        table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 20px;
        }

        th, td {
            text-align: left;
            padding: 8px;
            border: 1px solid #ddd;
        }

        th {
            background-color: #f2f2f2;
        }

        .pass {
            color: green;
        }

        .fail {
            color: red;
        }

        .warning {
            color: orange;
        }
        .description-cell {
        max-width: 200px;
        word-wrap: break-word;
        white-space: normal;
        font-size: 0.8em;
        }
        .field-cell {
        max-width: 300px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        font-size: 0.8em;
        }
        .type-cell {
        max-width: 200px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        font-size: 0.8em;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Test Summary Report&lt;/h1&gt;
{{ html_table }}
&lt;/body&gt;
&lt;/html&gt;</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_testing_server_positions_json">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\testing_server\positions.json</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>{
    "balances": {
        "USD": 13500.0,
        "EUR": 8000.0,
        "HKD": 50000.0,
        "CNY": 55900.0
    },
    "transactions": {
        "USD": {
            "2024-05-29": {
                "inbound": {
                    "count": 2,
                    "total_amount": 4000.0
                },
                "outbound": {
                    "count": 0,
                    "total_amount": 0.0
                }
            }
        },
        "EUR": {
            "2024-05-28": {
                "inbound": {
                    "count": 1,
                    "total_amount": 200.0
                },
                "outbound": {
                    "count": 2,
                    "total_amount": 150.0
                }
            }
        },
        "HKD": {
            "2024-05-28": {
                "inbound": {
                    "count": 0,
                    "total_amount": 0.0
                },
                "outbound": {
                    "count": 1,
                    "total_amount": 1000.0
                }
            }
        },
        "CNY": {
            "2025-02-28": {
                "inbound": {
                    "count": 2,
                    "total_amount": 200.0
                },
                "outbound": {
                    "count": 2,
                    "total_amount": 200.0
                }
            }
        }
    }
}</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_testing_server_server_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\testing_server\server.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import json
from flask import Flask, request, jsonify, Response
import xml.etree.ElementTree as ET
from datetime import datetime

app = Flask(__name__)

def round_to_two_decimals(value):
    return round(float(value), 2)

def load_positions():
    try:
        with open('positions.json', 'r') as file:
            data = json.load(file)
    except FileNotFoundError:
        data = {
            "balances": {},
            "transactions": {}
        }

    if 'balances' not in data:
        data['balances'] = {}
    if 'transactions' not in data:
        data['transactions'] = {}

    return data

def save_positions(data):
    with open('positions.json', 'w') as file:
        json.dump(data, file, indent=4)

def clear_old_positions():
    data = load_positions()
    today = datetime.today().strftime('%Y-%m-%d')

    for currency, transactions in data['transactions'].items():
        if today in transactions:
            data['transactions'][currency] = {today: transactions[today]}

    save_positions(data)

def parse_iso20022_pacs008(xml_data):
    try:
        root = ET.fromstring(xml_data)
        transaction_id = root.find('.//{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}InstrId').text
        amount = round_to_two_decimals(float(root.find('.//{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}IntrBkSttlmAmt').text))
        currency = root.find('.//{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}IntrBkSttlmAmt').attrib['Ccy']

        debtor = {
            "name": root.find('.//{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}Dbtr/{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}Nm').text,
            "phones": [phone.text for phone in root.findall('.//{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}Dbtr/{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}PstlAdr/{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}Phne')],
            "email": root.find('.//{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}Dbtr/{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}CtctDtls/{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}EmailAdr').text,
            "address": root.find('.//{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}Dbtr/{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}PstlAdr/{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}StrtNm').text
        }

        creditor = {
            "name": root.find('.//{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}Cdtr/{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}Nm').text,
            "phones": [phone.text for phone in root.findall('.//{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}Cdtr/{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}PstlAdr/{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}Phne')],
            "email": root.find('.//{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}Cdtr/{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}CtctDtls/{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}EmailAdr').text,
            "address": root.find('.//{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}Cdtr/{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}PstlAdr/{urn:iso:std:iso:20022:tech:xsd:pacs.008.001.02}StrtNm').text
        }
        return {
            "transaction_id": transaction_id,
            "amount": amount,
            "currency": currency,
            "debtor": debtor,
            "creditor": creditor
        }
    except Exception as e:
        return {"error": str(e)}

def dict_to_xml(tag, d):
    elem = ET.Element(tag)
    for key, val in d.items():
        child = ET.Element(key)
        if isinstance(val, dict):
            child.extend(dict_to_xml(key, val))
        else:
            child.text = str(val)
        elem.append(child)
    return elem

@app.route('/api/outbound_payment.xml', methods=['POST'])
def outbound_payment_xml():
    xml_data = request.data
    parsed_data = parse_iso20022_pacs008(xml_data)
    if "error" in parsed_data:
        return jsonify(parsed_data), 400

    data = load_positions()
    currency = parsed_data['currency']
    amount = parsed_data['amount']

    if currency in data['balances']:
        data['balances'][currency] = round_to_two_decimals(data['balances'][currency] - amount)
    else:
        return jsonify({"error": f"Currency {currency} not found"}), 400

    today = datetime.today().strftime('%Y-%m-%d')
    if currency not in data['transactions']:
        data['transactions'][currency] = {}

    if today not in data['transactions'][currency]:
        data['transactions'][currency][today] = {"inbound": {"count": 0, "total_amount": 0.0},
                                                 "outbound": {"count": 0, "total_amount": 0.0}}

    data['transactions'][currency][today]["outbound"]["count"] += 1
    data['transactions'][currency][today]["outbound"]["total_amount"] = round_to_two_decimals(
        data['transactions'][currency][today]["outbound"]["total_amount"] + amount
    )

    save_positions(data)

    response = {
        **parsed_data,
        "status": "Outbound Processed",
        "new_position": round_to_two_decimals(data['balances'][currency]),
        "cdata_content": f"&lt;![CDATA[This is a CDATA section for currency {currency}]]&gt;"
    }

    response_xml = dict_to_xml('result', response)
    xml_str = ET.tostring(response_xml, encoding='unicode', method='xml')
    xml_str = xml_str.replace('&amp;lt;![CDATA[', '&lt;![CDATA[').replace(']]&amp;gt;', ']]&gt;')
    xml_response = f'&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n{xml_str}'
    return Response(xml_response, content_type='application/xml')

@app.route('/api/inbound_payment.xml', methods=['POST'])
def inbound_payment_xml():
    xml_data = request.data
    parsed_data = parse_iso20022_pacs008(xml_data)
    if "error" in parsed_data:
        return jsonify(parsed_data), 400

    data = load_positions()
    currency = parsed_data['currency']
    amount = parsed_data['amount']

    if currency in data['balances']:
        data['balances'][currency] = round_to_two_decimals(data['balances'][currency] + amount)
    else:
        data['balances'][currency] = round_to_two_decimals(amount)

    today = datetime.today().strftime('%Y-%m-%d')
    if currency not in data['transactions']:
        data['transactions'][currency] = {}

    if today not in data['transactions'][currency]:
        data['transactions'][currency][today] = {"inbound": {"count": 0, "total_amount": 0.0},
                                                 "outbound": {"count": 0, "total_amount": 0.0}}

    data['transactions'][currency][today]["inbound"]["count"] += 1
    data['transactions'][currency][today]["inbound"]["total_amount"] = round_to_two_decimals(
        data['transactions'][currency][today]["inbound"]["total_amount"] + amount
    )

    save_positions(data)

    response = {
        **parsed_data,
        "status": "Inbound Processed",
        "new_position": round_to_two_decimals(data['balances'][currency]),
        "cdata_content": f"&lt;![CDATA[This is a CDATA section for currency {currency}]]&gt;"
    }

    response_xml = dict_to_xml('result', response)
    xml_str = ET.tostring(response_xml, encoding='unicode', method='xml')
    xml_str = xml_str.replace('&amp;lt;![CDATA[', '&lt;![CDATA[').replace(']]&amp;gt;', ']]&gt;')
    xml_response = f'&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n{xml_str}'
    return Response(xml_response, content_type='application/xml')

@app.route('/api/outbound_payment.json', methods=['POST'])
def outbound_payment_json():
    request_data = request.json

    try:
        transaction_id = request_data['transaction_id']
        amount = round_to_two_decimals(request_data['amount'])
        currency = request_data['currency']
        debtor = request_data['debtor']
        creditor = request_data['creditor']
    except KeyError as e:
        return jsonify({"error": f"Missing key: {str(e)}"}), 400

    data = load_positions()

    if currency in data['balances']:
        data['balances'][currency] = round_to_two_decimals(data['balances'][currency] - amount)
    else:
        return jsonify({"error": f"Currency {currency} not found"}), 400

    today = datetime.today().strftime('%Y-%m-%d')
    if currency not in data['transactions']:
        data['transactions'][currency] = {}

    if today not in data['transactions'][currency]:
        data['transactions'][currency][today] = {"inbound": {"count": 0, "total_amount": 0.0},
                                                 "outbound": {"count": 0, "total_amount": 0.0}}

    data['transactions'][currency][today]["outbound"]["count"] += 1
    data['transactions'][currency][today]["outbound"]["total_amount"] = round_to_two_decimals(
        data['transactions'][currency][today]["outbound"]["total_amount"] + amount
    )

    save_positions(data)

    response = {
        "transaction_id": transaction_id,
        "amount": amount,
        "currency": currency,
        "debtor": debtor,
        "creditor": creditor,
        "status": "Outbound Processed",
        "new_position": round_to_two_decimals(data['balances'][currency])
    }
    return jsonify(response), 200

@app.route('/api/inbound_payment.json', methods=['POST'])
def inbound_payment_json():
    request_data = request.json

    try:
        transaction_id = request_data['transaction_id']
        amount = round_to_two_decimals(request_data['amount'])
        currency = request_data['currency']
        debtor = request_data['debtor']
        creditor = request_data['creditor']
    except KeyError as e:
        return jsonify({"error": f"Missing key: {str(e)}"}), 400

    data = load_positions()

    if currency in data['balances']:
        data['balances'][currency] = round_to_two_decimals(data['balances'][currency] + amount)
    else:
        data['balances'][currency] = round_to_two_decimals(amount)

    today = datetime.today().strftime('%Y-%m-%d')
    if currency not in data['transactions']:
        data['transactions'][currency] = {}

    if today not in data['transactions'][currency]:
        data['transactions'][currency][today] = {"inbound": {"count": 0, "total_amount": 0.0},
                                                 "outbound": {"count": 0, "total_amount": 0.0}}

    data['transactions'][currency][today]["inbound"]["count"] += 1
    data['transactions'][currency][today]["inbound"]["total_amount"] = round_to_two_decimals(
        data['transactions'][currency][today]["inbound"]["total_amount"] + amount
    )

    save_positions(data)

    response = {
        "transaction_id": transaction_id,
        "amount": amount,
        "currency": currency,
        "debtor": debtor,
        "creditor": creditor,
        "status": "Inbound Processed",
        "new_position": round_to_two_decimals(data['balances'][currency])
    }
    return jsonify(response), 200

@app.route('/api/positions', methods=['POST'])
def get_positions():
    clear_old_positions()
    request_data = request.json
    data = load_positions()
    today = datetime.today().strftime('%Y-%m-%d')

    if not isinstance(request_data, list):
        return jsonify({"error": "Request body must be a list of currencies"}), 400

    results = []
    for currency in request_data:
        if currency in data['balances']:
            transactions = data['transactions'].get(currency, {}).get(today,
                                                                      {"inbound": {"count": 0, "total_amount": 0.0},
                                                                       "outbound": {"count": 0, "total_amount": 0.0}})
            results.append({
                "currency": currency,
                "balance": round_to_two_decimals(data['balances'][currency]),
                "value_date": today,
                "inbound": {
                    "count": transactions["inbound"]["count"],
                    "total_amount": round_to_two_decimals(transactions["inbound"]["total_amount"])
                },
                "outbound": {
                    "count": transactions["outbound"]["count"],
                    "total_amount": round_to_two_decimals(transactions["outbound"]["total_amount"])
                }
            })
        else:
            results.append({
                "currency": currency,
                "balance": 0.00,
                "value_date": today,
                "inbound": {"count": 0, "total_amount": 0.00},
                "outbound": {"count": 0, "total_amount": 0.00}
            })

    return jsonify(results), 200

@app.route('/api/positions2', methods=['GET'])
def get_all_positions():
    clear_old_positions()
    data = load_positions()
    today = datetime.today().strftime('%Y-%m-%d')

    results = []
    for currency in data['balances']:
        transactions = data['transactions'].get(currency, {}).get(today,
                                                                  {"inbound": {"count": 0, "total_amount": 0.0},
                                                                   "outbound": {"count": 0, "total_amount": 0.0}})
        results.append({
            "currency": currency,
            "balance": round_to_two_decimals(data['balances'][currency]),
            "value_date": today,
            "inbound": {
                "count": transactions["inbound"]["count"],
                "total_amount": round_to_two_decimals(transactions["inbound"]["total_amount"])
            },
            "outbound": {
                "count": transactions["outbound"]["count"],
                "total_amount": round_to_two_decimals(transactions["outbound"]["total_amount"])
            }
        })

    return jsonify(results), 200

if __name__ == '__main__':
    app.run(debug=True, port=5000)
</pre>
</div>

<div class="code-container" id="C:_Users_vhuang1_PycharmProjects_api_test_framework_yaml_config_cli_py">
    <div class="class-header">C:\Users\vhuang1\PycharmProjects\api_test_framework\yaml_config_cli.py</div>
    <button class="copy-button" onclick="copyToClipboard(this)">Copy</button>
    <button class="return-button" onclick="returnToDirectory()">Return</button>
    <pre>import argparse
from ruamel.yaml import YAML
import os
from typing import Any, Dict
from libraries.common.utility_helpers import PROJECT_ROOT


class YamlConfigManager:
    """A class for managing YAML configuration files.
    python yaml_config_cli.py configs/api_test_config.yaml --update active_environment PROD --update test_cases_path "test_cases/new_test_cases.xlsx" --update clear_saved_fields_after_test False
    python yaml_config_cli.py configs/api_test_config.yaml --add-to-list tc_id_list TC001 --add-to-list tags api
    python yaml_config_cli.py configs/api_test_config.yaml --remove-from-list tags deprecated
    python yaml_config_cli.py configs/api_test_config.yaml --update active_environment PROD --add-to-list tc_id_list TC001 --remove-from-list tags deprecated
    """
    def __init__(self, file_path: str):
        self.file_path = os.path.join(PROJECT_ROOT, file_path)
        self.yaml = YAML()
        self.yaml.preserve_quotes = True
        self.yaml.indent(mapping=2, sequence=4, offset=2)
        self.config = self.load_yaml()

    def load_yaml(self) -&gt; Dict[str, Any]:
        """Load YAML configuration from the file."""
        if os.path.exists(self.file_path):
            with open(self.file_path, 'r') as file:
                return self.yaml.load(file) or {}
        return {}

    def save_yaml(self):
        """Save YAML configuration to the file."""
        with open(self.file_path, 'w') as file:
            self.yaml.dump(self.config, file)

    def update_config(self, key: str, value: Any):
        """Update the configuration for a given key with the provided value."""
        keys = key.split('.')
        current = self.config
        for k in keys[:-1]:
            if k not in current:
                current[k] = {}
            current = current[k]
        current[keys[-1]] = value
        self.save_yaml()

    def get_config(self, key: str) -&gt; Any:
        """Retrieve the configuration value for a given key."""
        keys = key.split('.')
        current = self.config
        for k in keys:
            if k not in current:
                return None
            current = current[k]
        return current

    def add_to_list(self, key: str, value: Any):
        """Add a value to the list at the given key."""
        current_list = self.get_config(key)
        if current_list is None:
            self.update_config(key, [value])
        elif isinstance(current_list, list):
            if value not in current_list:
                current_list.append(value)
                self.save_yaml()
        else:
            raise ValueError(f"The key '{key}' does not point to a list.")

    def remove_from_list(self, key: str, value: Any):
        """Remove a value from the list at the given key."""
        current_list = self.get_config(key)
        if isinstance(current_list, list):
            if value in current_list:
                current_list.remove(value)
                self.save_yaml()
        else:
            raise ValueError(f"The key '{key}' does not point to a list.")


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Manage YAML configuration file.')
    parser.add_argument('file_path', help='Path to the YAML configuration file')
    parser.add_argument('--update', nargs=2, action='append', metavar=('KEY', 'VALUE'),
                        help='Update a configuration value. Can be used multiple times.')
    parser.add_argument('--add-to-list', nargs=2, action='append', metavar=('KEY', 'VALUE'),
                        help='Add a value to a list. Can be used multiple times.')
    parser.add_argument('--remove-from-list', nargs=2, action='append', metavar=('KEY', 'VALUE'),
                        help='Remove a value from a list. Can be used multiple times.')

    args = parser.parse_args()

    yaml_manager = YamlConfigManager(args.file_path)

    if args.update:
        for key, value in args.update:
            # Try to convert the value to the appropriate type
            try:
                value = eval(value)
            except:
                pass  # If conversion fails, keep it as a string
            yaml_manager.update_config(key, value)
            print(f"Updated {key} to {value}")

    if args.add_to_list:
        for key, value in args.add_to_list:
            yaml_manager.add_to_list(key, value)
            print(f"Added {value} to list {key}")

    if args.remove_from_list:
        for key, value in args.remove_from_list:
            yaml_manager.remove_from_list(key, value)
            print(f"Removed {value} from list {key}")

    # Print the updated configuration
    print("\nUpdated configuration:")
    with open(args.file_path, 'r') as file:
        print(file.read())
</pre>
</div>


    <script>
        function copyToClipboard(button) {
            const codeContainer = button.parentElement;
            const code = codeContainer.querySelector('pre').innerText;
            navigator.clipboard.writeText(code).then(() => {
                button.innerText = 'Copied!';
                setTimeout(() => { button.innerText = 'Copy'; }, 2000);
            });
        }
        function returnToDirectory() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
    </script>
</body>
</html>
