---
layout:     post
title:      "groovy"
subtitle:   "「 End to End Auto Testing 」" 
date:       2024-10-05 12:00:00
author:     "Vick Huang"
header-img: "img/bg-walle.jpg"
catalog: true
tags:
    - Testing
    - Automated Testing
---



这个脚本看起来不错，但是有几个地方可以改进以提高性能和线程安全性：

1.  **批量查询数据**：在 `queryDatabase` 方法中，您可以使用 `batchSize` 参数来控制每次查询的数据量。这样可以减少数据库的负担和网络传输的数据量。

2.  **线程安全**：在 `getUnusedData` 方法中，您使用了 `queue.poll()` 来获取未使用的数据。这个方法是线程安全的，但是如果多个线程同时调用这个方法，可能会导致数据丢失或重复使用。为了避免这个问题，您可以使用 `synchronized` 块来确保只有一个线程可以访问队列。

3.  **数据刷新**：在 `refreshData` 方法中，您使用了 `queue.addAll(newData)` 来添加新数据到队列中。这个方法是线程安全的，但是如果多个线程同时调用这个方法，可能会导致数据重复添加。为了避免这个问题，您可以使用 `synchronized` 块来确保只有一个线程可以添加数据到队列中。

4.  **计数器**：在 `counter.incrementAndGet()` 方法中，您使用了 `AtomicInteger` 来确保线程安全性。这个方法是正确的，但是您可以使用 `synchronized` 块来确保只有一个线程可以访问计数器。

5.  **日志记录**：在脚本中，您使用了 `log.info` 和 `log.error` 来记录日志。这个方法是正确的，但是您可以使用 `synchronized` 块来确保只有一个线程可以访问日志记录。

以下是改进后的脚本：

```groovy
import groovy.sql.Sql
import java.sql.SQLException
import java.util.concurrent.ConcurrentLinkedQueue
import java.util.concurrent.atomic.AtomicInteger

// 初始化连接池（应在测试计划开始时执行）
def initConnectionPool() {
    synchronized (this) {
        if (!props.get('dbConnectionPool')) {
            def dbUrl = props.get('db.url')
            def dbUser = props.get('db.user')
            def dbPass = props.get('db.pass')
            def pool = Sql.newInstance(dbUrl, dbUser, dbPass, 'org.postgresql.Driver')
            props.put('dbConnectionPool', pool)
        }
    }
}

// 获取连接池
def getConnectionPool() {
    synchronized (this) {
        def pool = props.get('dbConnectionPool')
        if (!pool) {
            initConnectionPool()
            pool = props.get('dbConnectionPool')
        }
        return pool
    }
}

// 初始化全局数据队列
def initGlobalDataQueue() {
    synchronized (this) {
        if (!props.get('globalDataQueue')) {
            props.put('globalDataQueue', new ConcurrentLinkedQueue())
        }
    }
}

// 获取全局数据队列
def getGlobalDataQueue() {
    synchronized (this) {
        def queue = props.get('globalDataQueue')
        if (!queue) {
            initGlobalDataQueue()
            queue = props.get('globalDataQueue')
        }
        return queue
    }
}

// 批量查询数据
def batchSize = 1000 // 可以根据需要调整
def queryDatabase(batchSize) {
    synchronized (this) {
        def pool = getConnectionPool()
        try {
            def query = "SELECT column1, column2 FROM your_table LIMIT ${batchSize}"
            return pool.rows(query)
        } catch (SQLException e) {
            log.error("Database query failed: " + e.getMessage())
            return []
        }
    }
}

// 获取或刷新数据
def refreshData() {
    synchronized (this) {
        log.info("Querying database for new data.")
        def newData = queryDatabase(batchSize)
        def queue = getGlobalDataQueue()
        queue.addAll(newData)
        log.info("Added ${newData.size()} new items to the global queue.")
    }
}

// 获取未使用的数据
def getUnusedData() {
    synchronized (this) {
        def queue = getGlobalDataQueue()
        def data = queue.poll()
        if (data == null && queue.isEmpty()) {
            refreshData()
            data = queue.poll()
        }
        return data
    }
}

// 主逻辑
def unusedData = getUnusedData()

if (unusedData != null) {
    vars.put('param1', unusedData.column1)
    vars.put('param2', unusedData.column2)
    log.info("Using data: ${unusedData.column1}, ${unusedData.column2}")
} else {
    log.error("Failed to get unused data.")
    vars.put('CONTINUE', 'false')
}

// 使用计数器来跟踪数据使用情况，当达到一定阈值时刷新数据
def counter = props.get('dataUsageCounter') ?: new AtomicInteger(0)
synchronized (this) {
    if (counter.incrementAndGet() % 1000 == 0) { // 每1000次请求检查一次
        def queue = getGlobalDataQueue()
        if (queue.size() < batchSize / 2) {
            refreshData()
        }
    }
}
props.put('dataUsageCounter', counter)
```

这个改进后的脚本使用了 `synchronized` 块来确保线程安全性，避免了数据丢失或重复使用的问题。同时，使用了 `AtomicInteger` 来确保计数器的线程安全性。