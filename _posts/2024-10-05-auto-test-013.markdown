---
layout:     post
title:      "groovy无重复数据"
subtitle:   "「 End to End Auto Testing 」" 
date:       2024-10-05 12:00:00
author:     "Vick Huang"
header-img: "img/bg-walle.jpg"
catalog: true
tags:
    - Testing
    - Automated Testing
---



为了实现从数据库查询数据、使用这些数据发送HTTP请求、以及在测试结束后清理资源，我们需要结合以下几个关键组件：

### 测试计划结构

- **Test Plan**
  - **Thread Group**
    - **JDBC Connection Configuration**
    - **While Controller**
      - **JSR223 PreProcessor**
      - **HTTP Request**
    - **JSR223 Listener** (用于清理)
  - **tearDown Thread Group**
    - **JSR223 Sampler** (用于清理资源)

### 详细配置

#### a) JDBC Connection Configuration
- **Variable Name**: `dbConnection`
- **Database URL**: `${__P(db.url,jdbc:postgresql://localhost:5432/your_database)}`
- **JDBC Driver class**: `org.postgresql.Driver`
- **Username**: `${__P(db.user,postgres)}`
- **Password**: `${__P(db.pass,password)}`

#### b) While Controller
- **Condition**: `${__jexl3("${CONTINUE}" != "false")}`

#### c) JSR223 PreProcessor (使用Groovy)

```groovy
import groovy.sql.Sql
import java.sql.SQLException
import java.util.concurrent.ConcurrentLinkedQueue
import java.util.concurrent.atomic.AtomicInteger

// 初始化连接池（应在测试计划开始时执行）
def initConnectionPool() {
    synchronized (this) {
        if (!props.get('dbConnectionPool')) {
            def dbUrl = props.get('db.url')
            def dbUser = props.get('db.user')
            def dbPass = props.get('db.pass')
            def pool = Sql.newInstance(dbUrl, dbUser, dbPass, 'org.postgresql.Driver')
            props.put('dbConnectionPool', pool)
        }
    }
}

// 获取连接池
def getConnectionPool() {
    synchronized (this) {
        def pool = props.get('dbConnectionPool')
        if (!pool) {
            initConnectionPool()
            pool = props.get('dbConnectionPool')
        }
        return pool
    }
}

// 初始化全局数据队列
def initGlobalDataQueue() {
    synchronized (this) {
        if (!props.get('globalDataQueue')) {
            props.put('globalDataQueue', new ConcurrentLinkedQueue())
        }
    }
}

// 获取全局数据队列
def getGlobalDataQueue() {
    synchronized (this) {
        def queue = props.get('globalDataQueue')
        if (!queue) {
            initGlobalDataQueue()
            queue = props.get('globalDataQueue')
        }
        return queue
    }
}

// 批量查询数据
def batchSize = 1000 // 可以根据需要调整
def queryDatabase(batchSize) {
    synchronized (this) {
        def pool = getConnectionPool()
        try {
            def query = "SELECT column1, column2 FROM your_table LIMIT ${batchSize}"
            return pool.rows(query)
        } catch (SQLException e) {
            log.error("Database query failed: " + e.getMessage())
            return []
        }
    }
}

// 获取或刷新数据
def refreshData() {
    synchronized (this) {
        log.info("Querying database for new data.")
        def newData = queryDatabase(batchSize)
        def queue = getGlobalDataQueue()
        queue.addAll(newData)
        log.info("Added ${newData.size()} new items to the global queue.")
    }
}

// 获取未使用的数据
def getUnusedData() {
    synchronized (this) {
        def queue = getGlobalDataQueue()
        def data = queue.poll()
        if (data == null && queue.isEmpty()) {
            refreshData()
            data = queue.poll()
        }
        return data
    }
}

// 主逻辑
def unusedData = getUnusedData()

if (unusedData != null) {
    vars.put('param1', unusedData.column1)
    vars.put('param2', unusedData.column2)
    log.info("Using data: ${unusedData.column1}, ${unusedData.column2}")
} else {
    log.error("Failed to get unused data.")
    vars.put('CONTINUE', 'false')
}

// 使用计数器来跟踪数据使用情况，当达到一定阈值时刷新数据
def counter = props.get('dataUsageCounter') ?: new AtomicInteger(0)
synchronized (this) {
    if (counter.incrementAndGet() % 1000 == 0) { // 每1000次请求检查一次
        def queue = getGlobalDataQueue()
        if (queue.size() < batchSize / 2) {
            refreshData()
        }
    }
}
props.put('dataUsageCounter', counter)
```

#### d) HTTP Request
- **Method**: POST (或根据需求选择)
- **Protocol**: http
- **Server Name or IP**: your_server_address
- **Path**: /your_api_endpoint
- **Parameters**:
  - Name: param1, Value: `${param1}`
  - Name: param2, Value: `${param2}`

#### e) Response Assertion (用于检查响应是否包含某个字符串)
- **Assertion Type**: Response Assertion
- **Pattern Matching Rules**: Contains
- **Pattern to Test**: 要检查的字符串（如 "success"）
- **Apply to**: Text Response

#### f) tearDown Thread Group
- **Name**: tearDown Thread Group
- **Number of Threads**: 1
- **Ramp-up Period**: 1
- **Loop Count**: 1

#### g) JSR223 Sampler (用于清理资源，在tearDown Thread Group中)
```groovy
// 清理连接池和全局数据
def pool = props.get('dbConnectionPool')
if (pool) {
    pool.close()
    props.remove('dbConnectionPool')
}

// 清理全局数据队列
def queue = props.get('globalDataQueue')
if (queue) {
    queue.clear()
    props.remove('globalDataQueue')
}

// 清理计数器
def counter = props.get('dataUsageCounter')
if (counter) {
    props.remove('dataUsageCounter')
}

log.info("Cleaned up database connection pool, global data queue, and usage counter.")
```

### 设置 tearDown Thread Group 执行选项

确保在 **Test Plan** 元件中勾选 **"Run tearDown Thread Groups after shutdown of main threads"**，这样可以保证在测试结束后，无论测试是否正常完成，tearDown Thread Group 都会执行。

### 工作流程

1. **初始化连接池和数据队列**：
   - 在测试开始时，初始化数据库连接池和全局数据队列。

2. **执行While Controller**：
   - While Controller 确保测试持续运行直到没有更多可用数据。
   - 每次迭代，JSR223 PreProcessor 执行以下操作：
     - 检查是否有当前数据集，如果没有则查询数据库。
     - 从当前数据集中查找未使用的数据。
     - 如果所有数据都已使用，重新查询数据库并更新数据集。
     - 如果找到未使用的数据，将其设置为变量供 HTTP Request 使用。
     - 如果没有可用数据，停止测试。

3. **发送HTTP请求**：
   - HTTP Request 使用选定的数据作为参数发送请求。
   - 使用 Response Assertion 检查响应是否包含或不包含某个字符串。

4. **清理资源**：
   - 在测试结束后，tearDown Thread Group 执行清理脚本，关闭数据库连接池，清空全局数据队列，移除计数器。

通过这种方式，你可以确保在高并发场景下，数据被正确地使用和清理，同时保证资源在测试结束后被正确地释放。