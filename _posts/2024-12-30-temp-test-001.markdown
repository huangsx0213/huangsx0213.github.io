---
layout:     post
title:      "Temp1"
subtitle:   "「 Testing 」" 
date:       2024-12-30 11:00:01
author:     "Vick Huang"
header-img: "img/bg-walle.jpg"
catalog: true
tags:
    - Testing
---



你的方法 `wait_for_js_framework_stability` 使用 Selenium 的 `WebDriverWait` 来等待 JavaScript 框架稳定。这是一个很好的实现方式，可以帮助确保所有异步操作完成后再进行后续的测试步骤。以下是对你方法的详细说明和完整示例。

## **方法解析**

### 1. **使用 `WebDriverWait`**
- `WebDriverWait` 是 Selenium 提供的显式等待机制，可以等待某个条件成立。
- `self.driver` 表示当前的 WebDriver 实例，`self.timeout` 是等待的最大时间。
- `poll_frequency=0.1` 表示每 0.1 秒检查一次条件。

### 2. **执行 JavaScript 脚本**
- `script` 变量保存了要执行的 JavaScript 代码。
- `wait.until(lambda driver: driver.execute_script(script))` 会不断执行这个脚本，直到返回值为 `True`，表示 JS 框架已经稳定。

## **完整示例**

以下是一个完整的类示例，展示了如何使用这个方法来等待 JavaScript 框架的稳定状态：

```python
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

class JSFrameworkWaiter:
    def __init__(self, driver, timeout=10):
        self.driver = driver
        self.timeout = timeout

    def wait_for_js_framework_stability(self):
        wait = WebDriverWait(self.driver, self.timeout, poll_frequency=0.1)
        # 将等待框架稳定的脚本定义为字符串
        wait_for_js_framework_stability = """
            function waitForFrameworkStability() {
                function hasPendingAsyncOperation() {
                    var xhrRequests = Array.from(document.querySelectorAll('xhr-request'));
                    if (xhrRequests.some(isXhrRequestPending)) {
                        return true;
                    }
                    
                    var pendingTimers = Array.from(document.querySelectorAll('timer')).filter(isTimerPending);
                    if (pendingTimers.length > 0) {
                        return true;
                    }
                    
                    var pendingAnimationFrame = Array.from(document.querySelectorAll('animation-frame')).some(isAnimationFramePending);
                    if (pendingAnimationFrame) {
                        return true;
                    }
                    
                    return false;
                }

                function isXhrRequestPending(xhrRequest) {
                    return xhrRequest.readyState !== 4 || xhrRequest.status === 0;
                }

                function isTimerPending(timer) {
                    return timer.hasAttribute('data-pending');
                }

                function isAnimationFramePending(animationFrame) {
                    return animationFrame.hasAttribute('data-pending');
                }

                return !hasPendingAsyncOperation();
            }

            // 返回等待框架稳定的结果
            return waitForFrameworkStability();
        """
        # 等待直到框架稳定
        wait.until(lambda driver: driver.execute_script(wait_for_js_framework_stability))

# 使用示例
if __name__ == "__main__":
    # 初始化 WebDriver
    driver = webdriver.Chrome(service=Service("chromedriver"))
    driver.get("https://your-js-app.com")

    # 创建等待器实例
    waiter = JSFrameworkWaiter(driver)

    # 等待 JS 框架稳定
    waiter.wait_for_js_framework_stability()

    # 在框架稳定后进行其他操作，比如点击某个按钮
    button = WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.ID, "myButton")))
    button.click()

    # 关闭浏览器
    driver.quit()
```

## **注意事项**
- 确保页面上存在 `xhr-request`、`timer` 和 `animation-frame` 的元素，或者根据实际情况修改检查逻辑。
- 可以根据需要调整 `self.timeout` 的值，以适应不同页面的加载速度。
- 在不同的框架或应用中，可能需要根据实际情况对 JavaScript 检查逻辑进行调整，以确保准确判断框架的稳定性。

通过这种方式，你可以有效地等待 JavaScript 框架的稳定，确保测试脚本在执行后续操作时不会遇到未加载完成的元素或数据。