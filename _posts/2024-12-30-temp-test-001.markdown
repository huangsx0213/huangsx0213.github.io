---
layout:     post
title:      "Temp1"
subtitle:   "「 Testing 」" 
date:       2024-12-30 11:00:01
author:     "Vick Huang"
header-img: "img/bg-walle.jpg"
catalog: true
tags:
    - Testing
---
<think>

嗯，用户问的是如何用Selenium的CDP功能来监控一个网址，然后替换服务器返回的cookie。首先，我需要回忆一下之前关于Selenium和CDP的知识。之前用户提到过使用Python的Selenium 4.22版本，所以现在的问题应该在这个环境下解决。

用户的问题分为两个部分：监控一个网址和修改响应中的cookie。监控网址可以通过CDP的Network或者Fetch模块来实现，但替换响应内容需要拦截请求和响应。不过cookie通常是服务器通过Set-Cookie头设置的，所以可能需要修改响应头。

首先，我需要确定如何使用Fetch模块来拦截请求和响应。Fetch模块允许暂停请求和响应，然后修改它们。之前讲过如何用Fetch.enable来启用拦截，并处理requestPaused事件。这个时候需要同时处理请求阶段和响应阶段。

不过，修改响应的cookie可能需要修改响应头中的Set-Cookie字段。这可能需要获取响应后，修改头信息，然后继续响应。但是CDP的Fetch模块是否允许修改响应头呢？需要查一下相关文档或者示例。

另外，用户可能想要在浏览器接收到响应时，替换掉服务器发来的cookie，比如替换成自定义的值。这时候的步骤应该是：

1. 启用Fetch模块，设置拦截模式。
2. 当请求发送到目标URL时，拦截请求。
3. 当响应返回时，拦截响应，修改Set-Cookie头。
4. 放行修改后的响应。

可能需要分别处理请求和响应的暂停事件。例如，在Fetch.requestPaused事件中，判断是请求还是响应阶段。事件参数中有resourceType和requestId，可能需要在响应阶段处理。

但是，具体怎么在响应阶段修改Set-Cookie头呢？例如，在Fetch.fulfillRequest命令中，可以自定义响应头，但需要构造整个响应内容，这可能比较复杂。或者，是否有其他方法可以在不修改整个响应体的情况下只修改头？

或者，是否可以在获取到响应头后，修改其中的Set-Cookie字段，然后继续响应？这可能需要使用Fetch.continueResponse或者类似的方法。

可能还需要注意，修改响应头需要正确计算content-length等字段，但如果是替换现有的cookie值，可能不需要改动内容长度，特别是如果cookie的长度没有变化的话，但实际情况可能更复杂。

这时候可能需要构造一个修改后的响应头，替换掉Set-Cookie的值，然后继续响应。但Fetch模块中的处理可能需要先获取原始响应，修改后再返回。

不过，可能更简单的方式是，在响应阶段捕获该请求，获取响应头，修改Set-Cookie，然后使用Fetch.fulfillRequest来返回一个自定义的响应，包括修改后的头。但这样的话，可能需要重新提供响应体，否则内容会丢失，但如果只是想修改头而不影响内容，可能需要读取原始响应体，然后重新发送。

这可能比较复杂，但有没有更简便的方法？

例如，在Fetch.requestPaused事件中，如果事件的phase是Response阶段，则获取响应头，修改Set-Cookie，然后使用Fetch.continueResponse来继续，并带上修改后的头。但是根据CDP文档，ContinueResponse可能需要提供响应代码和头，这样可能必须处理整个响应。

或者，是否存在另一种方式，例如使用Network模块来监听响应头，然后动态修改，但Network模块可能不允许修改响应头，只能读取。

综上，可能的步骤是：

1. 启用Fetch模块，拦截目标URL的请求。
2. 当请求被暂停时，如果是响应阶段，获取响应头。
3. 修改响应头中的Set-Cookie字段。
4. 使用Fetch.fulfillRequest来发送修改后的头和原始响应体。

但如何获取原始响应体呢？可能需要先获取原始响应，这会导致额外的处理步骤，例如使用Fetch.getResponseBody来获取响应体，然后重新发送。

这个过程可能涉及多个CDP命令，步骤较多，需要注意顺序和异步处理。

现在需要将这些步骤转化为Python代码，使用Selenium的execute_cdp_cmd方法。

同时，用户可能希望监控特定的网址，比如当访问某个URL时，替换其返回的cookie。所以需要设置拦截的URL模式。

例如，使用Fetch.enable时，设置patterns来匹配目标URL，比如{'urlPattern': 'https://example.com/somepath*'}。

然后，在事件处理函数中，判断请求的URL是否符合条件，再进行修改。

另外，修改cookie的时候需要构造正确的Set-Cookie头格式，可能需要了解如何构造该头的值，包括键、值、域名、路径等属性。

比如，原本服务器的响应头可能有Set-Cookie: session=123; Domain=example.com; Path=/，想要替换成session=456，其他属性保持不变。

这时候可能需要解析原始的Set-Cookie头，修改值，再重新组合。

这可能需要用Python的字符串处理或者专门的库，但为了简化示例，可能在代码中直接替换字符串。

现在需要将这些思路整理成代码步骤：

首先，启用Fetch模块，设置拦截模式：

driver.execute_cdp_cmd('Fetch.enable', {
    'patterns': [{'urlPattern': 'https://target-url.com/*', 'requestStage': 'Response'}]
})

这里requestStage设置为Response，表示拦截响应阶段的事件。

然后，添加CDP监听器，处理Fetch.requestPaused事件。

在事件处理函数中，判断事件是否处于响应阶段，如果是，获取requestId，然后获取响应头和响应体。

然后，修改Set-Cookie头，然后使用Fetch.fulfillRequest发送修改后的头和数据。

具体代码可能如下：

def handle_request_paused(event):
    params = event.get('params', {})
    request_id = params.get('requestId')
    resource_type = params.get('resourceType')
    response_headers = params.get('responseHeaders', [])
    
    # 判断是否是目标URL的响应阶段
    if params.get('responseStatusCode') is not None:  # 表示是响应阶段
        # 修改Set-Cookie头
        new_headers = []
        for header in response_headers:
            if header['name'].lower() == 'set-cookie':
                # 替换cookie值，这里假设将原来的值替换为new_cookie_value
                new_value = header['value'].replace('original_value', 'new_cookie_value')
                new_headers.append({'name': 'Set-Cookie', 'value': new_value})
            else:
                new_headers.append(header)
        
        # 获取原始响应体
        body_response = driver.execute_cdp_cmd('Fetch.getResponseBody', {'requestId': request_id})
        body = body_response.get('body', '')
        
        # 构造新的响应
        driver.execute_cdp_cmd('Fetch.fulfillRequest', {
            'requestId': request_id,
            'responseCode': params.get('responseStatusCode', 200),
            'responseHeaders': new_headers,
            'body': body.encode('base64') if body_response.get('base64Encoded') else body
        })

driver.add_cdp_listener('Fetch.requestPaused', handle_request_paused)

不过这里需要注意，Fetch.getResponseBody可能需要处理base64编码的情况，例如，如果body是base64编码的，那么在Fulfill的时候也需要用相同的编码方式。

此外，可能还需要处理跨域或某些安全设置，需要确保在启用Fetch模块时正确配置。

此外，设置requestStage为Response可能需要在Fetch.enable的patterns中指定，例如：

driver.execute_cdp_cmd('Fetch.enable', {
    'patterns': [{
        'urlPattern': 'https://target-url.com/*',
        'requestStage': 'Response'  # 拦截响应阶段
    }]
})

这样，只有响应阶段的事件会被拦截，避免处理请求阶段的事件。

不过，是否允许在响应阶段修改头呢？需要验证这一点，或者是否有其他限制。

另外，如果修改了响应头，尤其是Set-Cookie，需要确保新的cookie格式是正确的，否则浏览器可能无法正确解析，导致cookie不被存储。

可能的测试步骤是，先尝试在代码中替换Set-Cookie头的值，然后查看浏览器中存储的cookie是否变化。

综上，可能需要以下代码结构：

from selenium import webdriver
import base64

driver = webdriver.Chrome()

# 启用 Fetch 并设置拦截响应阶段的请求
driver.execute_cdp_cmd('Fetch.enable', {
    'patterns': [{
        'urlPattern': 'https://example.com/set-cookie-route*',
        'requestStage': 'Response'
    }]
})

def handle_fetch_paused(event):
    params = event.get('params', {})
    request_id = params.get('requestId')
    
    # 仅处理响应阶段的事件
    if 'responseStatusCode' not in params:
        return  # 如果不是响应阶段，直接继续请求
    
    # 获取原始响应头和状态码
    status_code = params['responseStatusCode']
    headers = params.get('responseHeaders', [])
    
    # 修改 Set-Cookie 头
    new_headers = []
    for header in headers:
        if header['name'].lower() == 'set-cookie':
            # 示例：替换 cookie 值，假设原cookie是session=123
            modified_cookie = header['value'].replace('session=123', 'session=modified_456')
            new_headers.append({'name': 'Set-Cookie', 'value': modified_cookie})
        else:
            new_headers.append(header)
    
    # 获取原始响应体
    get_body_response = driver.execute_cdp_cmd('Fetch.getResponseBody', {'requestId': request_id})
    body = get_body_response['body']
    is_base64 = get_body_response.get('base64Encoded', False)
    
    # 使用修改后的头重新构造响应
    fulfill_args = {
        'requestId': request_id,
        'responseCode': status_code,
        'responseHeaders': new_headers,
        'body': body if is_base64 else base64.b64encode(body.encode()).decode()
    }
    
    # 如果是 base64 编码，直接传递，否则需要编码
    if is_base64:
        fulfill_args['body'] = body
    else:
        fulfill_args['body'] = base64.b64encode(body.encode()).decode()
    
    driver.execute_cdp_cmd('Fetch.fulfillRequest', fulfill_args)

driver.add_cdp_listener('Fetch.requestPaused', handle_fetch_paused)

driver.get('https://example.com/set-cookie-route')

# 验证 cookie 是否被修改
cookies = driver.get_cookies()
print(cookies)  # 检查是否有 session=modified_456

driver.quit()

这样，当访问目标URL时，服务器返回的Set-Cookie头会被修改，浏览器将存储修改后的cookie。

但需要注意的是，这种方法需要提前知道目标URL的模式（urlPattern），并且可能需要处理各种情况，例如多个Set-Cookie头，或者没有Set-Cookie头的情况。此外，Fetch.getResponseBody在响应阶段可能已经接收完数据，但如果是大文件可能会有性能问题。

另外，如果原响应是压缩的（如gzip），可能需要解压缩后再处理，但一般情况下浏览器会自动处理，这里可能需要保持原样，避免解压。

可能的错误点包括：未正确处理base64编码的响应体，导致返回的数据损坏；修改后的头格式不正确，导致浏览器无法解析；或者没有正确处理所有响应头，导致某些头丢失。

因此，在实际应用中需要测试和调整代码，确保修改后的响应能够正确被浏览器处理，并且cookie确实被替换。

总结，步骤为：

1. 启用Fetch模块，拦截目标URL的响应。
2. 监听Fetch.requestPaused事件。
3. 在事件处理中，检查是否为响应阶段。
4. 获取响应头和响应体。
5. 修改Set-Cookie头。
6. 使用Fetch.fulfillRequest返回修改后的响应。
</think>

以下是使用 Selenium 4.22 + Python 通过 CDP 监控并替换服务器响应中 Cookie 的完整方案：

---

### **核心思路**
通过 Chrome DevTools Protocol 的 `Fetch` 模块拦截 HTTP 响应，修改 `Set-Cookie` 头后重新注入响应。

---

### **完整代码**
```python
from selenium import webdriver
import base64

# 初始化浏览器
driver = webdriver.Chrome()

# 定义要监控的目标 URL（支持通配符 *）
TARGET_URL = "https://example.com/api/setcookie*"

def modify_cookie_in_response(event):
    params = event.get('params', {})
    request_id = params.get('requestId')
    
    # 仅处理响应阶段
    if 'responseStatusCode' not in params:
        return

    # 获取原始响应信息
    status_code = params['responseStatusCode']
    headers = params.get('responseHeaders', [])
    
    # 修改 Set-Cookie 头
    new_headers = []
    for header in headers:
        if header['name'].lower() == 'set-cookie':
            original_cookie = header['value']
            # 替换 Cookie 示例：将 "session=old_value" 改为 "session=new_value"
            modified_cookie = original_cookie.replace("old_value", "new_value")
            new_headers.append({'name': 'Set-Cookie', 'value': modified_cookie})
        else:
            new_headers.append(header)
    
    # 获取原始响应体
    body_response = driver.execute_cdp_cmd('Fetch.getResponseBody', {'requestId': request_id})
    body = body_response['body']
    is_base64_encoded = body_response.get('base64Encoded', False)

    # 构造新响应
    fulfill_args = {
        'requestId': request_id,
        'responseCode': status_code,
        'responseHeaders': new_headers,
        'body': body if is_base64_encoded else base64.b64encode(body.encode()).decode()
    }

    # 发送修改后的响应
    driver.execute_cdp_cmd('Fetch.fulfillRequest', fulfill_args)

# 启用 Fetch 并监听目标 URL 的响应
driver.execute_cdp_cmd('Fetch.enable', {
    'patterns': [{
        'urlPattern': TARGET_URL,
        'requestStage': 'Response'  # 关键：只拦截响应阶段
    }]
})
driver.add_cdp_listener("Fetch.requestPaused", modify_cookie_in_response)

# 访问测试页面
driver.get("https://example.com/api/setcookie")

# 验证 Cookie 是否被修改
print("修改后的 Cookies:", driver.get_cookies())

driver.quit()
```

---

### **关键步骤说明**
1. **启用 Fetch 模块**：通过 `Fetch.enable` 指定要拦截的 URL 模式和响应阶段 (`requestStage: 'Response'`).
2. **监听响应事件**：通过 `add_cdp_listener` 捕获 `Fetch.requestPaused` 事件.
3. **修改 Cookie**：
   - 遍历响应头找到 `Set-Cookie`
   - 使用字符串替换或正则表达式修改 Cookie 值
   - 保留其他头信息避免破坏响应
4. **重新注入响应**：
   - 通过 `Fetch.getResponseBody` 获取原始响应体
   - 使用 `Fetch.fulfillRequest` 回传修改后的头和原始 body

---

### **注意事项**
- **编码处理**：如果响应体是二进制数据（如图片），需保持 `base64Encoded` 标志与原始响应一致
- **精准匹配**：调整 `urlPattern` 确保只拦截目标请求（如 `*` 匹配任意字符，`?` 匹配单个字符）
- **Cookie 完整性**：修改时需保持 Cookie 属性（如 `Domain`、`Path`、`HttpOnly` 等）
- **性能影响**：频繁拦截大响应体可能导致内存压力

---

### **高级定制**
#### **正则表达式替换 Cookie**
```python
import re

modified_cookie = re.sub(
    r'session=\w+', 
    'session=hacked_value', 
    original_cookie
)
```

#### **多 Cookie 处理**
```python
for header in headers:
    if header['name'].lower() == 'set-cookie':
        cookies = header['value'].split(';')
        modified = [c.replace('old', 'new') for c in cookies]
        new_headers.append({'name': 'Set-Cookie', 'value': ';'.join(modified)})
```

#### **动态 Cookie 生成**
```python
import time
new_cookie = f"session=modified_{int(time.time())}"
```

---

### **验证方法**
1. 浏览器开发者工具检查 Network 面板中的响应头
2. 使用 `driver.get_cookies()` 打印实际存储的 Cookie
3. 在修改逻辑中添加调试输出：
```python
print(f"Original Cookie: {original_cookie}")
print(f"Modified Cookie: {modified_cookie}")
```