---
layout:     post
title:      "基于 Python 和 Robot Framework 的自动化测试框架"
subtitle:   "「 End to End Auto Testing 」" 
date:       2025-03-07 12:00:00
author:     "Vick Huang"
header-img: "img/bg-walle.jpg"
catalog: true
tags:
    - Testing
    - Automated Testing
---

# 自动化测试框架详细说明书

该框架基于 Python 与 Robot Framework 实现，支持多种测试类型（API、Web UI、端到端、性能）。框架采用模块化设计：配置文件统一管理各种参数、公共工具库封装常用函数与中间件、各测试类别的逻辑独立处理用例的加载、执行与验证，最终生成详细的 HTML 报告和日志。


#### 1.1 目录结构示例

```
project_root/
├── configs/
│   ├── api_test_config.yaml      // API测试配置（环境、用例路径、过滤条件等）
│   ├── db_config.yaml            // 数据库连接配置（DEV、UAT等环境）
│   ├── e2e_test_config.yaml      // 端到端测试配置
│   ├── logging_config.yaml       // 日志系统配置
│   ├── saved_fields.yaml         // 保存字段（如 token）管理文件
│   ├── web_pt_config.yaml        // Web性能测试配置
│   └── web_test_config.yaml      // Web UI测试配置
│
├── libraries/
│   ├── api/                      // API测试相关模块
│   │   ├── api_test_keywords.py  // Robot Framework关键词封装：用于在测试用例中调用API操作
│   │   ├── api_test_loader.py    // 解析 Excel 文件，加载 API 测试用例（包含多个Sheet：API、BodyTemplates、Headers、Endpoints 等）
│   │   ├── body_generator.py     // 根据 Body 模板和默认数据生成最终请求体（支持动态值替换）
│   │   ├── headers_generator.py  // 根据 Headers 模板生成请求头，支持变量替换
│   │   ├── request_sender.py     // 封装 requests 请求，发送 HTTP 调用并记录响应详情
│   │   ├── response_handler.py   // 处理与校验接口响应（支持 JSONPath 断言、动态验证、CheckWith逻辑等）
│   │   ├── saved_fields_manager.py // 读写保存字段文件，实现变量自动保存和替换
│   │   └── template_renderer.py  // 利用 Jinja2 模板渲染生成最终 JSON／XML 请求体
│   │
│   ├── common/                   // 公共辅助工具及通用配置
│   │   ├── config_manager.py     // 加载 YAML/JSON 配置文件，提供全局配置读取接口
│   │   ├── log_manager.py        // 日志管理工具（支持多级日志输出、颜色日志、文件写入）
│   │   ├── utility_helpers.py    // 常用工具方法（如格式化 JSON、XML、查找项目根目录等）
│   │   ├── variable_generator.py // 根据占位符生成动态变量（如 UUID、时间戳等）
│   │   └── variable_transformer.py // 对变量进行转换（如日期格式转化、大小写转换等）
│   │
│   ├── db/                       // 数据库操作模块
│   │   ├── db.py                 // SQLAlchemy 基本封装，实现数据库连接、查询、更新、插入、删除
│   │   └── db_operator.py        // 数据库操作接口封装，支持验证数据、数据插入与更新
│   │
│   ├── performance/              // 性能测试相关模块（主要针对 Web 性能测试）
│   │   ├── web_pt.py             // Web性能测试核心逻辑：执行测试、记录响应时间、内存占用等数据
│   │   ├── web_pt_loader.py      // 加载 Web 性能测试 Excel 用例文件（包括 TestCases、TestFunctions、SubFunctions、Locators、CustomActions等）
│   │   ├── web_pt_reporter.py    // 根据测试数据生成图表和统计报表（例如利用 Matplotlib、Chart.js 生成Base64图表嵌入报告）
│   │   └── web_pt_robot_keyword.py // 封装为 RF 关键词，便于在测试套件中调用性能测试操作
│   │
│   ├── robot/                    // 与 Robot Framework 集成相关模块
│   │   ├── case/                 // 用例生成器：将 Excel 测试用例转换为 Robot 测试用例
│   │   │   ├── base_generator.py // 抽象用例生成器接口（定义 load_configuration、initialize_components、create_test_suite、create_test_case、create_test_steps 等方法）
│   │   │   ├── api_generator.py  // 专用于 API 测试用例生成，调用 API 关键词
│   │   │   ├── e2e_generator.py  // 生成端到端 (E2E) 用例（混合调用 Web 和 API 测试步骤）
│   │   │   ├── web_generator.py  // 生成 Web UI 测试用例，将页面对象与操作转换为 Robot Framework 测试步骤
│   │   │   ├── web_pt_robot_generator.py // 生成性能测试用例，封装 Web 性能测试过程
│   │   │   └── unified_generator.py // 根据传入的测试类型（api、web、e2e、performance）获取对应用例生成器
│   │   ├── custom_action_executor.py // 支持执行自定义 Python 代码，为 Web UI 测试扩展自定义操作
│   │   └── robot_test_executor.py   // 核心 Robot 测试执行器，负责调用 WebActions、数据库操作、日志记录、以及处理特殊条件（如 Sanity Check）
│   │
│   ├── web/                      // Web UI 测试相关模块
│   │   ├── webdriver_factory.py  // 根据配置（是否远程、浏览器类型及选项）创建 Selenium WebDriver 实例
│   │   ├── web_actions.py        // 整合所有 Web UI 操作，封装为一个统一的调用接口，内部组合了各种 action 模块
│   │   └── web_test_loader.py    // 加载 Web UI 测试 Excel 用例，并进行数据验证（包含 Locators、PageModules、TestCases、TestSteps、TestData、WebEnvironments、CustomActions、EnvVariables）
│   │       └── web_action/       // Web UI 具体操作封装，每个文件对应一类操作：
│   │             ├── alert_actions.py      // 浏览器 Alert 操作：接收、拒绝、获取文本
│   │             ├── base.py                 // 所有 Web 操作模块基类，提供元素查找、等待封装等
│   │             ├── cookie_actions.py       // 浏览器 Cookie 操作
│   │             ├── decorators.py           // 公共装饰器，如用于记录执行时长等
│   │             ├── element_actions.py      // 基本操作：点击、输入、清除、鼠标悬停（hover）
│   │             ├── javascript_actions.py   // 通过 JavaScript 执行操作，如点击、填充、滚动
│   │             ├── js.py                   // 存放常用 JS 代码片段供 javascript_actions 调用
│   │             ├── navigation_actions.py   // 浏览器导航操作：打开 URL、刷新、后退、前进等
│   │             ├── table_actions.py        // 表格操作：验证表格数据、选择行、分表验证等
│   │             ├── table_verifier.py       // 关于表格的断言验证（支持 exact/partial/regex）
│   │             ├── utils_actions.py        // 辅助功能：截图、元素高亮、日志记录
│   │             ├── verification_actions.py // 页面元素、标题、文本、图形数值等的验证与断言
│   │             ├── wait_actions.py         // 封装 WebDriverWait 操作，等待元素加载、文本出现、元素可点击等
│   │             └── window_actions.py       // 窗口与 frame 切换操作（打开新窗口、切换 frame、关闭窗口）
│
├── templates/                    // 报告、测试总结等模板文件
│   ├── rf_report_template.html   // Robot Framework 测试报告 HTML 模板（包含侧边栏、图表、数据表等）
│   └── test_summary_template.html// 测试总结报告模板
│
├── test_cases/                   // 测试用例文件（一般为 Excel 文件）
│   ├── api_test_cases.xlsx       // API 测试用例
│   ├── web_test_cases.xlsx       // Web UI 测试用例
│   ├── e2e_test_cases.xlsx       // 端到端测试用例
│   └── web_pt_cases.xlsx         // Web 性能测试用例
│
├── main.py                       // 主程序入口（解析命令行参数，根据需要选择执行的测试类型）
└── ...                           // 其它脚本、说明文档等
```

**要点：**
- `configs/` 目录统一管理所有测试所需的 YAML 配置文件。
- `test_cases/` 存放不同类型的 Excel 用例文件，以区分 API、web UI、E2E、性能测试。
- `libraries/` 下分门别类地存放各种功能模块，多数模块都有相应的“加载器”、“执行器”、以及“关键字”封装。
- `templates/` 中的 HTML 模板用来生成更加美观、统计信息丰富的测试报告。

---

### 二、全局配置管理

#### 2.1 配置文件

本框架采用 YAML 文件管理绝大部分配置，常见文件示例：

1. **api_test_config.yaml**
   - `active_environment`: 标记当前测试环境（DEV/UAT/RD）
   - `test_cases_path`: 指定 API 用例 Excel 文件路径
   - `clear_saved_fields_after_test`: 是否在每个测试结束后清空保存字段
   - `tc_id_list` 和 `tags`: 用于筛选执行特定用例或带有某些标签的用例

2. **web_test_config.yaml**
   - `active_environment`: 当前环境
   - `test_cases_path`: 指定 Web UI 测试用例 Excel
   - `tc_id_list`, `tags`: 同上

3. **e2e_test_config.yaml**
   - 端到端测试逻辑的相同配置信息

4. **web_pt_config.yaml**
   - Web 性能测试相关的指定配置，如循环次数、是否远程执行、性能指标阈值等

5. **db_config.yaml**
   - 不同环境下数据库连接配置，包括 oracle、postgresql 等等

#### 2.2 common/config_manager.py

所有测试启动前，都会调用此模块读取对应的 YAML 文件，解析为 Python 字典对象并存储。**好处**：
- 可随时在不同地方读取同一份配置文件，保证数据一致性
- 配合 Robot Framework 的 `BuiltIn().set_global_variable`，可将配置推送成全局变量，如 `${active_environment}`

#### 2.3 logging_config.yaml

决定日志输出格式、级别及目标位置（例如控制台和文件），框架会在启动时加载这个配置，调用 Python 原生 `logging.config.dictConfig`。

---

### 三、main.py 主程序概述

`main.py` 是整个框架的启动入口，通过命令行参数解析来选择执行的测试类型：

- `--api`       (只执行 API 测试)
- `--web`       (只执行 Web UI 测试)
- `--e2e`       (执行端到端，用到 API + Web UI)
- `--performance` (执行 Web 性能测试)

**逻辑简要：**
1. 解析命令行参数，把不同的布尔值（api, web, e2e, performance）存进一个字典。
2. 找到第一个为 True 的测试类型，若都为 False 则默认执行 `e2e`。
3. 调用 `UnifiedRobotCaseGenerator(test_type)` 生成 Robot Framework 测试套件，然后交给 `run_test_suite(suite)` 执行。
4. `run_test_suite` 内部会执行：
   - 将测试结果写入 `report/output.xml`
   - 生成 HTML 报告 `report/report.html` 和 `report/log.html`
   - 生成仪表盘统计信息（通过 DashboardGenerator, SummaryReportGenerator 等）
5. 在测试过程中，若存在带有 `sanity check` 标签的用例失败，会自动跳过后续用例。

---

### 四、整体执行流程（简要概览）

1. **配置加载**： 通过 `ConfigManager.load_yaml` 获取测试环境、测试用例路径等信息
2. **首个初始化**： 在各测试模块（API / Web 等）启动时，设置 `${active_environment}` 并加载数据库、日志等全局工具
3. **用例加载与校验**： 读取 Excel，用 DataFrame 形式存放（pandas），校验每个 Sheet 的完整度
4. **生成测试套件**： 通过 `_generator.py` 文件（如 web_generator.py、api_generator.py 等）动态创建 Robot Framework 测试
5. **执行测试**： 依次调用每个测试用例的关键词（如 `execute_api_test_case` 或 `execute_module`），期间会处理各种动态变量替换、前后置操作
6. **生成报告**： 收集执行过程中的日志与错误信息，调用 Robot Framework 自带的 `ResultWriter` 或自定义模板插入统计图表等。

到此，第一部分主要介绍项目的整体结构与全局配置。下一部分将进入 API 测试模块的详细说明。

---

以下为自动化测试框架说明书的第二部分，重点介绍 API 测试模块的主要流程和 Excel 用例填写要点：

---
## 第二部分：API 测试模块

API 测试模块主要涵盖以下功能：
1. **Excel 用例加载与数据校验**
2. **请求体生成（Body Template + Body Default + Body Override）**
3. **请求头生成（Headers Template）**
4. **请求发送、响应解析、断言验证**
5. **动态值与共享字段管理**
6. **CheckWith、Sanity Check 等特殊标签和跳过逻辑**

下面将分别详述其实现和配置。

---

### 一、配置文件与初始化

框架对 API 测试的所有配置集中放在 `configs/api_test_config.yaml` 中，常用字段示例：

```yaml
active_environment: DEV
test_cases_path: 'test_cases/api_test_cases.xlsx'
clear_saved_fields_after_test: false
# 额外可选字段
tc_id_list:
  - TC001
tags:
  - smoke
```

- **active_environment**：当前激活环境(DEV、SIT、UAT等)，会与 `db_config.yaml`、**Endpoints** 表结合。
- **test_cases_path**：指定 Excel 用例文件路径，如 `test_cases/api_test_cases.xlsx`。
- **clear_saved_fields_after_test**：在每次用例执行完后，是否清空已保存的字段（类似 Token、user_id 等）。
- **tc_id_list** 和 **tags**：可选的过滤器，仅执行指定的用例 ID 或带某些标签的用例。

#### 1.1 初始化流程

1. **加载配置**：
   调用 `load_yaml` 读取 `api_test_config.yaml`，同时载入数据库配置 `db_config.yaml`；
2. **设置全局变量**：
   将 `active_environment` 等值通过 Robot Framework 内部的 `BuiltIn().set_global_variable("${active_environment}", value)` 设为全局；
3. **初始化组件**：
   - 数据库连接初始化（见 `db_operator.py`）
   - `api_test_loader` 解析 Excel 用例表
   - 准备 BodyGenerator、HeadersGenerator、RequestSender、ResponseHandler 等执行核心

只要执行 `APITestKeywords` 或在用例生成时导入 `libraries.api.api_test_keywords`，便会自动做上述初始化。

---

### 二、API Excel 用例结构与加载

本框架约定 `test_cases/api_test_cases.xlsx` 包含以下几个 Sheet：

1. **API**
2. **BodyTemplates**
3. **BodyDefaults**
4. **Headers**
5. **Endpoints**

其中：

- **API (主用例表)**
  存放所有待执行的接口用例信息，一行对应一个用例。
- **BodyTemplates**
  定义请求体模板，可包含 Jinja2 语法。
- **BodyDefaults**
  提供默认数据结构，通常与 BodyTemplates 结合使用。
- **Headers**
  定义可复用的请求头模板（yaml 格式）。
- **Endpoints**
  不同环境（DEV、SIT、UAT等）下接口的 URL 路径和请求方法。

#### 2.1 API Sheet 主要字段说明

| 字段            | 说明                                                         | 示例                                    |
|-----------------|-------------------------------------------------------------|-----------------------------------------|
| **TCID**        | 用例唯一标识                                               | "TC001"                                 |
| **Name**        | 用例名称                                                   | “CreateUserAPI”                         |
| **Descriptions**| 用例详细描述                                               | “验证创建用户的接口（必填字段校验等）”   |
| **Run**         | 是否执行 ("Y"或"N")                                       | “Y”                                     |
| **Suite**       | 用例归属分组                                             | “UserAPI”                               |
| **Tags**        | 逗号分隔的标签列表（可包含 "sanity check"）                  | “critical, sanity check”                |
| **Endpoint**    | 使用的接口名称，对应 Endpoints Sheet 的 Endpoint 字段        | “CreateUser”                            |
| **Body Template** | BodyTemplates 表中的 TemplateName                           | “CreateUserTpl”                         |
| **Body Default**  | BodyDefaults 表中的 Name                                   | “DefaultUserBody”                      |
| **Body Override** | 用于覆盖或补充的 JSON 字符串，可含动态值占位符            | `{"username": "${USER_ID}"}`           |
| **Headers**     | 对应 Headers 中的 HeaderName                               | “AuthHeader”                            |
| **Exp Result**  | 预期结果或断言逻辑（JSONPath 断言、数据库检查等）          | `$.status=200` 或多行                |
| **Save Fields** | 从响应中提取要保存的字段                                   | `assign_value($.token, MyToken)`       |
| **Conditions**  | 预置条件（如 [CheckWith]TC002）或 [TestSetup] / [TestTeardown]   | “\[CheckWith\]TC002,TC003”             |
| **Wait**        | 用例执行完成后等待>0秒                                     | “2”                                    |

**注意**：
- `sanity check`：用例标签中若包含该字符串（不区分大小写），则一旦该用例失败，后续其他用例自动跳过。
- `Run` 为 “Y” 表示该用例会执行，若指定了 `tc_id_list` + `tags` 则只执行符合过滤条件的用例。
- `Exp Result` 支持多行写法，每行可表示一个断言，如：
  ```
  $.result.code=0
  $.data.username=${EXPECTED_USER}
  db_dbname.Table.Column[Filter=a][OrderBy=CreateTime]=ExpectedVal
  ```
- `Conditions` 中常见标记：
  - `[CheckWith]TC002`：执行当前用例前后都会执行 TC002，用于检查数据是否发生预期变化；
  - `[TestSetup]TC003`：把 TC003 当做本用例 Setup
  - `[TestTeardown]TC004`：把 TC004 当 Teardown

---

#### 2.2 BodyTemplates Sheet

| 字段          | 说明                  | 示例                                   |
|---------------|-----------------------|----------------------------------------|
| TemplateName  | 模板名称             | "CreateUserTpl"                        |
| Content       | 模板内容（JSON/XML） | `{ "username": "{{username}}", ... }`  |
| Format        | "json"/"xml"         | "json"                                 |

- **Content** 可使用 Jinja2 语法。
- 若 `Format=json`，表示最终生成 JSON 请求体；若 `Format=xml`，则生成 XML 字符串并设置合适的 Content-Type。

---

#### 2.3 BodyDefaults Sheet

| 字段 | 说明             | 示例                                         |
|------|------------------|----------------------------------------------|
| Name | 默认为一套数据  | "DefaultUserBody"                            |
| Content | JSON 格式存储默认值 | `{ "age": 18, "country": "china"} `    |

- 框架会将 `Body Default` 中的内容和 `Body Override` JSON 合并，用后者覆盖前者的同名字段，再跟 BodyTemplates 进行渲染，得到最终请求体。

---

#### 2.4 Headers Sheet

| 字段       | 说明                            | 示例                                              |
|------------|---------------------------------|---------------------------------------------------|
| HeaderName | 模板名称                        | "AuthHeader"                                      |
| Content    | YAML 格式的 Header 内容         | `Content-Type: application/json\nAuthorization: Bearer ${MyToken}` |

- 支持在 `Content` 中使用 `${VAR_NAME}` 做动态替换，也能用 `{{ placeholder }}` 生成动态值。

---

#### 2.5 Endpoints Sheet

| 字段         | 说明                                                      | 示例                                  |
|--------------|-----------------------------------------------------------|---------------------------------------|
| Environment  | 环境名称(DEV/UAT等)，与 `api_test_config.yaml` 一致       | "DEV"                                  |
| Endpoint     | 接口名称，需与 API Sheet 的 Endpoint 匹配                 | "CreateUser"                           |
| Method       | HTTP 方法 (GET/POST/PUT/DELETE/PATCH)                    | “POST”                                 |
| Path         | URL 路径（可含公共域名或仅是 path，视需求而定）           | "/api/v1/users/create"                |

- 测试时根据 `active_environment` 和给定的 Endpoint 名字，找到所需的 URL + Method；若找不到则会报错。
- 对于完整域名，可以把 Path 写成 `https://dev.xxx.com/api/v1/...`，也能结合通用域名前缀等方式自行扩展。

---

### 三、请求生成与执行

#### 3.1 Body 生成

在执行每个用例时，框架会依次进行：

1. **读取 Body Template**（在 BodyTemplates 中找 TemplateName 匹配）
2. **读 Body Default**（BodyDefaults 根据 Name 匹配）
3. **应用 Body Override**（将 Override 与默认值合并）
4. **渲染模板**： 用 TemplateRenderer（Jinja2）将最终字典数据套进模板 `Content`；
5. **动态值替换**：
   - `{{xxx}}` -> variable_generator.py 生成动态值(如 uuid4、timestamp等)
   - `${VAR_NAME}` -> Robot 全局变量
生成完成后，若 `Format=json` 则会调用 `json.loads` 来得到 dict；若是 `xml` 则保留字符串。

---

#### 3.2 Headers 生成

同理：

1. **通过 HeadersGenerator** 找到 Headers Sheet 中对应的 HeaderName
2. **读取 Content(YAML)** 并解析成字典
3. **替换**：
   - `${VAR_NAME}` -> Robot 全局变量（如 `${MyToken}`）
   - `{{xxx}}` -> variable_generator.py 生成动态值
4. 合并进请求头

---

#### 3.3 请求发送

调用 `request_sender.py` 中的 `send_request(url, method, headers, body, format_type)` 发出 HTTP 请求。
- 若 format_type="json"，则 `requests` 会用 `json=body` 方式；
- 若 format_type="xml"，则 `headers['Content-Type'] = 'application/xml'` 并使用 `data=body`。

捕获错误日志并记录执行时间 `execution_time`。

---

### 四、响应处理与校验

1. **获取响应并解析**
   - 若是 JSON，会自动 `json.loads`；若是 XML，会 `xmltodict.parse` 转成 JSON
2. **Exp Result** 中指定的断言逐行解析
   - `$.status=200` 表示 JSONPath 找到 `status` 字段等于200
   - `db_xxx.table.column[...] = val` 表示数据库断言
   - `TC02.$xxx=+1` 表示动态 Diff 检查（CheckWith 场景），对比前后值是否差1 等
3. **保存字段**
   - 在 `Save Fields` 一列中，如 `assign_value($.token, MyToken)`，会把 JSONPath `$.token` 提取到变量 `MyToken`，并写入 `configs/saved_fields.yaml`
   - 后续用例中如 `Body Override` = `{"Authorization": "Bearer ${MyToken}"}` 就能自动替换

---

### 五、CheckWith 与 Sanity Check

#### 5.1 [CheckWith] 机制

在 `Conditions` 列写 `[CheckWith]TC002` 表示执行该用例前后，都会额外执行一次 TC002：

- **前置检查**：获取初始数据库/接口状态
- **主用例执行**：对被测接口做操作
- **后置检查**：再次运行 TC002，用以对比前后数据差异（比如数量变化）

在断言时可用 `TC002.$response.data.count=+1` 判断该用例执行前后计数差是否符合预期。

#### 5.2 Sanity Check 跳过逻辑

如果某个用例标签中含 `sanity check`，且其执行结果失败，则会在 `end_test` 时设置 `${skip_on_sanity_check_failure}=True`。后续用例在执行时，若检测到此标志，则 `BuiltIn().skip("Skipping...")` 跳过。

---

### 六、Excel 用例示例

**示例：**
假设在 API Sheet 中有记录：

| TCID  | Name          | Suite      | Run | Tags               | Endpoint       | Body Template | Body Default   | Body Override                       | Headers     | Exp Result                 | Save Fields                     | Conditions           | Wait |
|-------|--------------|------------|-----|--------------------|---------------|---------------|---------------|-------------------------------------|------------|---------------------------|----------------------------------|----------------------|------|
| TC001 | Create User   | UserAPI    | Y   | critical           | CreateUser    | CreateUserTpl | DefaultUserBody| {"name": "${USER_NAME}", "age": 30} | AuthHeader | $.status=201<br/>$.id!="" | assign_value($.token,UserToken) | [CheckWith]TC900     | 0    |
| TC002 | Sanity Check  | UserAPI    | Y   | sanity check       | HealthCheck   | HealthTpl     | DefaultHealth  |                                     | BasicHeader| $.status=200             |                                  |                      | 0    |
| TC900 | Check Counts  | UserAPI    | N   |                    | CountUser     | CountTpl      | DefaultCount   |                                     | AuthHeader | $.status=200<br/>         | assign_value($.countCountUsers)  |                      | 0    |

- `TC001`：主用例，创建用户，执行前后都要跑一次 `TC900`；断言 `status=201` 并保存 token 到 `UserToken`。
- `TC002`：一个健康检查接口带 `sanity check` 标签，一旦此用例失败，就跳过其他任何用例。
- `TC900`：用来做 CheckWith 的辅助用例，此处 Run=N，一般不直接执行；用来统计用户数或做校验对比。

**Headers 示例** (Headers Sheet):
| HeaderName | Content                                            |
|------------|----------------------------------------------------|
| AuthHeader | Content-Type: application/json<br/>Authorization: Bearer ${UserToken} |

**Endpoints 示例** (Endpoints Sheet):
| Environment | Endpoint    | Method | Path                           |
|------------|-------------|--------|--------------------------------|
| DEV        | CreateUser  | POST   | https://dev.example.com/api/v1/users/create  |
| DEV        | HealthCheck | GET    | https://dev.example.com/api/v1/health        |
| DEV        | CountUser   | GET    | https://dev.example.com/api/v1/users/count   |

---

### 七、生成与执行

1. **用例生成**： `APIRobotCaseGenerator` 会筛选出 Run=Y 的用例（或符合 `tc_id_list` / `tags`），为其创建 Robot Framework 测试，内部关键步骤如 `execute_api_test_case(TCID)`。
2. **存储逻辑**： 若 `clear_saved_fields_after_test`=true，则每个用例执行完后都会清空 `saved_fields.yaml`。
3. **日志与报告**：
   - 对于请求和响应内容，会记录在 `report/robot_testing.log` 中；
   - 最终生成 `report/output.xml -> report.html/log.html`，并可加 dashboards。

**执行方式**： 
```bash
python main.py --api
```
或直接指定 `--e2e`、`--web`，若优先发现 `--api=True` 则跑 API 测试。

---

**到此结束：** API 测试部分主要介绍了配置文件、Excel 用例组织方式、请求体/头生成与动态变量替换、CheckWith 以及 Sanity Check 特性等。

以下为本自动化测试框架的第三部分说明，重点介绍 **Web UI 测试模块** 的原理、Excel 用例格式以及执行流程。请在阅读前确保已通读前两部分，以便对全局结构和配置有充分了解。

---

## 第三部分：Web UI 测试模块

Web UI 测试通过 Selenium WebDriver 驱动浏览器，根据 Excel 中对页面元素、测试步骤、数据参数的描述动态生成 Robot Framework 测试用例。其核心目标是实现以下功能：
1. **使用 Page Object 模式提升可维护性**
2. **多环境支持**：可在 DEV、SIT、UAT 等不同环境间快速切换
3. **数据驱动**：同一套测试逻辑可结合多组数据重复执行
4. **关键操作自动封装**：点击、输入、滚动、等待、截图、断言等
5. **灵活扩展**：支持自定义操作（CustomActions），可编写自定义 Python 逻辑

下文将详细说明 Web UI 测试的配置文件、Excel 用例结构，以及用例生成与执行过程。

---

### 一、配置文件与初始化

#### 1.1 web_test_config.yaml

与 API 类似，Web 测试配置信息保存在 `configs/web_test_config.yaml`（下列字段仅供参考，实际可根据项目需要调整）：

```yaml
active_environment: SIT
test_cases_path : test_cases/web_test_cases.xlsx
tc_id_list:           # 若要只执行某些用例ID，可在此填写
tags:                 # 若要只执行带某些标签的用例，可在此填写
```

关键字段：
- **active_environment**：指示当前环境，如 SIT、UAT、DEV 等。
- **test_cases_path**：Web 测试用例 Excel 文件位置（默认 `test_cases/web_test_cases.xlsx`）。
- **tc_id_list** / **tags**：和 API 测试类似，用于过滤执行特定用例或附带某些标签的用例。

#### 1.2 Environment 说明

另外，Web 环境中的浏览器设置、远程/本地执行、URL 等信息，一般在 WebEnvironments Sheet（详见后文）内指定。框架在加载时，会结合 `active_environment` 与 WebEnvironments 的配置来创建 WebDriver 实例。

1. **二次初始化**
   - 当 Web 用例正式执行时，会根据 `active_environment` 读取对应配置行内容（如 ChromePath, EdgePath, 是否 headless, 是否远程等）。
   - 通过 `webdriver_factory.py` 选择合适浏览器并启动实例。

2. **全局变量**
   - 同步环境相关参数到 `${active_environment}` 并可能还会设置 `${BASE_URL}`、`${REMOTE_URL}` 等，通过 `BuiltIn().set_global_variable`。

---

### 二、Web UI 测试用例 Excel 结构

默认框架要求 `test_cases_path` 指向的 Excel 文件包含以下几个核心 Sheet：

1. **TestCases** (主测试用例信息)
2. **TestSteps** (详细步骤)
3. **TestData** (数据驱动参数)
4. **Locators** (页面元素定位)
5. **PageModules** (页面与模块逻辑)
6. **WebEnvironments** (多环境配置信息)
7. **CustomActions** (可选，自定义操作扩展)
8. **EnvVariables** (可选，环境相关的额外变量)

下面依次介绍各 Sheet 的目的和字段。

---

#### 2.1 TestCases Sheet

记录 Web 测试用例的基本信息，每一行对应一个用例：

| 字段          | 说明                                         | 示例                                   |
|---------------|----------------------------------------------|----------------------------------------|
| Case ID       | 用例唯一标识                                 | “UITC001”                              |
| Name          | 用例名称                                     | “Login Test”                           |
| Descriptions  | 用例详细描述                                 | “验证用户使用正确凭证能成功登录系统”    |
| Run           | 是否执行 (“Y”/“N”)                           | “Y”                                    |
| Tags          | 标签（逗号分隔），支持 “sanity check”         | “regression, sanity check”             |
| Suite         | 测试所属套件/模块名称(可选)                  | “LoginModule”                          |

**说明：**
- *Case ID*：如 “UITC001”，必须唯一，后续与 `TestSteps`、`TestData` 等关联。
- *Tags*：如果带 “sanity check”，则此用例失败后会跳过后续用例。
- *Run*：如果为 “N”，此用例不生成测试。

---

#### 2.2 TestSteps Sheet

每条记录代表测试用例中的某一步操作。主要字段：

| 字段        | 说明                                                   | 示例                                                     |
|-------------|--------------------------------------------------------|----------------------------------------------------------|
| Case ID     | 与 TestCases 中相同                                   | “UITC001”                                                |
| Step ID     | 步骤序号，决定执行顺序                                 | 1, 2, 3 …                                               |
| Page Name   | 页面名称，对应 PageModules 或 Locators 中的 Page       | “LoginPage”                                              |
| Module Name | 模块名称，对应 PageModules 中的 Module                | “LoginForm”                                              |
| Run         | 是否执行此步骤 (“Y”/“N”)                              | “Y”                                                      |
| 备注        | 可选，说明操作意图                                    | “输入用户名密码，点击登录”                               |

**执行流程**：
- 测试生成时，会依照 Step ID 顺序将每行操作转换为 Robot Framework 关键词调用，如 `execute_module("LoginPage", "LoginForm", data_set)`。
- 若 `Module Name` = “API”，可在 E2E 测试场景里调用 API 逻辑。

---

#### 2.3 TestData Sheet

用于数据驱动测试，一个用例可以有多行数据，每行代表一组参数：

| 字段           | 说明                               | 示例                               |
|----------------|------------------------------------|------------------------------------|
| Case ID        | 与 TestCases 中的 Case ID 一致      | “UITC001”                          |
| Data Set       | 区分同一用例下的多组数据           | “Set1” / “Set2”                    |
| Parameter Name | 在 PageModules 里定义的参数名称     | “username”                          |
| Value          | 实际传入值                         | “testuser1”                        |
| Data Type      | 用于做类型转换（string, int, json等） | “string”                           |

**生成后的结果**：
- 如果某个用例有 2 组数据 (Data Set= “Set1”, “Set2”)，最终会生成 2 个子用例，如 “UITC001.Set1”、“UITC001.Set2”。
- 在执行时，`execute_module` 或自定义关键字会把对应参数注入到操作里。

---

#### 2.4 Locators Sheet

定位页面中每个元素，主要字段：

| 字段         | 说明                                                | 示例                                  |
|--------------|-----------------------------------------------------|---------------------------------------|
| Page Name    | 页面名称，以区分不同页面或组件                       | “LoginPage”                           |
| Element Name | 元素标识，在 PageModules 中引用                      | “username_field”、“login_button”      |
| Locator Type | 定位方法：id、name、xpath、css 等                    | “id”                                  |
| Locator Value| 具体定位表达式                                      | “username” 或 “//button[@id='login']” |
| Description  | 对该元素的说明                                      | “用户名输入框”                         |

**举例**：
```
Page Name | Element Name     | Locator Type | Locator Value            | Description
LoginPage | username_field   | id           | username                | 用户名输入框
LoginPage | password_field   | id           | password                | 密码输入框
LoginPage | login_button     | xpath        | //button[text()='Login']| 登录按钮
```

---

#### 2.5 PageModules Sheet

把页面拆分为多个模块，每个模块包含若干操作。每条记录描述一个操作（或动作）：

| 字段         | 说明                                         | 示例                                                  |
|--------------|----------------------------------------------|-------------------------------------------------------|
| Page Name    | 对应 Locators 中的 Page Name                 | “LoginPage”                                           |
| Module Name  | 模块名称                                     | “LoginForm”                                           |
| Element Name | 此操作涉及的元素名称 (可为空)                | “username_field”                                      |
| Actions      | 具体动作，比如 click、input、verify_text 等    | “click”/“send_keys”/“highlight_element” 等            |
| Parameter Name| 逗号分隔的参数列表                          | “username,password”                                   |
| Highlight    | 是否在执行前高亮元素 ("Y"/"N")              | “Y”                                                   |
| Screenshot   | 是否在执行后截图 ("Y"/"N")                   | “N”                                                   |
| Wait         | 操作完成后等待多少秒                        | “1” 或 “2”，留空表示不等待                           |
| Run          | 是否执行此动作 ("Y"/"N")                     | “Y”                                                   |

**执行过程：**
- 当用例在 TestSteps 中指定 “Page Name=LoginPage”、“Module Name=LoginForm”，框架会查找 PageModules 中相应记录，然后逐行执行 `Actions`。
- `Element Name` 则映射到 Locators 中找真实定位器 `(By.ID, "username")` 等。
- `Parameter Name`：若是 “username”，则从 `TestData` 里读取到具体值。

---

#### 2.6 WebEnvironments Sheet

框架支持多环境切换，配置示例：

| 字段         | 说明                                      | 示例                                     |
|--------------|-------------------------------------------|------------------------------------------|
| Environment  | 环境名称 (DEV, SIT, UAT, PROD 等)         | “SIT”                                    |
| TargetURL    | 测试页面基 URL                           | “https://sit.example.com”               |
| Rounds       | 若结合性能场景可用，多次执行次数（可选）   | “5”                                      |
| LogDetails   | 是否详细记录调试信息 (“Y”/“N”)             | “Y”                                      |
| Browser      | 浏览器类型 (“chrome”/“edge”)              | “chrome”                                 |
| IsRemote     | 是否远程 (“True”/“False”)                 | “False”                                  |
| RemoteURL    | 远程地址（IsRemote=True时必填）           | “http://127.0.0.1:4444/wd/hub”           |
| ChromePath   | 本地 Chrome 浏览器可执行文件路径           | “C:\Program Files\Google\Chrome\...”     |
| ChromeDriverPath | ChromeDriver 路径                     | “C:\Drivers\chromedriver.exe”            |
| EdgePath     | Edge 浏览器可执行文件路径                 |                                          |
| EdgeDriverPath| EdgeDriver 路径                          |                                          |
| BrowserOptions| 各种启动参数，以 JSON 字符串表示         | `{"headless": true, "window-size": "1920,1080"}` |

执行前，脚本会根据 `active_environment` 找到对应行，从而确定浏览器类型、本地或远程模式等。

---

#### 2.7 CustomActions Sheet（可选）

当内建的操作不足以满足需求时，可在 `CustomActions` 表中编写自定义 Python 逻辑。字段示例：

| 字段        | 说明                                  | 示例                                                                                                  |
|-------------|---------------------------------------|-------------------------------------------------------------------------------------------------------|
| Action Name | 自定义操作名称，在 PageModules 或 TestSteps 中调用 | “CustomScroll”                                                                                         |
| Description | 对操作的简单描述                      | “页面滚动到底部”                                                                                       |
| Python Code | 实际 Python 代码，需要定义 execute 函数 | `def execute(element, web_actions, *args, **kwargs):\n    web_actions.execute_script("window.scrollTo(0, document.body.scrollHeight)")` |

**执行时**会调用 `custom_action_executor.py`，它会将 Python Code 动态解析、执行，进而实现自定义逻辑。

---

### 三、用例生成与执行过程

1. **加载Excel**：
   （在 `web_test_loader.py`）读取 TestCases、TestSteps、TestData、Locators、PageModules、WebEnvironments 等，校验引用关系、Run=“Y”标识等。
2. **过滤用例**：
   根据 `tc_id_list` 和 `tags` 筛选要执行的用例，如只执行标记为 “regression” 的测试。
3. **创建测试套件**：
   `WebRobotCaseGenerator`（或 E2E 场景则是 `E2ERobotCaseGenerator`）把筛选出的用例分组到 Robot Framework Suite 里，每个用例再根据 TestData 生成多个子用例。
4. **生成关键步骤**：
   对每个用例的 TestSteps，各步骤调用 `execute_module(PageName, ModuleName, data_set)`。
   - `execute_module` 内部查询 PageModules 中该模块所有 `Run=Y` 的动作顺序，并根据 `Element Name` 找到 Locators。
   - 执行 `Highlight`、`Screenshot`、`Wait`、`Actions` 等逻辑，若需要参数就从 data_set 里获取。
5. **启动 WebDriver**：
   - 根据 WebEnvironments 里对应行创建浏览器实例（Chrome/Edge/本地或远程），加载 URL 并开始执行步骤。
   - 在执行完后 `suite.teardown` 会调用 `close_browser`。
6. **断言与日志**：
   - 对元素可见性、文本内容、标题、等待消失、表格检验等都可以调用 `VerificationActions` 中的方法；
   - 如果发生异常，会记录日志并在 Robot Framework 报告中显示。
7. **生成报告**：
   与 API 一样，执行完后得到 `report.html`、`log.html`，并可查看每一步截屏或高亮等。

---

### 四、常见示例

**Example**：以“登录测试”为例

- `TestCases`：

| Case ID  | Name                | Descriptions             | Run | Tags             | Suite         |
|----------|---------------------|--------------------------|-----|------------------|---------------|
| UITC001  | Login Test (Valid )| 测试合法账号登录成功     | Y   | regression, login | LoginModule   |

- `TestSteps`：

| Case ID | Step ID | Page Name  | Module Name | Run | 备注              |
|---------|--------|------------|------------|-----|-------------------|
| UITC001 | 1      | LoginPage  | LoginForm  | Y   | 输入用户名和密码  |
| UITC001 | 2      | LoginPage  | ClickLogin | Y   | 点击登录按钮      |

- `TestData`：

| Case ID | Data Set | Parameter Name | Value      | Data Type |
|---------|---------|----------------|------------|----------|
| UITC001 | Set1     | username       | testuser1  | string   |
| UITC001 | Set1     | password       | 123456     | string   |
| UITC001 | Set2     | username       | testuser2  | string   |
| UITC001 | Set2     | password       | abcdef     | string   |

- `Locators`：

| Page Name | Element Name     | Locator Type | Locator Value         | Description        |
|-----------|------------------|-------------|-----------------------|--------------------|
| LoginPage | username_field   | id          | username             | 用户名输入框       |
| LoginPage | password_field   | id          | password             | 密码输入框         |
| LoginPage | login_button     | xpath       | //button[@id='login']| 登录按钮           |

- `PageModules`：

| Page Name | Module Name | Element Name     | Actions    | Parameter Name    | Highlight | Screenshot | Wait | Run |
|-----------|------------|------------------|-----------|-------------------|-----------|-----------|------|-----|
| LoginPage | LoginForm  | username_field   | send_keys | username         | Y         | N         | 0    | Y   |
| LoginPage | LoginForm  | password_field   | send_keys | password         | Y         | N         | 0    | Y   |
| LoginPage | ClickLogin | login_button     | click     |                  | Y         | Y         | 1    | Y   |

**执行效果**：
1. 生成由 `UITC001` 用例，结合 `Set1`、`Set2` 两组数据 -> “UITC001.Set1”，“UITC001.Set2”。
2. 在“UITC001.Set1”里，会先以 username=testuser1, password=123456， 调用 `send_keys(username_field, "testuser1")`、`send_keys(password_field, "123456")`，再 `click(login_button)`。
3. 如果 `Highlight=Y`，执行时元素会闪烁显示；若 `Screenshot=Y`，则自动在日志中插入截图。
4. 等待 1 秒 (`Wait=1`) 后再进行下一步或结束。

---

### 五、运行方式与日志报告

- 通过命令 `python main.py --web` 启动 Web 测试。如包含 `--api` / `--e2e` / `--performance` 参数，则分别执行另外的流程。
- 测试结果将输出至 `report/` 文件夹：
  - `report.html`、`log.html`：Robot Framework 的详细报告与执行日志；
  - `robot_testing.log`：按照 `logging_config.yaml` 定义的日志文件，记录所有操作。
- 若用例带有 “sanity check” 标签并失败，会跳过其他用例；若想只执行部分用例，可指定 `--api` 或 `--web` 并在 config 中设置 `tc_id_list` 或 `tags`。

---

### 六、注意与扩展

1. **页面元素更新**：项目迭代时，如果 ID、xpath 等定位器改变，需要及时维护 Locators 与 PageModules，以免定位失败。
2. **数据驱动**：使用 TestData 可大幅减少重复编辑，建议采用多个 `Data Set` 提升测试覆盖。
3. **自定义操作**：通过 CustomActions Sheet 与 `custom_action_executor.py`，可以定义任何 Python 逻辑，比如复杂 JS 注入、文件上传下载、或多步骤操作封装。
4. **断言**：常见断言在 `verification_actions.py`，包含 text校验、element可见性、是否选中等；也可写自定义断言。
5. **环境选择**：若在 WebEnvironments 中定义多个环境（DEV/SIT等），修改 `web_test_config.yaml` 的 `active_environment` 即可快速切换浏览器设置和 Url。

---

综上，第三部分主要阐述了 Web UI 测试模块如何通过 Excel 用例进行页面元素定位、步骤执行与数据驱动，并结合多环境与自定义操作机制达成高效的 Web UI 自动化测试。下一部分将介绍 **E2E 测试**（API + Web 结合）或 **性能测试** 的详细内容。


以下为本自动化测试框架的 **第四部分说明**，介绍如何在同一套框架下集成并执行**性能测试**（Performance Testing）。将重点阐述整体设计思路、配置文件、脚本编写方法及执行流程。与前几部分一样，性能测试也可通过命令行或配置文件实现一键式启动。

---

## 第四部分：性能测试模块

本框架的性能测试基于第三方负载工具（如 **Locust**、**JMeter**、**K6** 等）进行封装，从而统一管理**性能场景配置**、**数据驱动**、**环境切换**和**结果收集**。主要目标包括：

1. **自动加载场景配置**：通过 YAML 或 Excel 对并发用户数、启动时长、运行时间等进行参数化。
2. **数据驱动**：结合已有的 `TestData` 或单独编写性能测试专用数据文件，如账号池、测试样本等。
3. **一键执行**：可由 `python main.py --performance` 或集成到 CI 来统一调度。
4. **结果可视化**：通过内置的 HTML 报告或外接 Grafana、influxDB 等进行性能指标监控。

---

### 一、配置文件与初始化

#### 1.1 `performance_test_config.yaml`

与 API/UI 测试类似，性能测试的主要配置集中在 `configs/performance_test_config.yaml`，示例内容如下：

```yaml
tool: locust
active_environment: SIT
test_cases_path: 'test_cases/performance_test_cases.xlsx'
locust_options:
  host: 'https://sit.example.com'
  users: 50
  spawn_rate: 5
  run_time: '10m'
  headless: true
  loglevel: INFO
```

常见字段：

- **tool**：指定使用的负载工具，如 `locust`、`jmeter`、`k6` 等，本框架当前主要集成 Locust，其他工具可扩展。
- **active_environment**：与 API/Web 测试共用同一个环境标识，用于切换不同环境的 URL、账号等。
- **test_cases_path**：性能测试用例文件（如 `test_cases/performance_test_cases.xlsx`），若需数据驱动可在同一 Excel 里或独立 CSV 文件存储数据。
- **locust_options**：Locust 相关的启动参数：
  - `host`：目标环境地址
  - `users`：并发用户数上限
  - `spawn_rate`：每秒启动多少个虚拟用户
  - `run_time`：测试持续时长（如10分钟）
  - `headless`：是否在无UI模式下执行
  - `loglevel`：日志级别等

> 注：如果采用 **JMeter** 或 **K6**，可在配置文件中定义对应的参数，如 JMeter 的 `thread_num`、`ramp_up_time` 等。

#### 1.2 初始化流程

1. **加载配置**：
   - 读取并解析 `performance_test_config.yaml`；
   - 根据 `tool` 判断使用何种负载工具；
2. **设置全局变量**：
   - 将 `active_environment`、`locust_options` 等注入 Robot Framework（如果跟其他部分在同一进程中）。
3. **数据准备**：
   - 如果有性能测试专用的账号池、请求参数等，需要提前准备或在 `PerformanceTestLoader` 中读取 Excel/CSV 进行初始化。
4. **启动**：
   - 若使用 Locust 分布式执行，会在 Master/Worker 上分别加载配置；也可单机模式下直接运行。

---

### 二、性能测试用例（Scenarios）

与 API 只需编写一组业务接口用例不同，性能测试往往需要**定义多个场景（Scenario）**，每个场景包含**不同的请求组合、权重、思维等待时间**等。为此可以采用以下两种组织方式：

1. **在 Excel 中专门新增 `PerformanceScenarios` Sheet**：
   - 定义每个场景的名称、接口列表、执行顺序、请求体等；
   - 在 Locust 脚本中动态解析后生成 tasks。

2. **直接在 Python/Locust 脚本中编写**：
   - 通过继承 `locust.HttpUser`, `task` 装饰器的方式实现业务流；
   - Excel/CSV 仅用于管理测试数据（账号、参数）。

本框架支持第一种更“低代码化”的方式，也允许在 Python 中灵活编写复杂场景。下面介绍如何在 Excel 中配置场景。

---

#### 2.1 `PerformanceScenarios` Sheet (可选)

| 字段           | 说明                                               | 示例                                          |
|----------------|----------------------------------------------------|-----------------------------------------------|
| Scenario Name  | 场景名称                                           | “UserRegistrationLoadTest”                    |
| Weight         | 该场景在全部场景中的权重（Locust 用于随机调度）      | 2                                             |
| Step Index     | 场景步骤序号                                       | 1, 2, 3…                                      |
| API Endpoint   | 对应前面已有的 API Endpoint 名或完整 URL           | “CreateUser” / “https://sit.example.com/api”  |
| HTTP Method    | GET/POST/PUT/DELETE 等                             | “POST”                                        |
| Body Template  | 如需发送请求体可指定（与 API 测试部分类似）         | “CreateUserTpl”                               |
| Headers        | 请求头（可简写或引用 YAML）                         | “AuthHeader”                                  |
| Think Time     | 思考时间（秒），每步操作后等待多少秒（Locust中概念） | “1”                                           |
| Notes          | 备注                                               | “注册接口并记录响应耗时”                       |

> 注：在 Locust 脚本解析时，会根据 “Scenario Name” 分组，并结合“Weight” 来设置场景分发。对于每个场景的步骤（Step Index）依次调用相应 API Endpoint 或 URL，并可在之间执行随机或固定的思考等待。

---

#### 2.2 账号/数据池 (可选)

如果需要大量不同账号或参数，可将其存储在 Excel 其它 Sheet 或单独 CSV 文件：

- **Accounts** Sheet： columns = `username`, `password`, `other_info`…
- 脚本启动时读取 -> 存入列表 -> 用迭代或随机取下一个账号 -> 执行场景请求。

---

### 三、基于 Locust 的实现示例

本框架的示例集成 **Locust** 作为负载工具，核心文件一般包括：

- `performance_test_launcher.py`：读取 `performance_test_config.yaml`，解析 Excel 的 `PerformanceScenarios`，并生成 `locustfile.py` 或以动态方式直接启动 Locust。
- `locustfile.py`：定义 `LocustUser` 类，用 tasks 实现对场景请求的访问。
- `performance_data_loader.py`：封装读取账号池、BodyTemplates、Headers 逻辑，以便 Locust 脚本中使用。

**关键步骤**：

1. **获取 locust_options**：并发用户数、运行时长、host 等。
2. **解析 PerformanceScenarios**：把相同 `Scenario Name` 的行组成一个 task 集合，为每个 step 记录 `HTTP Method`、`URL`、`Body`、`Headers`、`Think Time`。
3. **动态 or 静态生成 locustfile**：
   - 动态：在 Python 运行时构造一个字符串或类对象并传给 LocustRunner；
   - 静态：提前写好 `locustfile.py` 模板，通过 Jinja2 之类的方式把场景插入。
4. **启动 Locust**：
   - 在本地可 `locust -f locustfile.py --users 50 --spawn-rate 5 --run-time 10m --headless`；
   - 或在分布式环境下启动 Master/Worker。
5. **收集结果**：
   - Locust 会在终端输出 RPS(请求率)、响应时间分布、失败率等；也能通过 WebUI 或导出 CSV。
   - 如需整合至 Robot Framework 报告，可将关键指标写回到 `output.xml` 自定义标签中，也可在 `report/` 目录保存统计。

---

### 四、执行与整合

1. **命令行执行**：
   ```bash
   python main.py --performance
   ```
   脚本会检查 `performance_test_config.yaml`，根据 `tool` 判断是 Locust 还是其他工具，再调用对应流程。
2. **与 API/Web/E2E 互不干扰**：
   - 若只加 `--performance`，则只跑性能测试；
   - 也可加 `--api` 或 `--web` 实现在同一轮 CI 里先功能测试，再性能测试；
   - 如果要在同一个 pipeline 中先执行集成测试，后执行性能测试，可以通过配置多阶段或多个 `main.py` 命令分步骤进行。
3. **报告查看**：
   - Locust 自带 WebUI (http://localhost:8089) 可在运行时查看统计；若 `--headless` 则自动输出汇总到终端；
   - 若需要本框架统一管理报告，可在 `performance_test_launcher.py` 中收集结果写入 `report/performance_result.json` 或 `report/performance_summary.html`。

---

### 五、扩展与注意事项

1. **高级用法（分布式、多场景调度）**：Locust、JMeter 均支持分布式集群，需在脚本中配置 Master/Worker 节点的 IP、端口等。
2. **资源监控**：性能测试往往需要监控服务器 CPU、内存、网络带宽等，可配合 Grafana + InfluxDB/Prometheus 方案进行实时统计。
3. **数据准备**：在大并发下，API 需要足量的账号或测试数据，如订单号、ID 等，否则可能导致并发时互相影响（如重复注册）。要提前考虑数据清理和重复使用策略。
4. **断言**：性能脚本中通常也建议添加基础断言（响应码是否 200、响应体字段是否正确），否则只测吞吐量，缺乏正确性判断可能导致误判。
5. **与功能测试共享逻辑**：如在 `BodyTemplates`、`Headers`、`Endpoints` 中已有配置，可直接复用 API 测试部分生成请求，从而减少重复编写。

---

## 小结

本部分主要介绍了如何将 **性能测试** 集成到同一自动化框架中。通过配置 `performance_test_config.yaml`、定义 `PerformanceScenarios` 或自定义脚本，即可使用 **Locust**（或其他负载工具）进行大规模并发测试，辅以统一的环境切换、数据驱动和日志/报告管理。至此，整个框架已经涵盖了从 **API**、**Web** 到 **性能** 的多层次自动化测试能力。如果需要 **E2E** 测试场景或其他专项（安全、可用性…），也可按照类似方法进行扩展。


