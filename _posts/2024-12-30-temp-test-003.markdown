---
layout:     post
title:      "Temp3"
subtitle:   "「 Testing 」" 
date:       2024-12-30 11:00:03
author:     "Vick Huang"
header-img: "img/bg-walle.jpg"
catalog: true
tags:
    - Testing
---



由于篇幅所限，完整内容将分为上下篇展示。以下是**上篇**内容，包含方案概述、系统架构、以及部分核心代码设计。

---

# Web 客户端性能测试自动化方案（上篇）

---

## 1. 方案概述

### 1.1 背景

在现代 Web 应用性能测试中，不仅需要衡量页面加载时间、按钮点击响应时间等功能点的表现，还需要监控 JavaScript 内存使用情况，以检测潜在的内存泄漏或其他性能问题。本方案旨在提供一个全面的 Web 客户端性能测试自动化解决方案。

### 1.2 目标

1. 实现模块化的测试框架，支持功能点的动态扩展和管理。
2. 集成 JavaScript 内存监控功能，记录每轮测试的内存使用情况。
3. 提供自动化的测试执行和结果分析功能。
4. 生成包含统计数据和可视化图表的综合性能报告。

### 1.3 技术栈

- Python
- Selenium WebDriver
- Robot Framework
- pandas (数据分析)
- matplotlib (图表生成)

---

## 2. 系统架构

### 2.1 模块组成

1. **`base_function.py`**：功能点抽象基类，定义标准测试接口。
2. **`performance_tester.py`**：核心测试管理类，负责测试执行与数据处理。
3. **`robot_framework_wrapper.py`**：封装测试管理类，便于与 Robot Framework 集成。
4. **`test_functions.py`**：功能点实现模块，定义具体操作。
5. **`web_performance_test.robot`**：Robot Framework 测试用例文件。

### 2.2 工作流程

1. **初始化测试环境**。
2. **动态注册功能点**：通过模块名与类名动态加载测试功能点。
3. **执行测试循环**：
   - 执行操作前记录 JS 内存使用情况。
   - 执行功能点测试并记录响应时间。
4. **数据记录与保存**：测试结果写入 JSON 文件。
5. **生成报告**：统计数据并生成包含图表的 HTML 报告。

---

## 3. 详细设计

### 3.1 功能点抽象基类 (`base_function.py`)

功能点抽象基类定义了标准接口，包含以下方法：
- **`precondition()`**：测试前准备操作。
- **`measure_operation()`**：执行核心测试操作。
- **`postcondition()`**：测试后清理操作。

#### 代码实现

```python
from abc import ABC, abstractmethod
import time

class TestFunctionBase(ABC):
    def __init__(self, tester):
        self.tester = tester

    @abstractmethod
    def precondition(self):
        pass

    @abstractmethod
    def measure_operation(self):
        pass

    @abstractmethod
    def postcondition(self):
        pass

    def run(self):
        try:
            self.precondition()
            start_time = time.time()
            self.measure_operation()
            end_time = time.time()
            response_time = end_time - start_time
            self.postcondition()
            return response_time
        except Exception as e:
            print(f"Error in {self.__class__.__name__}: {e}")
            return None
```

---

### 3.2 核心测试管理类 (`performance_tester.py`)

核心测试管理类负责管理测试过程，包括 WebDriver 的初始化与退出、功能点的动态加载、测试数据的记录与分析。

#### 核心功能

- **动态加载功能点**：通过模块名与类名加载功能点类。
- **捕获 JavaScript 内存**：通过 Selenium 执行脚本获取 `performance.memory` 数据。
- **测试执行与数据记录**：循环测试并记录响应时间和内存使用情况。

#### 代码实现

```python
import importlib
import inspect
import json
from selenium import webdriver
from base_function import TestFunctionBase
import pandas as pd
import matplotlib.pyplot as plt
from io import BytesIO
import base64

class WebPerformanceTester:
    def __init__(self, driver_path, target_url, rounds=5):
        self.driver = webdriver.Chrome(executable_path=driver_path)
        self.target_url = target_url
        self.rounds = rounds
        self.data = []
        self.function_points = []

    def get_js_memory(self):
        try:
            js_memory = self.driver.execute_script("return window.performance.memory;")
            if js_memory:
                used_js_memory_mb = js_memory.get("usedJSHeapSize", 0) / (1024 * 1024)
                total_js_memory_mb = js_memory.get("totalJSHeapSize", 0) / (1024 * 1024)
                return round(used_js_memory_mb, 2), round(total_js_memory_mb, 2)
        except Exception as e:
            print(f"Error in get_js_memory: {e}")
        return None, None

    def _get_class_from_module(self, module_name, class_name):
        module = importlib.import_module(module_name)
        for name, obj in inspect.getmembers(module, inspect.isclass):
            if name == class_name and issubclass(obj, TestFunctionBase) and obj is not TestFunctionBase:
                return obj
        raise ValueError(f"Class '{class_name}' not found in module '{module_name}'")

    def register_test_function(self, module_name, class_name):
        func_class = self._get_class_from_module(module_name, class_name)
        self.function_points.append(func_class(self))
        print(f"{class_name} from module '{module_name}' registered successfully.")

    def execute_tests(self):
        for round_num in range(self.rounds):
            self.driver.get(self.target_url)
            round_start_js_memory = self.get_js_memory()
            if round_start_js_memory:
                print(f"Round {round_num + 1} - JS Memory at Start: Used {round_start_js_memory[0]} MB, Total {round_start_js_memory[1]} MB")

            for func in self.function_points:
                response_time = func.run()
                self.data.append({
                    "round": round_num + 1,
                    "function_point": func.__class__.__name__,
                    "round_start_js_memory": {
                        "used_MB": round_start_js_memory[0] if round_start_js_memory else None,
                        "total_MB": round_start_js_memory[1] if round_start_js_memory else None
                    },
                    "response_time": response_time
                })
                print(f"Round {round_num + 1} - {func.__class__.__name__} - Response Time: {response_time} seconds")

    def save_data(self, file_name="test_data.json"):
        with open(file_name, "w") as f:
            json.dump(self.data, f, indent=4)
        print(f"Test data saved to {file_name}")

    def analyze_data(self):
        df = pd.DataFrame(self.data)
        
        time_stats = df.groupby('function_point')['response_time'].agg(['mean', 'median', 'max'])
        
        memory_stats = df.groupby('function_point').apply(lambda x: pd.Series({
            'mean_used_MB': x['round_start_js_memory'].apply(lambda y: y['used_MB']).mean(),
            'mean_total_MB': x['round_start_js_memory'].apply(lambda y: y['total_MB']).mean()
        }))
        
        plt.figure(figsize=(12, 6))
        for func in df['function_point'].unique():
            func_data = df[df['function_point'] == func]
            plt.plot(func_data['round'], func_data['response_time'], label=func)
        
        plt.xlabel('Round')
        plt.ylabel('Response Time (s)')
        plt.title('Response Time Trend')
        plt.legend()
        
        buffer = BytesIO()
        plt.savefig(buffer, format='png')
        buffer.seek(0)
        time_image_base64 = base64.b64encode(buffer.getvalue()).decode('utf-8')
        plt.close()

        plt.figure(figsize=(12, 6))
        for func in df['function_point'].unique():
            func_data = df[df['function_point'] == func]
            plt.plot(func_data['round'], func_data['round_start_js_memory'].apply(lambda x: x['used_MB']), label=f"{func} (Used)")
            plt.plot(func_data['round'], func_data['round_start_js_memory'].apply(lambda x: x['total_MB']), label=f"{func} (Total)")
        
        plt.xlabel('Round')
        plt.ylabel('Memory (MB)')
        plt.title('JavaScript Memory Usage Trend')
        plt.legend()
        
        buffer = BytesIO()
        plt.savefig(buffer, format='png')
        buffer.seek(0)
        memory_image_base64 = base64.b64encode(buffer.getvalue()).decode('utf-8')
        plt.close()

        return time_stats, memory_stats, time_image_base64, memory_image_base64

    def save_analysis_report(self, file_name="performance_report.html"):
        time_stats, memory_stats, time_image_base64, memory_image_base64 = self.analyze_data()
        
        html_content = f"""
        <html>
        <head>
            <title>Web Performance Test Report</title>
            <style>
                body {{ font-family: Arial, sans-serif; }}
                table {{ border-collapse: collapse; width: 100%; }}
                th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
                th {{ background-color: #f2f2f2; }}
            </style>
        </head>
        <body>
            <h1>Web Performance Test Report</h1>
            <h2>Response Time Statistics</h2>
            {time_stats.to_html(classes='stats')}
            <h2>JavaScript Memory Usage Statistics</h2>
            {memory_stats.to_html(classes='stats')}
            <h2>Response Time Trend</h2>
            <img src="data:image/png;base64,{time_image_base64}" alt="Response Time Trend">
            <h2>JavaScript Memory Usage Trend</h2>
            <img src="data:image/png;base64,{memory_image_base64}" alt="Memory Usage Trend">
        </body>
        </html>
        """
        with open(file_name, "w") as f:
            f.write(html_content)
        print(f"Analysis report saved to {file_name}")

    def quit_driver(self):
        self.driver.quit()
```

---

**下篇**将包含功能点实现模块 (`test_functions.py`)、Robot Framework 集成封装类、测试用例文件及完整实施步骤和结论。


# Web 客户端性能测试自动化方案（下篇）

## 3. 详细设计（续）

### 3.3 Robot Framework 集成封装类 (`robot_framework_wrapper.py`)

为了方便与 Robot Framework 集成，`robot_framework_wrapper.py` 封装了核心测试管理类。通过提供一组关键字接口，用户可以在 Robot Framework 测试用例中直接调用这些方法。

#### 核心功能
1. **初始化测试**：创建测试管理类实例，并加载目标 URL。
2. **动态注册功能点**：通过模块名和类名动态加载功能点。
3. **执行测试**：调用核心类的测试执行方法进行多轮测试。
4. **保存测试结果与报告**：保存测试数据至文件，并生成性能报告。
5. **释放资源**：关闭 WebDriver。

#### 代码实现
```python
from performance_tester import WebPerformanceTester

class RobotFrameworkWebTester:
    def __init__(self):
        self.tester = None

    def initialize_tester(self, driver_path, target_url, rounds=5):
        """
        初始化测试管理类。
        """
        self.tester = WebPerformanceTester(driver_path, target_url, int(rounds))
        print("WebPerformanceTester initialized.")

    def register_test_function(self, module_name, class_name):
        """
        动态注册测试功能点。
        """
        if self.tester:
            self.tester.register_test_function(module_name, class_name)

    def execute_tests(self):
        """
        执行测试。
        """
        if self.tester:
            self.tester.execute_tests()

    def save_test_results(self, file_name="test_data.json"):
        """
        保存测试结果到 JSON 文件。
        """
        if self.tester:
            self.tester.save_data(file_name)

    def save_analysis_report(self, file_name="performance_report.html"):
        """
        保存性能报告到 HTML 文件。
        """
        if self.tester:
            self.tester.save_analysis_report(file_name)

    def quit_tester(self):
        """
        释放资源，关闭 WebDriver。
        """
        if self.tester:
            self.tester.quit_driver()
```

---

### 3.4 功能点实现模块 (`test_functions.py`)

`test_functions.py` 定义了具体的测试功能点。每个功能点实现了基类中的通用方法 `precondition()`、`measure_operation()` 和 `postcondition()`。

#### 示例功能点设计
以下以两个功能点为例：
1. **TestFunction1**：点击功能按钮。
2. **TestFunction2**：输入文本并提交。

#### 代码实现
```python
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from base_function import TestFunctionBase

class TestFunction1(TestFunctionBase):
    def precondition(self):
        """
        等待功能按钮加载完成。
        """
        WebDriverWait(self.tester.driver, 10).until(
            EC.presence_of_element_located((By.ID, "function1"))
        )

    def measure_operation(self):
        """
        点击功能按钮。
        """
        WebDriverWait(self.tester.driver, 10).until(
            EC.element_to_be_clickable((By.ID, "function1"))
        ).click()

    def postcondition(self):
        """
        功能点无后置清理操作。
        """
        pass

class TestFunction2(TestFunctionBase):
    def precondition(self):
        """
        等待输入框加载完成。
        """
        WebDriverWait(self.tester.driver, 10).until(
            EC.presence_of_element_located((By.ID, "function2"))
        )

    def measure_operation(self):
        """
        向输入框中输入文本并点击提交按钮。
        """
        input_field = WebDriverWait(self.tester.driver, 10).until(
            EC.presence_of_element_located((By.ID, "function2"))
        )
        input_field.send_keys("测试文本")
        WebDriverWait(self.tester.driver, 10).until(
            EC.element_to_be_clickable((By.ID, "submit2"))
        ).click()

    def postcondition(self):
        """
        清空输入框内容。
        """
        input_field = self.tester.driver.find_element(By.ID, "function2")
        input_field.clear()
```

---

### 3.5 Robot Framework 测试用例 (`web_performance_test.robot`)

在 Robot Framework 中，用户可以通过测试用例直接调用封装的关键字接口，完成性能测试的执行与报告生成。

#### 测试用例示例
```robot
*** Settings ***
Library           robot_framework_wrapper.py

*** Variables ***
${CHROME_DRIVER_PATH}    /path/to/chromedriver
${TARGET_URL}            https://example.com
${ROUNDS}               5
${RESULT_FILE}          test_data.json
${REPORT_FILE}          performance_report.html
${MODULE_NAME}          test_functions

*** Test Cases ***
Web 客户端性能测试
    Initialize Tester    ${CHROME_DRIVER_PATH}    ${TARGET_URL}    ${ROUNDS}
    Register Test Function    ${MODULE_NAME}    TestFunction1
    Register Test Function    ${MODULE_NAME}    TestFunction2
    Execute Tests
    Save Test Results    ${RESULT_FILE}
    Save Analysis Report    ${REPORT_FILE}
    Quit Tester
```

---

## 4. 实施步骤

### 4.1 环境准备

1. 安装依赖：
   ```bash
   pip install selenium robotframework pandas matplotlib
   ```
2. 确保安装了正确版本的 Chrome 浏览器及对应的 `chromedriver`，并将其路径配置到环境变量或提供给测试用例。

### 4.2 运行测试

1. 确保所有文件放置在同一目录下，结构如下：
   ```
   base_function.py
   performance_tester.py
   robot_framework_wrapper.py
   test_functions.py
   web_performance_test.robot
   ```
2. 在命令行中执行 Robot Framework 测试用例：
   ```bash
   robot web_performance_test.robot
   ```

---

## 5. 输出结果

执行完成后，将生成以下文件：
1. **`test_data.json`**：包含所有测试轮次的详细数据，例如每轮的响应时间、JavaScript 内存使用情况等。
   ```json
   [
       {
           "round": 1,
           "function_point": "TestFunction1",
           "round_start_js_memory": {
               "used_MB": 12.34,
               "total_MB": 45.67
           },
           "response_time": 0.456
       }
   ]
   ```
2. **`performance_report.html`**：包含统计分析与可视化图表的综合性能报告，示例如下：
   - **响应时间统计表**：记录平均值、最大值等信息。
   - **JavaScript 内存统计表**：记录平均内存使用情况。
   - **响应时间趋势图**。
   - **JavaScript 内存使用趋势图**。

---

## 6. 结论

本方案通过模块化设计和细粒度数据监控，提供了一套灵活且全面的 Web 客户端性能测试解决方案。其主要优点包括：

1. **动态可扩展性**：支持通过模块化机制动态注册测试功能点。
2. **全面性能监控**：同时监控响应时间和 JavaScript 内存使用情况。
3. **自动化与分析一体化**：结合 Robot Framework 的高效自动化管理能力，输出包含详细数据和图表的性能报告。

该方案适用于 Web 应用的性能基准测试与问题分析，为开发团队提供了优化产品性能的重要依据。