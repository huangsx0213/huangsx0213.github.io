---
layout:     post
title:      "Temp3"
subtitle:   "「 Testing 」" 
date:       2024-12-30 11:00:03
author:     "Vick Huang"
header-img: "img/bg-walle.jpg"
catalog: true
tags:
    - Testing
---



### **方案：基于模块化设计的 Web 客户端性能测试自动化方案**

---

#### **背景**

在现代 Web 应用性能测试中，衡量页面加载时间、按钮点击响应时间、表单提交性能等功能点的表现是关键。一种可扩展的性能测试框架需要能够适应不断变化的功能点需求，且支持对功能点的动态扩展和高效管理。

**Web 客户端性能测试自动化方案**旨在解决以下问题：
1. **模块化与扩展性**：功能点逻辑独立实现，框架通过动态加载功能点模块完成测试。
2. **动态加载与管理**：通过 Python 的 `importlib` 和 `inspect` 模块动态加载功能点类，避免硬编码，使新增功能点时无需修改主框架代码。
3. **自动化集成**：支持与自动化测试框架（如 **Robot Framework**）的无缝集成，基于关键字的方式实现便捷的配置和运行。

该方案采用 **Python**、**Selenium** 和 **Robot Framework** 作为核心技术栈，构建了模块化的性能测试框架。

---

#### **方案结构**

项目文件结构如下：

```
web_client_performance/
├── base_function.py              # 功能点抽象基类
├── performance_tester.py         # 核心测试管理类
├── robot_framework_wrapper.py    # Robot Framework 封装类
├── test_functions.py             # 功能点实现模块
├── web_performance_test.robot    # Robot Framework 测试用例
```

---

### **完整代码**

#### **1. 功能点抽象基类：`base_function.py`**

抽象基类 `TestFunctionBase`，所有功能点类需继承该类并实现其方法。

```python
from abc import ABC, abstractmethod
import time


class TestFunctionBase(ABC):
    """功能点抽象基类"""
    def __init__(self, tester):
        self.tester = tester

    @abstractmethod
    def precondition(self):
        """计时前的操作"""
        pass

    @abstractmethod
    def measure_operation(self):
        """需要计时的核心操作"""
        pass

    @abstractmethod
    def postcondition(self):
        """计时后的操作"""
        pass

    def run(self):
        """执行功能点测试的完整流程"""
        try:
            # 执行前置条件
            self.precondition()
            
            # 测量核心操作
            start_time = time.time()
            self.measure_operation()
            end_time = time.time()
            response_time = end_time - start_time
            
            # 执行后置条件
            self.postcondition()
            
            return response_time
        except Exception as e:
            print(f"Error in {self.__class__.__name__}: {e}")
            return None
```

---

#### **2. 核心测试管理类：`performance_tester.py`**

负责功能点的动态注册、测试执行和结果保存。

```python
import importlib
import inspect
import json
from selenium import webdriver
from base_function import TestFunctionBase


class WebPerformanceTester:
    """核心测试管理类"""
    def __init__(self, driver_path, target_url, rounds=5):
        self.driver = webdriver.Chrome(executable_path=driver_path)
        self.target_url = target_url
        self.rounds = rounds
        self.data = []
        self.function_points = []

    def _get_class_from_module(self, module_name, class_name):
        """动态从模块中加载类"""
        module = importlib.import_module(module_name)
        for name, obj in inspect.getmembers(module, inspect.isclass):
            if name == class_name and issubclass(obj, TestFunctionBase) and obj is not TestFunctionBase:
                return obj
        raise ValueError(f"Class '{class_name}' not found in module '{module_name}'")

    def register_test_function(self, module_name, class_name):
        """动态注册功能点"""
        func_class = self._get_class_from_module(module_name, class_name)
        self.function_points.append(func_class(self))
        print(f"{class_name} from module '{module_name}' registered successfully.")

    def execute_tests(self):
        """执行所有功能点测试"""
        for round_num in range(self.rounds):
            self.driver.get(self.target_url)
            for func in self.function_points:
                response_time = func.run()
                self.data.append({
                    "round": round_num + 1,
                    "function_point": func.__class__.__name__,
                    "response_time": response_time
                })
                print(f"Round {round_num + 1} - {func.__class__.__name__} - Response Time: {response_time} seconds")

    def save_data(self, file_name="test_data.json"):
        """保存测试数据"""
        with open(file_name, "w") as f:
            json.dump(self.data, f, indent=4)
        print(f"Test data saved to {file_name}")

    def quit_driver(self):
        """关闭 WebDriver"""
        self.driver.quit()
```

---

#### **3. Robot Framework 封装类：`robot_framework_wrapper.py`**

封装核心测试管理类，为 Robot Framework 提供关键字支持。

```python
from performance_tester import WebPerformanceTester


class RobotFrameworkWebTester:
    """Robot Framework 封装类"""
    def __init__(self):
        self.tester = None

    def initialize_tester(self, driver_path, target_url, rounds=5):
        """初始化 WebPerformanceTester"""
        self.tester = WebPerformanceTester(driver_path, target_url, int(rounds))
        print("WebPerformanceTester initialized.")

    def register_test_function(self, module_name, class_name):
        """注册功能点"""
        if self.tester:
            self.tester.register_test_function(module_name, class_name)

    def execute_tests(self):
        """执行所有功能点测试"""
        if self.tester:
            self.tester.execute_tests()

    def save_test_results(self, file_name="test_data.json"):
        """保存测试结果到文件"""
        if self.tester:
            self.tester.save_data(file_name)

    def quit_tester(self):
        """关闭测试器"""
        if self.tester:
            self.tester.quit_driver()
```

---

#### **4. 功能点实现模块：`test_functions.py`**

实现具体功能点逻辑，继承 `TestFunctionBase`。

```python
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from base_function import TestFunctionBase


class TestFunction1(TestFunctionBase):
    """功能点 1：模拟点击操作"""
    def precondition(self):
        WebDriverWait(self.tester.driver, 10).until(
            EC.presence_of_element_located((By.ID, "precondition1"))
        )
        print(f"{self.__class__.__name__} - Precondition Completed")

    def measure_operation(self):
        WebDriverWait(self.tester.driver, 10).until(
            EC.element_to_be_clickable((By.ID, "function1"))
        ).click()
        WebDriverWait(self.tester.driver, 10).until(
            EC.presence_of_element_located((By.ID, "result1"))
        )
        print(f"{self.__class__.__name__} - Measure Operation Completed")

    def postcondition(self):
        print(f"{self.__class__.__name__} - Postcondition Completed")


class TestFunction2(TestFunctionBase):
    """功能点 2：模拟输入框提交操作"""
    def precondition(self):
        WebDriverWait(self.tester.driver, 10).until(
            EC.presence_of_element_located((By.ID, "precondition2"))
        )
        print(f"{self.__class__.__name__} - Precondition Completed")

    def measure_operation(self):
        input_field = WebDriverWait(self.tester.driver, 10).until(
            EC.presence_of_element_located((By.ID, "function2"))
        )
        input_field.send_keys("性能测试")
        WebDriverWait(self.tester.driver, 10).until(
            EC.element_to_be_clickable((By.ID, "submit2"))
        ).click()
        WebDriverWait(self.tester.driver, 10).until(
            EC.presence_of_element_located((By.ID, "result2"))
        )
        print(f"{self.__class__.__name__} - Measure Operation Completed")

    def postcondition(self):
        input_field = self.tester.driver.find_element(By.ID, "function2")
        input_field.clear()
        print(f"{self.__class__.__name__} - Postcondition Completed")
```

---

#### **5. Robot Framework 测试用例：`web_performance_test.robot`**

通过模块名和类名动态注册功能点，执行测试并保存结果。

```robot
*** Settings ***
Library           robot_framework_wrapper.py

*** Variables ***
${CHROME_DRIVER_PATH}    /path/to/chromedriver
${TARGET_URL}            https://example.com
${ROUNDS}               5
${RESULT_FILE}          test_data.json
${MODULE_NAME}          test_functions

*** Test Cases ***
Web 客户端性能测试
    Initialize Tester    ${CHROME_DRIVER_PATH}    ${TARGET_URL}    ${ROUNDS}
    Register Test Function    ${MODULE_NAME}    TestFunction1
    Register Test Function    ${MODULE_NAME}    TestFunction2
    Execute Tests
    Save Test Results    ${RESULT_FILE}
    Quit Tester
```

---

### **运行步骤**

1. **安装依赖**：
   ```bash
   pip install robotframework selenium
   ```

2. **运行测试用例**：
   ```bash
   robot web_performance_test.robot
   ```

---

### **输出结果**

1. **控制台输出**：
   - 显示功能点注册、测试执行和响应时间。
   ```
   TestFunction1 from module 'test_functions' registered successfully.
   Round 1 - TestFunction1 - Response Time: 1.23 seconds
   ```

2. **结果文件**：
   - 生成 `test_data.json`，示例如下：
     ```json
     [
         {
             "round": 1,
             "function_point": "TestFunction1",
             "response_time": 1.23
         },
         {
             "round": 1,
             "function_point": "TestFunction2",
             "response_time": 2.34
         }
     ]
     ```

---

通过本方案，性能测试框架实现了模块化与动态扩展，功能点解耦，易于管理和扩展，同时与 **Robot Framework** 的无缝集成使得测试流程更加自动化和高效。