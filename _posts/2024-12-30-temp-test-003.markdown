---
layout:     post
title:      "Temp3"
subtitle:   "「 Testing 」" 
date:       2024-12-30 11:00:03
author:     "Vick Huang"
header-img: "img/bg-walle.jpg"
catalog: true
tags:
    - Testing
---



以下是完整的方案和代码实现。该方案动态查找功能点类，无需维护硬编码的映射字典（`function_mapping`）。整个流程包含：

1. **功能点抽象**：
   - 抽象基类 `TestFunctionBase` 规定了功能点的 `precondition`、`measure_operation` 和 `postcondition`。
   - 功能点类（如 `TestFunction1`）继承该基类并实现自己的逻辑。

2. **动态注册功能点**：
   - 使用 Python 的 `inspect` 模块，动态扫描所有继承自 `TestFunctionBase` 的类并实例化对应功能点。

3. **Robot Framework 支持**：
   - 提供初始化测试器、动态注册功能点、执行测试、保存结果和释放资源的关键字，供 Robot Framework 调用。

---

### **完整代码**

#### **Python 模块：`web_performance_tester.py`**

这是核心 Python 模块，定义了测试器类、功能点基类及其实现，同时提供了 Robot Framework 的关键字接口。

```python
import inspect
import sys
from abc import ABC, abstractmethod
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import time
import json


class TestFunctionBase(ABC):
    """功能点抽象基类"""
    def __init__(self, tester):
        self.tester = tester

    @abstractmethod
    def precondition(self):
        """计时前的操作"""
        pass

    @abstractmethod
    def measure_operation(self):
        """需要计时的核心操作"""
        pass

    @abstractmethod
    def postcondition(self):
        """计时后的操作"""
        pass

    def run(self):
        """执行功能点测试的完整流程"""
        try:
            # Step 1: Precondition
            self.precondition()

            # Step 2: Measure Operation
            start_time = time.time()
            self.measure_operation()
            end_time = time.time()
            response_time = end_time - start_time

            # Step 3: Postcondition
            self.postcondition()

            return response_time
        except Exception as e:
            print(f"Error in {self.__class__.__name__}: {e}")
            return None


class TestFunction1(TestFunctionBase):
    """功能点1"""
    def precondition(self):
        WebDriverWait(self.tester.driver, 10).until(
            EC.presence_of_element_located((By.ID, "precondition1"))
        )
        print(f"{self.__class__.__name__} - Precondition Completed")

    def measure_operation(self):
        WebDriverWait(self.tester.driver, 10).until(
            EC.element_to_be_clickable((By.ID, "function1"))
        ).click()
        WebDriverWait(self.tester.driver, 10).until(
            EC.presence_of_element_located((By.ID, "result1"))
        )
        print(f"{self.__class__.__name__} - Measure Operation Completed")

    def postcondition(self):
        print(f"{self.__class__.__name__} - Postcondition Completed")


class TestFunction2(TestFunctionBase):
    """功能点2"""
    def precondition(self):
        WebDriverWait(self.tester.driver, 10).until(
            EC.presence_of_element_located((By.ID, "precondition2"))
        )
        print(f"{self.__class__.__name__} - Precondition Completed")

    def measure_operation(self):
        input_field = WebDriverWait(self.tester.driver, 10).until(
            EC.presence_of_element_located((By.ID, "function2"))
        )
        input_field.send_keys("测试文本")
        WebDriverWait(self.tester.driver, 10).until(
            EC.element_to_be_clickable((By.ID, "submit2"))
        ).click()
        WebDriverWait(self.tester.driver, 10).until(
            EC.presence_of_element_located((By.ID, "result2"))
        )
        print(f"{self.__class__.__name__} - Measure Operation Completed")

    def postcondition(self):
        input_field = self.tester.driver.find_element(By.ID, "function2")
        input_field.clear()
        print(f"{self.__class__.__name__} - Postcondition Completed")


class WebPerformanceTester:
    """测试管理类"""
    def __init__(self, driver_path, target_url, rounds=5):
        self.driver = webdriver.Chrome(executable_path=driver_path)
        self.target_url = target_url
        self.rounds = rounds
        self.data = []
        self.function_points = []

    def _get_class_by_name(self, class_name):
        """
        动态查找功能点类
        :param class_name: 功能点类名
        :return: 功能点类对象
        """
        current_module = sys.modules[__name__]
        for name, obj in inspect.getmembers(current_module, inspect.isclass):
            if name == class_name and issubclass(obj, TestFunctionBase) and obj is not TestFunctionBase:
                return obj
        raise ValueError(f"Function class '{class_name}' not found.")

    def register_test_function(self, function_name):
        """
        动态注册功能点
        :param function_name: 功能点类名
        """
        func_class = self._get_class_by_name(function_name)
        self.function_points.append(func_class(self))
        print(f"{function_name} registered successfully.")

    def execute_tests(self):
        """执行所有测试功能点"""
        for round_num in range(self.rounds):
            self.driver.get(self.target_url)
            for func in self.function_points:
                response_time = func.run()
                self.data.append({
                    "round": round_num + 1,
                    "function_point": func.__class__.__name__,
                    "response_time": response_time
                })
                print(f"Round {round_num + 1} - {func.__class__.__name__} - Response Time: {response_time} seconds")

    def save_data(self, file_name="test_data.json"):
        """保存测试数据"""
        with open(file_name, "w") as f:
            json.dump(self.data, f, indent=4)
        print(f"Test data saved to {file_name}")

    def quit_driver(self):
        """关闭 WebDriver"""
        self.driver.quit()


class RobotFrameworkWebTester:
    """Robot Framework Wrapper"""
    def __init__(self):
        self.tester = None

    def initialize_tester(self, driver_path, target_url, rounds=5):
        """初始化 WebPerformanceTester"""
        self.tester = WebPerformanceTester(driver_path, target_url, int(rounds))
        print("WebPerformanceTester initialized.")

    def register_test_function(self, function_name):
        """动态注册功能点"""
        if self.tester:
            self.tester.register_test_function(function_name)

    def execute_tests(self):
        """执行所有测试功能点"""
        if self.tester:
            self.tester.execute_tests()

    def save_test_results(self, file_name="test_data.json"):
        """保存测试结果到文件"""
        if self.tester:
            self.tester.save_data(file_name)

    def quit_tester(self):
        """关闭 WebDriver"""
        if self.tester:
            self.tester.quit_driver()
```

---

#### **Robot Framework 测试用例：`web_performance_test.robot`**

```robot
*** Settings ***
Library           web_performance_tester.py

*** Variables ***
${CHROME_DRIVER_PATH}    /path/to/chromedriver
${TARGET_URL}            https://example.com
${ROUNDS}               5
${RESULT_FILE}          test_data.json

*** Test Cases ***
Web Performance Test
    [Documentation]    测试网页性能，包括动态注册功能点、执行测试和保存结果。
    Initialize Tester    ${CHROME_DRIVER_PATH}    ${TARGET_URL}    ${ROUNDS}
    Register Test Function    TestFunction1
    Register Test Function    TestFunction2
    Execute Tests
    Save Test Results    ${RESULT_FILE}
    Quit Tester
```

---

### **方案说明**

1. **动态功能点查找**：
   - 使用 `inspect.getmembers` 动态查找所有继承自 `TestFunctionBase` 的类，避免硬编码功能点映射。

2. **功能点注册**：
   - 在 Robot Framework 中通过 `Register Test Function` 关键字动态注册功能点。

3. **功能点扩展**：
   - 添加新功能点时，只需定义新的功能点类，无需修改测试器逻辑。

4. **测试数据保存**：
   - 测试结果（包括响应时间）保存为 JSON 文件，便于后续分析。

5. **Robot Framework 支持**：
   - 提供关键字操作：初始化测试器、动态注册功能点、执行测试、保存结果和关闭测试器。

---

### **运行步骤**

1. **安装依赖**：
   ```bash
   pip install robotframework selenium
   ```

2. **运行测试用例**：
   ```bash
   robot web_performance_test.robot
   ```

---

### **运行结果**

1. **控制台输出**：
   - 显示功能点注册、每轮测试的响应时间等信息。

2. **JSON 文件**：
   - `test_data.json` 包含如下数据：
     ```json
     [
         {
             "round": 1,
             "function_point": "TestFunction1",
             "response_time": 1.23
         },
         {
             "round": 1,
             "function_point": "TestFunction2",
             "response_time": 2.34
         }
     ]
     ```

通过上述方案，功能点的动态管理更加灵活，整个测试流程易于扩展和维护。